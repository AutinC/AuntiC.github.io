<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《qt5开发及实例 第4版》第二章-模板库、工具类及控件</title>
      <link href="/2024/02/21/qt5-kai-fa-ji-shi-li-di-4-ban-di-er-zhang-mo-ban-ku-gong-ju-lei-ji-kong-jian/"/>
      <url>/2024/02/21/qt5-kai-fa-ji-shi-li-di-4-ban-di-er-zhang-mo-ban-ku-gong-ju-lei-ji-kong-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><p>优点：保存16位Unicode值；丰富的操作、查询、转换函数；<strong>隐式共享；内存分配高效</strong>。</p><h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><ul><li><p><strong>“+”</strong>可以<strong>组合</strong>两个字符串，<strong>“+=”</strong>把一个字符串<strong>追加</strong>到另一个的末尾。</p></li><li><p><strong>QObject::tr()<strong>函数</strong>用来使字符串便于利用插件翻译</strong>，如果程序员想在开发过程中对所有显示给用户的字符串要求必须使用tr()函数，就可以通过<strong>QT_CAST_FROM_ASCII</strong>宏屏蔽QString构造函数。</p></li><li><p>**QString::append()**函数用途与“+=”相同。</p></li><li><p>**QString::sprintf()**函数用来组合字符串，其支持的格式定义符与C++一样</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str;</span><br><span class="line">str.<span class="built_in">sprintf</span>(<span class="string">"%s %s"</span>, <span class="string">"Welcome"</span>, <span class="string">"to you!"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>QString::arg()<strong>函数也用来组合字符串，其类型安全，支持Unicode，允许</strong>使用“%n“参数改变字符</strong>顺序，其重载版本参数可以对<strong>字段宽度、数字基数或浮点数精度</strong>进行控制。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QString str;</span><br><span class="line">str = <span class="built_in">QString</span>(<span class="string">"%1 was born in %2."</span>).<span class="built_in">arg</span>(<span class="string">"John"</span>).<span class="built_in">arg</span>(<span class="string">"1999"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p>其他组合字符串的方法：</p><ul><li><strong>insert()<strong>：在原字符串</strong>特定位置插入</strong>另一字符串；</li><li><strong>prepend()<strong>：在原字符串</strong>开头插入</strong>另一字符串；</li><li><strong>replace()<strong>：用指定字符串</strong>代替</strong>原字符串某些字符。</li></ul></li><li><p>去除字符串两端空白，如回车字符“\n”、换行字符”\r“、制表符”\t”、空格字符” ”等：</p><ul><li>QString::trimmed()：<strong>移除字符串两端空白字符</strong>；</li><li>QString::simplified()：<strong>移除字符串两端空白字符，并使用单个空格字符” “代替字符串中的空白字符</strong>。</li></ul></li></ul><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><ul><li><strong>QString::startsWith()判断一个字符串A是否以某个字符串B开头</strong>，第一个参数指定B，第二个参数指定是否区分大小写（默认区分）.</li><li><strong>QString::endsWith()判断一个字符串A是否以某个字符串B结尾</strong>，参数同上</li><li><strong>QString::contains()判断一个一个字符串A是否包含某个字符串B，参数同上</strong></li><li>比较两个字符串：<ul><li>**&lt;、&lt;=、==、&gt;=**重载运算法按照字典序进行比较；</li><li><strong>localeAwareCompare()<strong>根据本地字符集进行比较，与平台相关，一般用来向用户显示一个有序的字符串列表，</strong>当前面的字符串小于后面时，返回负整数，等于就返回0，大于就返回正整数；</strong></li><li><strong>compare()基于字符串的Unicode编码比较</strong>，返回值同上，可以设置第三个参数是否进行大小写比较。</li></ul></li></ul><h3 id="转换字符串"><a href="#转换字符串" class="headerlink" title="转换字符串"></a>转换字符串</h3><ul><li><p>字符串转数值：</p><ul><li><strong>QString::toInt()转为整数类型</strong>，第一个参数是bool指针，指示转换状态，第二个参数是转换的基数，如16进制和8进制等；</li><li><strong>QString::toDouble()转为双精度浮点数类型</strong>；</li><li><strong>QString::toFloat()转为浮点数类型</strong>；</li><li><strong>QString::toLong()转为长整类型</strong>；</li><li><strong>QString::toLongLong()转为长长整数类型</strong>。</li></ul></li><li><p>字符串转换编码集，均返回<strong>QByteArray</strong>对象：</p><ul><li>**toAscii()**：返回一个ASCII编码的8位字符串；</li><li>**toLatin1()**：返回一个Latin-1(ISO8859-1)编码的8位字符串；</li><li>**toUtf8()**：返回一个UTF-8编码的8位字符串；</li><li>**toLocal8Bit()**：返回一个本地编码的8位字符串。</li></ul></li><li><p>一个NULL字符串是QString默认构造的字符串对象，空字符串是大小为0的字符串；<strong>NULL一定是空，空不一定是NULL。</strong></p></li></ul><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>存储在容器类的元素必须可赋值，也就是一定要有：<strong>默认构造函数、拷贝构造函数、赋值操作运算符</strong>，<strong>对于QObjcet和其子类这些不能赋值的对象，可以存储指针</strong>。</p><h3 id="QList、QLinkedList、QVector"><a href="#QList、QLinkedList、QVector" class="headerlink" title="QList、QLinkedList、QVector"></a>QList、QLinkedList、QVector</h3><p><img src="https://gcdnb.pbrd.co/images/ss209MeMzTE0.jpg?o=1"></p><ul><li><p>QList维护了一个<strong>指针数组</strong>，各指针元素指向具体内容，因此其提供了<strong>基于下标的快速访问</strong>。</p></li><li><p>QList的子类有：<strong>QItemSelection、QQueue、QSignalSpy、QStringList、QTestEventList</strong>。</p></li><li><p>QList操作：**QList::append()、QList::prepend()、QList::Insert()**。</p></li><li><p>QList的两种存储策略：</p><ul><li>元素是指针类型或指针大小的类型，直接存储；</li><li>只存储对象指针。</li></ul></li><li><p>QLinkedList是非连续内存的<strong>链表</strong>，只能用迭代器访问，插入效率高。</p></li><li><p>QVector是相邻内存的<strong>数组</strong>，支持下标和迭代器访问。</p></li><li><p>QVector的子类有：<strong>QPloygon、QPolygonF、QStack</strong>。</p></li><li><p>容器类有Java风格的迭代器和STL风格的迭代器两种：</p><ul><li><p>Java风格的迭代器指向的是元素间隙，如第一个元素之前，两个元素之间和最后一个元素之后</p><p><img src="https://gcdnb.pbrd.co/images/LBPPTmGPM7Nq.jpg?o=1"></p></li><li><p>STL风格的迭代指向的是元素</p><p><img src="https://gcdnb.pbrd.co/images/4zH4TVYgGQaT.jpg?o=1"></p></li></ul></li></ul><h3 id="QMap、QHash"><a href="#QMap、QHash" class="headerlink" title="QMap、QHash"></a>QMap、QHash</h3><ul><li><p>QHash比QMap<strong>查找速度更快</strong>。</p></li><li><p>QHash以<strong>任意顺序</strong>存储元素，QMap按照<strong>键的顺序</strong>存储元素。</p></li><li><p>QHash的键Key必须提供**operator==()和全局的qHash(Key)<strong>函数，QMap的键Key必须提供</strong>operator&lt;()**函数。</p></li><li><p>二者时间复杂度：</p><p><img src="https://gcdnb.pbrd.co/images/aF4berqQzwne.jpg?o=1"></p></li><li><p>为了实现一键多值，QMap提供**QMap&lt;Key,T&gt;::insertMulti()和QMap&lt;Key,T&gt;::values()<strong>函数，也可以使用</strong>QMultiMap&lt;Key,T&gt;**，其继承于QMap。</p></li><li><p>QHash底层维护<strong>哈希表</strong>，当存储数据的顺序无关紧要时，建议使用；**QMultiHash&lt;Key,T&gt;**实现一键多值。</p></li><li><p>容器类有Java风格的迭代器和STL风格的迭代器两种：</p><p><img src="https://gcdnb.pbrd.co/images/lU6TZy3rwFNm.jpg?o=1"></p><p><img src="https://gcdnb.pbrd.co/images/RWYwMHJgdr5o.jpg?o=1"></p></li></ul><h3 id="QVariant类"><a href="#QVariant类" class="headerlink" title="QVariant类"></a>QVariant类</h3><ul><li><p>类似C++的<strong>联合（Union）</strong>类型</p></li><li><p>实例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ui_widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVariant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QColor&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">{</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">QVariant <span class="title">v</span><span class="params">(<span class="number">709</span>)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; v.<span class="built_in">toInt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QVariant <span class="title">w</span><span class="params">(<span class="string">"How are you!"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; w.<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line">    QMap&lt;QString, QVariant&gt; map;</span><br><span class="line">    map[<span class="string">"int"</span>] = <span class="number">709</span>;</span><br><span class="line">    map[<span class="string">"double"</span>] = <span class="number">709.709</span>;</span><br><span class="line">    map[<span class="string">"string"</span>] = <span class="string">"How are you!"</span>;</span><br><span class="line">    map[<span class="string">"color"</span>] = <span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; map[<span class="string">"int"</span>] &lt;&lt; map[<span class="string">"int"</span>].<span class="built_in">toInt</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; map[<span class="string">"double"</span>] &lt;&lt; map[<span class="string">"double"</span>].<span class="built_in">toDouble</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; map[<span class="string">"string"</span>] &lt;&lt; map[<span class="string">"string"</span>].<span class="built_in">toString</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; map[<span class="string">"color"</span>] &lt;&lt; map[<span class="string">"color"</span>].<span class="built_in">value</span>&lt;QColor&gt;();</span><br><span class="line"></span><br><span class="line">    QStringList sl;</span><br><span class="line">    sl &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="string">"C"</span> &lt;&lt; <span class="string">"D"</span>;</span><br><span class="line">    <span class="function">QVariant <span class="title">slv</span><span class="params">(sl)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(slv.<span class="built_in">type</span>() == QVariant::StringList)</span><br><span class="line">    {</span><br><span class="line">        QStringList list = slv.<span class="built_in">toStringList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; list.<span class="built_in">at</span>(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">709</span></span><br><span class="line"><span class="string">"How are you!"</span></span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">int</span>, <span class="number">709</span>) <span class="number">709</span></span><br><span class="line"><span class="built_in">QVariant</span>(<span class="type">double</span>, <span class="number">709.709</span>) <span class="number">709.709</span></span><br><span class="line"><span class="built_in">QVariant</span>(QString, <span class="string">"How are you!"</span>) <span class="string">"How are you!"</span></span><br><span class="line"><span class="built_in">QVariant</span>(QColor, <span class="built_in">QColor</span>(ARGB <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)) <span class="built_in">QColor</span>(ARGB <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="string">"A"</span></span><br><span class="line"><span class="string">"B"</span></span><br><span class="line"><span class="string">"C"</span></span><br><span class="line"><span class="string">"D"</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>qDebug() &lt;&lt; map[“color”] &lt;&lt; map[“color”].value&lt;QColor&gt;():</p><p>在Variant中保存了一个QColor对象，使用<strong>QVariant::value()<strong>还原为QColor，QVariant是</strong>QtCore</strong>中的类，<strong>所有没有为QtGui中的数据类型（QColor、QImage、QPixmap等）提供转换函数</strong>。</p></li></ul></li><li><p>QVariant::type类型变量见表：</p><p><img src="https://gcdnb.pbrd.co/images/8zGnddXPu5r3.jpg?o=1"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《qt5开发及实例 第4版》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《qt5开发及实例 第4版》第一章-概述</title>
      <link href="/2024/02/20/qt5-kai-fa-ji-shi-li-di-4-ban-di-yi-zhang-gai-shu/"/>
      <url>/2024/02/20/qt5-kai-fa-ji-shi-li-di-4-ban-di-yi-zhang-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="QT5开发环境"><a href="#QT5开发环境" class="headerlink" title="QT5开发环境"></a>QT5开发环境</h2><h3 id="QT-Designer-控件-视图"><a href="#QT-Designer-控件-视图" class="headerlink" title="QT Designer->控件->视图"></a>QT Designer-&gt;控件-&gt;视图</h3><ul><li><p>对象查看器：主界面中的所有窗口部件以及各部件的<strong>父子关系、包容关系</strong></p></li><li><p>属性编辑器：部件的可编辑属性</p></li><li><p>Action编辑器：部件的QAction动作</p></li><li><p>信号和槽编辑器：关联的信号和槽</p></li></ul><h3 id="QT-Designer-编辑"><a href="#QT-Designer-编辑" class="headerlink" title="QT Designer->编辑"></a>QT Designer-&gt;编辑</h3><ul><li>控件编辑模式：在主界面添加GUI窗口并修改属性和外观</li><li>信号和槽编辑模式：在主界面的窗口部件上关联已经定义好的信号和槽</li><li>伙伴编辑模式：在主界面的窗口部件建立QLabel标签和其他窗口部件的伙伴关系</li><li>Tab顺序编辑模式：在主界面的窗口部件设置Tab键在窗口部件上的焦点顺序</li></ul><h3 id="main函数组成"><a href="#main函数组成" class="headerlink" title="main函数组成"></a>main函数组成</h3><ul><li><p><strong>dialog.h</strong></p><p>Dialog类的定义，使用到哪个类就要把该类的头文件引用，如使用到了按钮类，就要添加一个&lt;QpushButton&gt;</p></li><li><p><strong>QApplication</strong></p><p>Application类的定义，每个使用Qt图形化应用程中都必须使用一个QApplication对象，其中管理了资源、基本设置、控制流及事件处理等</p></li><li><p><strong>QApplication a(argc,argv)</strong></p><p>a是这个程序的Qapplication对象，在任何Qt窗口中的部件在使用之前必须创建该对象</p></li><li><p><strong>w.show()</strong></p><p>创建一个窗口时默认其不可见，用show可见</p></li><li><p><strong>return a.exec()</strong></p><p>程序进入消息循环，等待可能的输入进行响应，main把控制权给Qt，Qt完成事件处理，程序退出时exec()函数的值就会返回，在exec中Qt接收并处理用户和系统事件并把它们传递给适当的部件。</p></li></ul><h3 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h3><ul><li><p>信号**AbstractButton::clicked()与Dialog::on_button_clicked()**槽自动关联</p><p>手动关联：connect(button, SIGNAL(clicked()), this, SLOT(showArea()))；</p></li><li><p><strong>一个信号可以与另一个信号关联；一个信号可以与多个槽关联；一个槽可以关联多个信号</strong></p></li><li><p>SIGNAL()和SLOT()是两个宏，<strong>返回其参数的C语言风格字符串（const char*）</strong></p></li><li><p>优点：</p><ul><li><strong>类型安全。</strong>信号的参数类型和参数个数必须与槽的参数类型和个数相同，槽的参数个数可以少于信号的参数个数，但缺少的参数必须是信号参数的最后一个或几个。</li><li><strong>松散耦合。</strong>激发信号的对象不需要知道哪个对象的槽接受它，接收信号的对象也不需要知道哪些信号关联了自己的槽</li></ul></li><li><p>一个类若要支持信号与槽，必须继承QObject或其子类</p></li><li><p>信号和槽不支持模板的使用</p></li><li><p>信号与槽比直接调用非虚函数<strong>慢10倍</strong>，因为：</p><ul><li>需要定位接收信号的对象</li><li>安全地遍历所有关联</li><li>编组/解组参数</li><li>多线程时，信号要排队等待</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《qt5开发及实例 第4版》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》29-模式总结</title>
      <link href="/2024/01/10/da-hua-she-ji-mo-shi-29-mo-shi-zong-jie/"/>
      <url>/2024/01/10/da-hua-she-ji-mo-shi-29-mo-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li><p>简单工厂模式每次扩展都要更改工厂类，对修改开放，<strong>不符合开闭原则</strong></p></li><li><p>设计模式核心是<strong>面向对象</strong>，依赖于<strong>抽象、封装、继承、多态</strong></p></li><li><p>重要原则包括：<strong>单一职责、开放封闭、依赖倒转、里氏代换、合成聚和复用、迪米特</strong></p></li><li><p>面向过程设计开发容易，但不容易应对变化；面向对象设计开发困难，但能应对千变万化</p></li><li><p>设计模式可以分为：<strong>创建型模式、结构型模式和行为型模式</strong></p><p><img src="https://gcdnb.pbrd.co/images/U0R4OCXn8PPB.jpg?o=1"></p></li></ul><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式隐藏了类的实例是如何被创建和放在一起的，<strong>整个系统关于这些对象所知道的是由抽象类定义的接口</strong>，使得创建了什么、谁创建它、它是怎么被创建的、何时被创建的都提供很大的灵活性。</p><p><em>如何实现松耦合？</em></p><p>将一个复杂对象的构建和表示分离，可以很容易改变一个产品的内部表示，客户无需关心产品的构造过程。</p><h3 id="1-抽象工厂"><a href="#1-抽象工厂" class="headerlink" title="1. 抽象工厂"></a>1. <strong>抽象工厂</strong></h3><p>提供一个创建一系列或者相关依赖对象的接口，且无需指定它们具体的类。</p><p><img src="https://gcdnb.pbrd.co/images/156kaHoL7LKR.jpg?o=1"></p><p>可以解决多个类型产品的创建问题，可以实现同一对象与多个数据库的ORM（Objected-Relational Mapping，用于在面向对象编程语言和关系型数据库之间建立映射关系，从而实现通过面向对象的方式操作数据库）。</p><h3 id="2-建造者"><a href="#2-建造者" class="headerlink" title="2. 建造者"></a>2. 建造者</h3><p>将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同表示。</p><p><img src="https://gcdnb.pbrd.co/images/E7uhX0HHpUUy.jpg?o=1"></p><p>实现过程隐藏，一个请求就可以创建完整的产品，高内聚，与外界耦合低。</p><h3 id="3-工厂方法"><a href="#3-工厂方法" class="headerlink" title="3. 工厂方法"></a>3. 工厂方法</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。</p><p><img src="https://gcdnb.pbrd.co/images/y7BnwmfYTkha.jpg?o=1"></p><h3 id="4-原型"><a href="#4-原型" class="headerlink" title="4. 原型"></a>4. 原型</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><img src="https://gcdnb.pbrd.co/images/nCo0HhflVO7J.jpg?o=1"></p><p>调用原型的Clone可以解决数据结构的拷贝问题，Copy不仅可以复制结构，数据也可以复制。</p><h3 id="5-单例"><a href="#5-单例" class="headerlink" title="5. 单例"></a>5. 单例</h3><p>保证一个类仅由一个实例，并提供一个访问它的全局访问点。</p><p><img src="https://gcdnb.pbrd.co/images/bCWRWKQt6Rhi.jpg?o=1"></p><p>可以严格控制客户怎样、何时访问全局实例。</p><h2 id="结构型模型"><a href="#结构型模型" class="headerlink" title="结构型模型"></a>结构型模型</h2><h3 id="1-适配器"><a href="#1-适配器" class="headerlink" title="1. 适配器"></a>1. 适配器</h3><p>讲一个类的接口转换成客户希望的另一个接口，使得原本接口不兼容而不能一起工作的那些类可以一起工作。</p><p><img src="https://gcdnb.pbrd.co/images/xzo1zQIxlL8H.jpg?o=1"></p><p>想用一个已经存在的类，而它的接口不符合要求，或者希望创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。</p><h3 id="2-桥接"><a href="#2-桥接" class="headerlink" title="2. 桥接"></a>2. 桥接</h3><p>将抽象部分与实现部分分离，使得它们可以独立地变化。</p><p><img src="https://gcdnb.pbrd.co/images/QCUtufTQEL7O.jpg?o=1"></p><p>用聚合代替继承，把两个角色间的继承关系改为了组合关系，可以应对各自的变化。</p><h3 id="3-组合"><a href="#3-组合" class="headerlink" title="3. 组合"></a>3. 组合</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p><img src="https://gcdnb.pbrd.co/images/0eUkpln9dF6O.jpg?o=1"></p><p>客户可以一致地使用组合结构和单个对象，任何用到基本对象的地方都可以使用组合对象。</p><h3 id="4-装饰"><a href="#4-装饰" class="headerlink" title="4. 装饰"></a>4. 装饰</h3><p>动态地给一个对象添加一些额外的职责，比生成子类更灵活。</p><p><img src="https://gcdnb.pbrd.co/images/i9JOu7rm6Ytd.jpg?o=1"></p><p>子类大多是为某个对象增加一些职责，通过装饰可以动态透明的给单个对象添加职责。</p><h3 id="5-外观"><a href="#5-外观" class="headerlink" title="5. 外观"></a>5. 外观</h3><p>为子系统中的一组接口提供一个一致的界面，定义了一个高层接口使得子系统更容易使用。</p><p><img src="https://gcdnb.pbrd.co/images/A49w50V6BrSE.jpg?o=1"></p><p>引入一个外观对象，为子系统间提供单一简单的屏障，可以让软件中子系统的通信和依赖最小。</p><h3 id="6-享元"><a href="#6-享元" class="headerlink" title="6. 享元"></a>6. 享元</h3><p>为运用共享技术有效地支持大量细粒度对象。</p><p><img src="https://gcdnb.pbrd.co/images/VcjR6M1e8ndq.jpg?o=1"></p><p>让所有相同的对象共享同一资源。</p><h3 id="7-代理"><a href="#7-代理" class="headerlink" title="7. 代理"></a>7. 代理</h3><p>为其他对象提供一种代理以控制对这个对象的访问。</p><p><img src="https://gcdnb.pbrd.co/images/vmTYZu3MWzhf.jpg?o=1"></p><p>与外观的区别：代理对象代表一个单一对象而外观对象代表一个子系统；代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化共同层次调用接口</p><p>与适配器的区别：代理是原对象的代表，其他与原对象的交互都需要和代表进行，适配器不需要虚构一个代表着，只需要应付特定使用目的，对原来的类进行一些组合。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="1-观察者"><a href="#1-观察者" class="headerlink" title="1. 观察者"></a>1. 观察者</h3><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p><p><img src="https://gcdnb.pbrd.co/images/Kf0d2ryAU1A5.jpg?o=1"></p><h3 id="2-模板方法"><a href="#2-模板方法" class="headerlink" title="2. 模板方法"></a>2. 模板方法</h3><p>定义一个操作的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="https://gcdnb.pbrd.co/images/46xEWI27J3wA.jpg?o=1"></p><p>由一个抽象类组成，该抽象类定义了需要覆盖的可能有不同实现的模板方法，每个从这个抽象类派生的具体类将为此模板实现新方法，使得所有可重复的代码被提炼到抽象类。</p><h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h3><p>将一个请求封装为一个对象，从而可以用不用的请求对客户进行参数化，可以对请求排队或记录请求日志以及支持可撤销的操作。</p><p><img src="https://gcdnb.pbrd.co/images/fLKiPQbJ4J4Q.jpg?o=1"></p><p>将调用操作的对象和知道如何实现该操作的对象解耦，可以在这两者间处理额外的事，可以支持事务的实现。</p><h3 id="4-状态"><a href="#4-状态" class="headerlink" title="4. 状态"></a>4. 状态</h3><p>允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类。</p><p><img src="https://gcdnb.pbrd.co/images/Jds5Dc9vFRbx.jpg?o=1"></p><p>提供了一个更好的方法来组织与特定状态相关的代码，决定状态转移的逻辑不在单个if或switch中，而是分布在各个状态子类间，通过定义新的子类可以很容易增加新的状态和转换。</p><h3 id="5-职责链"><a href="#5-职责链" class="headerlink" title="5. 职责链"></a>5. 职责链</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理该请求</p><p><img src="https://gcdnb.pbrd.co/images/8PpuxzL1qd4t.jpg?o=1"></p><p>当有多个对象可以处理一个请求的时候，事先不知道具体哪个对象处理，运行时确定，就可以让所有请求串成链。</p><h3 id="6-解释器"><a href="#6-解释器" class="headerlink" title="6. 解释器"></a>6. 解释器</h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器来解释语言中的句子。</p><p><img src="https://gcdnb.pbrd.co/images/kwtzSg1y3jkw.jpg?o=1"></p><p>如果一种特定类型的问题发生频率足够高们就可以把该问题的各个实例描述为一个简单语言中的句子。</p><h3 id="7-中介者"><a href="#7-中介者" class="headerlink" title="7. 中介者"></a>7. 中介者</h3><p>用一个中介对象来封装一系列的对象交互，使各对象不需要显式的互相引用，从而使其耦合松散，可以独立的改变它们之间的交互。</p><p><img src="https://gcdnb.pbrd.co/images/6xHXsnYuWR4A.jpg?o=1"></p><p>将集体行为封装到一个中介者对象来控制和协调一组对象间的交互，减少对象间耦合。</p><h3 id="8-访问者"><a href="#8-访问者" class="headerlink" title="8. 访问者"></a>8. 访问者</h3><p>一个作用域某对象结构中的各元素的操作，可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p><img src="https://gcdnb.pbrd.co/images/5uQ1fWpcy3VL.jpg?o=1"></p><p>增加具体的Element困难，增加依赖于复杂对象结构的构建很容易，仅需增加一个新的访问者即可在一个对象的构件上定义一个新的操作。</p><h3 id="9-策略"><a href="#9-策略" class="headerlink" title="9. 策略"></a>9. 策略</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换，使得算法可以独立于使用它的客户而变化。</p><p><img src="https://gcdnb.pbrd.co/images/zy8BJLpvOCIH.jpg?o=1"></p><h3 id="10-备忘录"><a href="#10-备忘录" class="headerlink" title="10. 备忘录"></a>10. 备忘录</h3><p>不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，就可以将该对象恢复到原先保存的状态。</p><p><img src="https://gcdnb.pbrd.co/images/z2decNwIHz82.jpg?o=1"></p><p>把复杂对象的内部信息对其他对象拼比起来，保持封装边界。</p><h3 id="11-迭代器"><a href="#11-迭代器" class="headerlink" title="11. 迭代器"></a>11. 迭代器</h3><p>提供一种方法顺序的访问一个聚合对象中各个元素，而不需要暴露该对象的内部表示。</p><p><img src="https://gcdnb.pbrd.co/images/cJXdsG9vYUdz.jpg?o=1"></p><p>将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，定义一个访问该列表元素的接口，迭代器对象负责追踪当前的元素，并且知道哪些元素已经遍历。</p><h2 id="薪资管理系统开发"><a href="#薪资管理系统开发" class="headerlink" title="薪资管理系统开发"></a>薪资管理系统开发</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>逻辑：普通员工：月薪+月奖金；市场和销售员工：月薪+月提成；中高级管理员工：年薪+年分红；兼职和临时员工：时薪；</p><p>系统：菜单、工具栏、状态栏</p><p>存储：SQL Server，后期用Oracle、MySQL做持久化</p><p>功能：查询薪资、统计薪资、生成统计图</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><strong>外观模式：</strong>表示层、业务外观层、业务逻辑层、数据访问层。增加业务外观层保证表示层的任何变化（使用客户端软件或网页）不会影响业务和数据设计</li><li><strong>观察者模式：</strong>表示层使用事件驱动技术，点击按钮触发事件</li><li><strong>适配器模式：</strong>生成统计图可用已有组件，让业务模块依赖一个抽象的生成图接口，对于第三方的接口不统一的问题可以使用适配器处理</li><li><strong>策略模式：</strong>不希望薪资发放规则的变化影响系统的数据新增修改、统计查询等具体业务逻辑，可以用策略模式把薪资发放规则一个个封装起来，使他们可以相互替换</li><li><strong>工厂方法模式：</strong>如果创建的时候只动了对象是SQL Server，就不能适应后面改用其他数据库的变化，可以<strong>用抽象工厂模式、反射技术让业务逻辑和数据访问减少耦合</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》28-访问者模式</title>
      <link href="/2024/01/03/da-hua-she-ji-mo-shi-28-fang-wen-zhe-mo-shi/"/>
      <url>/2024/01/03/da-hua-she-ji-mo-shi-28-fang-wen-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/kNCqEiDwtfdd.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vistor抽象类，为每一个ConcreteElement声明一个Visitxxx操作，当ConcreteElement增加时需要增加该类中的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA* ca)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB* cb)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteVisitor1和ConcreteVisitor2类，具体访问者，实现每个Visitxxx操作，根据ObjectStructure中对象的类来确定每个操作实现算法的某一部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor1</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA* ca)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(ca).<span class="built_in">name</span>() &lt;&lt; <span class="string">"被"</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"访问。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB* cb)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(cb).<span class="built_in">name</span>() &lt;&lt; <span class="string">"被"</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"访问。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitor2</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA* ca)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(ca).<span class="built_in">name</span>() &lt;&lt; <span class="string">"被"</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"访问。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB* cb)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(cb).<span class="built_in">name</span>() &lt;&lt; <span class="string">"被"</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"访问。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Element抽象类，定义一个Accept操作，以一个Visitor为参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor* visitor)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteElementA和ConcreteElementB类，具体元素，实现Accept操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor* visitor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">visitor-&gt;<span class="built_in">VisitConcreteElementA</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationA</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor* visitor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">visitor-&gt;<span class="built_in">VisitConcreteElementB</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OperationB</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectStructure类，数据结构，装入、删除、访问元素，提供高层接口允许访问者访问它的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Element* element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Detatch</span><span class="params">(Element* element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">elements.<span class="built_in">erase</span>(<span class="built_in">remove</span>(elements.<span class="built_in">begin</span>(), elements.<span class="built_in">end</span>(), element), elements.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor* visitor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : elements)</span><br><span class="line">{</span><br><span class="line">e-&gt;<span class="built_in">Accept</span>(visitor);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Element*&gt; elements;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">ObjectStructure* o = <span class="keyword">new</span> <span class="built_in">ObjectStructure</span>();</span><br><span class="line">o-&gt;<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementA</span>());</span><br><span class="line">o-&gt;<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteElementB</span>());</span><br><span class="line"></span><br><span class="line">ConcreteVisitor1* v1 = <span class="keyword">new</span> <span class="built_in">ConcreteVisitor1</span>();</span><br><span class="line">ConcreteVisitor2* v2 = <span class="keyword">new</span> <span class="built_in">ConcreteVisitor2</span>();</span><br><span class="line"></span><br><span class="line">o-&gt;<span class="built_in">Accept</span>(v1);</span><br><span class="line">o-&gt;<span class="built_in">Accept</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o;</span><br><span class="line"><span class="keyword">delete</span> v1;</span><br><span class="line"><span class="keyword">delete</span> v2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/2b7HBkT7YY0a.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action类(Visitor)，抽象访问者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetManConclusion</span><span class="params">(Man* m)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetWomanConclusion</span><span class="params">(Woman* w)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Success类(ConcreteVisitor1)、Failing类(ConcreteVisitor2)和Amativeness类(ConcreteVisitor3)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span> : <span class="keyword">public</span> Action</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetManConclusion</span><span class="params">(Man* m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(m).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(*<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，背后多半有一个伟大的女人。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetWomanConclusion</span><span class="params">(Woman* w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(w).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(*<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，背后多半有一个不成功的男人。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failing</span> : <span class="keyword">public</span> Action</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetManConclusion</span><span class="params">(Man* m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(m).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，闷头喝酒，谁也不用劝。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetWomanConclusion</span><span class="params">(Woman* w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(w).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，眼泪汪汪，谁也劝不了。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amativeness</span> : <span class="keyword">public</span> Action</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetManConclusion</span><span class="params">(Man* m)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(m).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，凡事不懂也要装懂。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetWomanConclusion</span><span class="params">(Woman* w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(w).<span class="built_in">name</span>() &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">this</span>).<span class="built_in">name</span>() &lt;&lt; <span class="string">"时，遇事懂也装作不懂。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person类(Element)，人的抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Action* action)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Man类(ConcreteElementA)和Woman类(ConcreteElementB)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> : <span class="keyword">public</span> Person</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Action* action)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">action-&gt;<span class="built_in">GetManConclusion</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> : <span class="keyword">public</span> Person</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Action* action)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">action-&gt;<span class="built_in">GetWomanConclusion</span>(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjectStructure类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectStructure</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Person* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">persons.<span class="built_in">push_back</span>(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Person* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">persons.<span class="built_in">erase</span>(<span class="built_in">remove</span>(persons.<span class="built_in">begin</span>(), persons.<span class="built_in">end</span>(), p), persons.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Accept</span><span class="params">(Action* a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (Person* p : persons)</span><br><span class="line">{</span><br><span class="line">p-&gt;<span class="built_in">Accept</span>(a);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Person*&gt; persons;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">ObjectStructure* o = <span class="keyword">new</span> <span class="built_in">ObjectStructure</span>();</span><br><span class="line">o-&gt;<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">Man</span>());</span><br><span class="line">o-&gt;<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">Woman</span>());</span><br><span class="line"></span><br><span class="line">Success* s = <span class="keyword">new</span> <span class="built_in">Success</span>();</span><br><span class="line">o-&gt;<span class="built_in">Accept</span>(s);</span><br><span class="line"></span><br><span class="line">Failing* f = <span class="keyword">new</span> <span class="built_in">Failing</span>();</span><br><span class="line">o-&gt;<span class="built_in">Accept</span>(f);</span><br><span class="line"></span><br><span class="line">Amativeness* a = <span class="keyword">new</span> <span class="built_in">Amativeness</span>();</span><br><span class="line">o-&gt;<span class="built_in">Accept</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> f;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line"><span class="keyword">delete</span> o;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>适用于<strong>数据结构相对稳定</strong>的系统。它<strong>把数据结构和作用于结构上的操作之间解耦</strong>，使得操作集合可以相对自由地演化</p></li><li><p>目的是要<strong>把处理从数据结构分离出来</strong>。如果系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较适合的，因为访问者模式使得算法操作的增加变得容易</p></li><li><p>优点是<strong>增加新的操作很容易</strong>，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中</p></li><li><p>缺点是<strong>使增加新的数据结构变得困难了</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》27-解释器模式</title>
      <link href="/2023/12/28/da-hua-she-ji-mo-shi-27-jie-shi-qi-mo-shi/"/>
      <url>/2023/12/28/da-hua-she-ji-mo-shi-27-jie-shi-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</li><li>如果一种特定类型的问题<strong>发生的频率足够高</strong>，那么可能就值得<strong>将该问题的各个实例表述为一个简单语言中的句子</strong>，这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题</li><li>当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/Ms8hVFuGnwII.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstracExpression抽象类，抽象表达式，声明一个抽象的解释操作，该接口被抽象语法树中所有的节点共享</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExpression</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Interpret</span><span class="params">(Context* contex)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// TerminalExpression类,终结符表达式，实现与文法中的终结符相关联的解释操作，每一个终结符都有一个具体终结表达式与之对应</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TerminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Interpret</span><span class="params">(Context* context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"终端解释器"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonTerminalExpression类，非终结符表达式，实现与文法中的非终结符相关联的解释操作，每一个非终结符都有一个具体非终结表达式类与之对应，通过递归方式调用每个符号的实例变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonTerminalExpression</span> : <span class="keyword">public</span> AbstractExpression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Interpret</span><span class="params">(Context* context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"非终端解释器"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context类，包含解释器之外的一些全局信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string input;</span><br><span class="line">string output;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Context* context = <span class="keyword">new</span> <span class="built_in">Context</span>();</span><br><span class="line">vector&lt;AbstractExpression*&gt; Expressions;</span><br><span class="line"></span><br><span class="line">Expressions.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TerminalExpression</span>());</span><br><span class="line">Expressions.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">NonTerminalExpression</span>());</span><br><span class="line">Expressions.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TerminalExpression</span>());</span><br><span class="line">Expressions.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">NonTerminalExpression</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> exp : Expressions)</span><br><span class="line">{</span><br><span class="line">exp-&gt;<span class="built_in">Interpret</span>(context);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/R9KkXstPDcbJ.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For std::exception</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayContext</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string text;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Interpret</span><span class="params">(PlayContext* context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (context-&gt;text.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">string playKey = context-&gt;text.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">context-&gt;text = context-&gt;text.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">double</span> playValue = <span class="built_in">stod</span>(context-&gt;text.<span class="built_in">substr</span>(<span class="number">0</span>, context-&gt;text.<span class="built_in">find</span>(<span class="string">" "</span>)));</span><br><span class="line">context-&gt;text = context-&gt;text.<span class="built_in">substr</span>(context-&gt;text.<span class="built_in">find</span>(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Execute</span>(playKey, playValue);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">(string key, <span class="type">double</span> value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Note</span> : <span class="keyword">public</span> Expression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">(string key, <span class="type">double</span> value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">string note = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="string">"C"</span>)</span><br><span class="line">note = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"D"</span>)</span><br><span class="line">note = <span class="string">"2"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"E"</span>)</span><br><span class="line">note = <span class="string">"3"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"F"</span>)</span><br><span class="line">note = <span class="string">"4"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"G"</span>)</span><br><span class="line">note = <span class="string">"5"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"A"</span>)</span><br><span class="line">note = <span class="string">"6"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">"B"</span>)</span><br><span class="line">note = <span class="string">"7"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; note &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scale</span> : <span class="keyword">public</span> Expression</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">(string key, <span class="type">double</span> value)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">string scale = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">int</span>(value) == <span class="number">1</span>)</span><br><span class="line">scale = <span class="string">"低音"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">int</span>(value) == <span class="number">2</span>)</span><br><span class="line">scale = <span class="string">"中音"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">int</span>(value) == <span class="number">3</span>)</span><br><span class="line">scale = <span class="string">"高音"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; scale &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">PlayContext* context = <span class="keyword">new</span> <span class="built_in">PlayContext</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"上海滩："</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">context-&gt;text = <span class="string">"O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5 G 0.5 A 0.5 O 3 C 1 O 2 A 0.5 G 1 C 0.5 E 0.5 D 3 "</span>;</span><br><span class="line">Expression* exp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> (context-&gt;text.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">string str = context-&gt;text.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">"O"</span>)</span><br><span class="line">exp = <span class="keyword">new</span> <span class="built_in">Scale</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"C"</span> || str == <span class="string">"D"</span> || str == <span class="string">"E"</span> || str == <span class="string">"F"</span> || str == <span class="string">"G"</span> || str == <span class="string">"A"</span> || str == <span class="string">"B"</span> || str == <span class="string">"P"</span>)</span><br><span class="line">exp = <span class="keyword">new</span> <span class="built_in">Note</span>();</span><br><span class="line"></span><br><span class="line">exp-&gt;<span class="built_in">Interpret</span>(context);</span><br><span class="line"><span class="keyword">delete</span> exp;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; ex)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点</strong>：容易地改变和扩展文法，因为该模式<strong>使用类来表示文法规则</strong>，可<strong>使用继承来改变或扩展该文法</strong>。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些都易于直接编写</li><li><strong>缺点</strong>：为文法中的每一条规则至少定义了一个类，因此<strong>包含许多规则的文法可能难以管理和维护</strong>。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》26-享元模式</title>
      <link href="/2023/12/27/da-hua-she-ji-mo-shi-26-xiang-yuan-mo-shi/"/>
      <url>/2023/12/27/da-hua-she-ji-mo-shi-26-xiang-yuan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>运用<strong>共享技术</strong>有效地支持大量细粒度的对象</li><li><strong>内部状态：</strong>享元对象内部不会随环境改变而改变的共享部分</li><li><strong>外部状态：</strong>随环境改变而改变、不可以共享的状态</li><li>享元模式可以<strong>避免大量非常相似类的开销</strong>。在程序设计中，有时需要生成大量细粒度的类实例来显示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能<strong>把那些参数移到类实例的外面，在方法调用时将它们传递进来</strong>，就可以通过共享大幅度地减少单个实例的数量</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/Xt0N40bhgW1X.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyweight类，是所有具体享元类的抽象接口，可以接受并作用于外部状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flyweight</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">(<span class="type">int</span> extrinsicState)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteFlyweight类，继承于Flyweight，为内部状态增加存储空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> : <span class="keyword">public</span> Flyweight</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">(<span class="type">int</span> extrinsicState)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体Flyweight："</span> &lt;&lt; extrinsicState &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnsharedConcreteFlyweight类，不需要共享的Flyweight子类，因为Flyweight存在所以可以共享，但不强制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnsharedConcreteFlyweight</span> : <span class="keyword">public</span> Flyweight</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">(<span class="type">int</span> extrinsicState)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"不共享的具体Flyweight："</span> &lt;&lt; extrinsicState &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyweightFactory类，享元工厂，创建并管理Flyweight对象，确保合理的共享Flyweight，当一个用户请求Flyweight对象时，工厂对象提供一个已创建的实例或者创建一个新的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FlyweightFactory</span>()</span><br><span class="line">{</span><br><span class="line"><span class="comment">// 初始化工厂时生成三个实例</span></span><br><span class="line">flyweights[<span class="string">"X"</span>] = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>();</span><br><span class="line">flyweights[<span class="string">"Y"</span>] = <span class="keyword">new</span> <span class="built_in">UnsharedConcreteFlyweight</span>();</span><br><span class="line">flyweights[<span class="string">"Z"</span>] = <span class="keyword">new</span> <span class="built_in">ConcreteFlyweight</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Flyweight* <span class="title">GetFlyweight</span><span class="params">(string key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> flyweights[key];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">unordered_map&lt;string, Flyweight*&gt; flyweights;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">FlyweightFactory* f = <span class="keyword">new</span> <span class="built_in">FlyweightFactory</span>();</span><br><span class="line"><span class="type">int</span> extrinsicState = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">Flyweight* fx = f-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">"X"</span>);</span><br><span class="line">fx-&gt;<span class="built_in">Operation</span>(--extrinsicState);</span><br><span class="line"></span><br><span class="line">Flyweight* fy = f-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">"Y"</span>);</span><br><span class="line">fy-&gt;<span class="built_in">Operation</span>(--extrinsicState);</span><br><span class="line"></span><br><span class="line">Flyweight* fz = f-&gt;<span class="built_in">GetFlyweight</span>(<span class="string">"Z"</span>);</span><br><span class="line">fz-&gt;<span class="built_in">Operation</span>(--extrinsicState);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/mGfl0e8LtVR2.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User，用户类，用于同类网站的区分，是网站的“外部状态”</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">User</span>(string name)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Website(Flyweight)，网站抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Website</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 接收用户对象这一外部状态的传递</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Use</span><span class="params">(User* user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteWebsite(ConcreteFlyweight)，具体网站类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteWebsite</span> : <span class="keyword">public</span> Website</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteWebsite</span>(string name)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Use</span><span class="params">(User* user)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"网站分类："</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">" 用户："</span> &lt;&lt; user-&gt;<span class="built_in">GetName</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebsiteFactory(FlyweightFactory)，网站工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebsiteFactory</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Website* <span class="title">GetWebsiteCategory</span><span class="params">(string key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (websites.<span class="built_in">count</span>(key) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">websites[key] = <span class="keyword">new</span> <span class="built_in">ConcreteWebsite</span>(key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> websites[key];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetWebsiteCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> websites.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">unordered_map&lt;string, Website*&gt; websites;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">WebsiteFactory* f = <span class="keyword">new</span> <span class="built_in">WebsiteFactory</span>();</span><br><span class="line"></span><br><span class="line">Website* fx = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"产品展示"</span>);</span><br><span class="line">fx-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"A"</span>));</span><br><span class="line"></span><br><span class="line">Website* fy = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"产品展示"</span>);</span><br><span class="line">fy-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"B"</span>));</span><br><span class="line"></span><br><span class="line">Website* fz = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"产品展示"</span>);</span><br><span class="line">fz-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"C"</span>));</span><br><span class="line"></span><br><span class="line">Website* fo = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"博客"</span>);</span><br><span class="line">fo-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"D"</span>));</span><br><span class="line"></span><br><span class="line">Website* fp = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"博客"</span>);</span><br><span class="line">fp-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"E"</span>));</span><br><span class="line"></span><br><span class="line">Website* fq = f-&gt;<span class="built_in">GetWebsiteCategory</span>(<span class="string">"博客"</span>);</span><br><span class="line">fq-&gt;<span class="built_in">Use</span>(<span class="keyword">new</span> <span class="built_in">User</span>(<span class="string">"F"</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"总共网站实例数目："</span> &lt;&lt; f-&gt;<span class="built_in">GetWebsiteCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>如果一个应用程序使用了大量的对象，而大量的这些<strong>对象造成了很大的存储开销</strong>时就应该考虑使用</p></li><li><p>对象的<strong>大多数状态可以外部状态</strong>，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式</p></li><li><p>使用享元模式需要维护一个记录了系统已有的所有享元的列表，这本身需要消耗资源</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》25-中介者模式</title>
      <link href="/2023/12/24/da-hua-she-ji-mo-shi-25-zhong-jie-zhe-mo-shi/"/>
      <url>/2023/12/24/da-hua-she-ji-mo-shi-25-zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>尽管将一个系统<strong>分割</strong>成许多对象通常可以<strong>增加其复用性</strong>，但是对象间的<strong>相互连接</strong>的激增又会<strong>降低其可复用性</strong>。大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所有，<strong>对系统的行为进行任何较大的改动就十分困难</strong>。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用一个<strong>中介对象来封装一系列的对象交互</strong>。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/eDFN4JBr0xfX.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">(string message, <span class="keyword">class</span> Colleague* colleague)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Colleague</span>(Mediator* mediator)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;mediator = mediator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Mediator* mediator;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span>;  <span class="comment">// Forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span>;  <span class="comment">// Forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> : <span class="keyword">public</span> Mediator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ConcreteColleague1* colleague1;</span><br><span class="line">ConcreteColleague2* colleague2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Send</span><span class="params">(string message, Colleague* colleague)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> : <span class="keyword">public</span> Colleague</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteColleague1</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"同事1得到信息："</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span> : <span class="keyword">public</span> Colleague</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteColleague2</span>(Mediator* mediator) : <span class="built_in">Colleague</span>(mediator) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">mediator-&gt;<span class="built_in">Send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"同事2得到信息："</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteMediator::Send</span><span class="params">(string message, Colleague* colleague)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (colleague == colleague1)</span><br><span class="line">{</span><br><span class="line">colleague2-&gt;<span class="built_in">Notify</span>(message);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">colleague1-&gt;<span class="built_in">Notify</span>(message);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">ConcreteMediator* m = <span class="keyword">new</span> <span class="built_in">ConcreteMediator</span>();</span><br><span class="line">ConcreteColleague1* c1 = <span class="keyword">new</span> <span class="built_in">ConcreteColleague1</span>(m);</span><br><span class="line">ConcreteColleague2* c2 = <span class="keyword">new</span> <span class="built_in">ConcreteColleague2</span>(m);</span><br><span class="line"></span><br><span class="line">m-&gt;colleague1 = c1;</span><br><span class="line">m-&gt;colleague2 = c2;</span><br><span class="line"></span><br><span class="line">c1-&gt;<span class="built_in">Send</span>(<span class="string">"吃饭了没？"</span>);</span><br><span class="line">c2-&gt;<span class="built_in">Send</span>(<span class="string">"吃过了。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> m;</span><br><span class="line"><span class="keyword">delete</span> c1;</span><br><span class="line"><span class="keyword">delete</span> c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="https://gcdnb.pbrd.co/images/mcWNux8YkpJD.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合国机构，抽象类，Mediator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnitedNations</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Declare</span><span class="params">(string message, Country* country)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 国家，抽象类，Colleague</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Country</span>(UnitedNations* mediator)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;mediator = mediator;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">UnitedNations* mediator;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 美国，ConcreteColleague1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USA</span> : <span class="keyword">public</span> Country</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">USA</span>(UnitedNations* mediator) : <span class="built_in">Country</span>(mediator) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Declare</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">mediator-&gt;<span class="built_in">Declare</span>(message, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMessage</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"美国获得信息："</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伊拉克，ConcreteColleague2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iraq</span> : <span class="keyword">public</span> Country</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Iraq</span>(UnitedNations* mediator) : <span class="built_in">Country</span>(mediator) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Declare</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">mediator-&gt;<span class="built_in">Declare</span>(message, <span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMessage</span><span class="params">(string message)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"伊拉克获得信息："</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合国安理会，ConcreteMeidator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnitedNationsSecurityCouncil</span> : <span class="keyword">public</span> UnitedNations</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">USA* c1;</span><br><span class="line">Iraq* c2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Declare</span><span class="params">(string message, Country* country)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (country == c1)</span><br><span class="line">{</span><br><span class="line">c2-&gt;<span class="built_in">GetMessage</span>(message);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">c1-&gt;<span class="built_in">GetMessage</span>(message);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">UnitedNationsSecurityCouncil* UNSC = <span class="keyword">new</span> <span class="built_in">UnitedNationsSecurityCouncil</span>();</span><br><span class="line"></span><br><span class="line">USA* usa = <span class="keyword">new</span> <span class="built_in">USA</span>(UNSC);</span><br><span class="line">Iraq* iraq = <span class="keyword">new</span> <span class="built_in">Iraq</span>(UNSC);</span><br><span class="line"></span><br><span class="line">UNSC-&gt;c1 = usa;</span><br><span class="line">UNSC-&gt;c2 = iraq;</span><br><span class="line"></span><br><span class="line">usa-&gt;<span class="built_in">Declare</span>(<span class="string">"美国期待和平！"</span>);</span><br><span class="line">iraq-&gt;<span class="built_in">Declare</span>(<span class="string">"伊拉克期待和平！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="中介模式优缺点、应用场合"><a href="#中介模式优缺点、应用场合" class="headerlink" title="中介模式优缺点、应用场合"></a>中介模式优缺点、应用场合</h3><p><strong>优点：</strong></p><ul><li>Mediator的出现<strong>减少了各个Colleague的耦合</strong>，使得可以独立地改变和复用各个Colleague类和Mediator</li><li>由于把对象如何协作进行了抽象，将中介作为一个独立的概念年并将其封装在一个对象中，这样<strong>关注的对象就从对象各自本身的行为转移到它们之间的交互上来</strong>，也就是站在一个更宏伟的角度去看待系统</li></ul><p><strong>缺点：</strong></p><ul><li>由于ConcreteMediator控制了集中化，于是就把<strong>交互复杂性变为了中介者的复杂性</strong>，这就是使得中介者会变得比任何一个ConcreteColleague都复杂</li></ul><p><strong>应用场合：</strong></p><ul><li>中介者模式一般应用与<strong>一组对象以定义良好但是复杂的方式进行通信</strong>的场合，以及想<strong>定制一个分布在多个类中的行为</strong>，而又不想生成太多的子类的场合</li><li>当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思系统在设计上是不是合理</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》24-职责链模式</title>
      <link href="/2023/12/23/da-hua-she-ji-mo-shi-24-zhi-ze-lian-mo-shi/"/>
      <url>/2023/12/23/da-hua-she-ji-mo-shi-24-zhi-ze-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>使多个对象都有机会处理请求，从而<strong>避免请求的发送者和接收者之间的耦合</strong>关系</li><li>将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/xBEXLecvlf5N.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler抽象类，定义一个处理请求的抽象接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 设置下一个处理请求的继任者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSuccessor</span><span class="params">(Handler* successor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;successor = successor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理请求的抽象接口  </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Handler* successor;</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteHandler类，具体处理着，处理它能负责的请求，可以访问它的后继者</span></span><br><span class="line"><span class="comment">// ConcreteHandler1类，处理权限0-9</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> : <span class="keyword">public</span> Handler</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteHandler1</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request &gt;= <span class="number">0</span> &amp;&amp; request &lt; <span class="number">10</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">"处理请求："</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Handler::successor != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">successor-&gt;<span class="built_in">HandleRequest</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteHandler2类，处理权限10-19</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> : <span class="keyword">public</span> Handler</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteHandler2</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request &gt;= <span class="number">10</span> &amp;&amp; request &lt; <span class="number">20</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">"处理请求："</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Handler::successor != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">successor-&gt;<span class="built_in">HandleRequest</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteHandler3类，处理权限20-29</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandler3</span> : <span class="keyword">public</span> Handler</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteHandler3</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">HandleRequest</span><span class="params">(<span class="type">int</span> request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request &gt;= <span class="number">20</span> &amp;&amp; request &lt; <span class="number">30</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">"处理请求："</span> &lt;&lt; request &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Handler::successor != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">successor-&gt;<span class="built_in">HandleRequest</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Handler* h1 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler1</span>(<span class="string">"主管"</span>);</span><br><span class="line">Handler* h2 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler2</span>(<span class="string">"部长"</span>);</span><br><span class="line">Handler* h3 = <span class="keyword">new</span> <span class="built_in">ConcreteHandler3</span>(<span class="string">"总裁"</span>);</span><br><span class="line"></span><br><span class="line">h1-&gt;<span class="built_in">SetSuccessor</span>(h2);</span><br><span class="line">h2-&gt;<span class="built_in">SetSuccessor</span>(h3);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> requests[] = { <span class="number">2</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">22</span>,<span class="number">18</span>,<span class="number">3</span>,<span class="number">27</span>,<span class="number">20</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> r : requests)</span><br><span class="line">{</span><br><span class="line">h1-&gt;<span class="built_in">HandleRequest</span>(r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>当客户提交一个请求时，请求是沿着链传递直至有一个ConcreteHandle对象负责处理它</li><li>接收者和发送者都<strong>没有对方的明确信息</strong>，且链中的对象自己也并不知道链的结构，结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接收者的引用</li><li><strong>随时地增加或修改</strong>处理一个请求的结构。增强了给对象指派职责的灵活性</li><li>一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/os3zJNHa5JAZ.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string requestType;</span><br><span class="line">string requestContent;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者抽象类(Handler)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Manager</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSuperior</span><span class="params">(Manager* superior)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;superior = superior;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestApplications</span><span class="params">(Request* request)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string name;</span><br><span class="line">Manager* superior;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经理类(ConcreteHandler1)，只能批准两天内的假期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommonManager</span> : <span class="keyword">public</span> Manager</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CommonManager</span>(string name) : <span class="built_in">Manager</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestApplications</span><span class="params">(Request* request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request-&gt;requestType == <span class="string">"请假"</span> &amp;&amp; request-&gt;number &lt;= <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; CommonManager::name &lt;&lt; <span class="string">": "</span> &lt;&lt; request-&gt;requestContent &lt;&lt; <span class="string">" 数量："</span> &lt;&lt; request-&gt;number &lt;&lt; <span class="string">" 被批准！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (CommonManager::superior != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">CommonManager::superior-&gt;<span class="built_in">RequestApplications</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总监类(ConcreteHandler2)，能批准五天内的假期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Majordomo</span> : <span class="keyword">public</span> Manager</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Majordomo</span>(string name) : <span class="built_in">Manager</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestApplications</span><span class="params">(Request* request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request-&gt;requestType == <span class="string">"请假"</span> &amp;&amp; request-&gt;number &lt;= <span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; Majordomo::name &lt;&lt; <span class="string">": "</span> &lt;&lt; request-&gt;requestContent &lt;&lt; <span class="string">" 数量："</span> &lt;&lt; request-&gt;number &lt;&lt; <span class="string">" 被批准！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (Majordomo::superior != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">Majordomo::superior-&gt;<span class="built_in">RequestApplications</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总经理类(ConcreteHandler3)，能批准所有假期和500元以下的加薪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralManager</span> : <span class="keyword">public</span> Manager</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GeneralManager</span>(string name) : <span class="built_in">Manager</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RequestApplications</span><span class="params">(Request* request)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (request-&gt;requestType == <span class="string">"请假"</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; GeneralManager::name &lt;&lt; <span class="string">": "</span> &lt;&lt; request-&gt;requestContent &lt;&lt; <span class="string">" 数量："</span> &lt;&lt; request-&gt;number &lt;&lt; <span class="string">" 被批准！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request-&gt;requestType == <span class="string">"加薪"</span> &amp;&amp; request-&gt;number &lt;= <span class="number">500</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; GeneralManager::name &lt;&lt; <span class="string">": "</span> &lt;&lt; request-&gt;requestContent &lt;&lt; <span class="string">" 数量："</span> &lt;&lt; request-&gt;number &lt;&lt; <span class="string">" 被批准！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (request-&gt;requestType == <span class="string">"加薪"</span> &amp;&amp; request-&gt;number &gt; <span class="number">500</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; GeneralManager::name &lt;&lt; <span class="string">": "</span> &lt;&lt; request-&gt;requestContent &lt;&lt; <span class="string">" 数量："</span> &lt;&lt; request-&gt;number &lt;&lt; <span class="string">" 再考虑一下..."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GeneralManager::superior != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">GeneralManager::superior-&gt;<span class="built_in">RequestApplications</span>(request);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Manager* c = <span class="keyword">new</span> <span class="built_in">CommonManager</span>(<span class="string">"经理"</span>);</span><br><span class="line">Manager* m = <span class="keyword">new</span> <span class="built_in">Majordomo</span>(<span class="string">"总监"</span>);</span><br><span class="line">Manager* g = <span class="keyword">new</span> <span class="built_in">GeneralManager</span>(<span class="string">"总经理"</span>);</span><br><span class="line">c-&gt;<span class="built_in">SetSuperior</span>(m);</span><br><span class="line">m-&gt;<span class="built_in">SetSuperior</span>(g);</span><br><span class="line"></span><br><span class="line">Request* r1 = <span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">r1-&gt;requestType = <span class="string">"请假"</span>;</span><br><span class="line">r1-&gt;requestContent = <span class="string">"小菜请假"</span>;</span><br><span class="line">r1-&gt;number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">c-&gt;<span class="built_in">RequestApplications</span>(r1);</span><br><span class="line"></span><br><span class="line">Request* r2 = <span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">r2-&gt;requestType = <span class="string">"请假"</span>;</span><br><span class="line">r2-&gt;requestContent = <span class="string">"小菜请假"</span>;</span><br><span class="line">r2-&gt;number = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">c-&gt;<span class="built_in">RequestApplications</span>(r2);</span><br><span class="line"></span><br><span class="line">Request* r3 = <span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">r3-&gt;requestType = <span class="string">"请假"</span>;</span><br><span class="line">r3-&gt;requestContent = <span class="string">"小菜请假"</span>;</span><br><span class="line">r3-&gt;number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">c-&gt;<span class="built_in">RequestApplications</span>(r3);</span><br><span class="line"></span><br><span class="line">Request* r4 = <span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">r4-&gt;requestType = <span class="string">"加薪"</span>;</span><br><span class="line">r4-&gt;requestContent = <span class="string">"小菜加薪"</span>;</span><br><span class="line">r4-&gt;number = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">c-&gt;<span class="built_in">RequestApplications</span>(r4);</span><br><span class="line"></span><br><span class="line">Request* r5 = <span class="keyword">new</span> <span class="built_in">Request</span>();</span><br><span class="line">r5-&gt;requestType = <span class="string">"加薪"</span>;</span><br><span class="line">r5-&gt;requestContent = <span class="string">"小菜加薪"</span>;</span><br><span class="line">r5-&gt;number = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">c-&gt;<span class="built_in">RequestApplications</span>(r5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》23-命令模式</title>
      <link href="/2023/12/22/da-hua-she-ji-mo-shi-23-ming-ling-mo-shi/"/>
      <url>/2023/12/22/da-hua-she-ji-mo-shi-23-ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>将一个<strong>请求封装为一个对象</strong>，从而可用不同的请求对客户进行参数化；对<strong>请求排队</strong>或<strong>记录请求日志</strong>，以及支持可<strong>撤销</strong>的操作</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/a6u1LSaCiRnF.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reicever类，知道如何实施与执行一个请求的具体操作，任何类都可能作为一个接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Action</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"执行请求！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Command抽象类，声明执行操作的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Command</span>(Receiver* receiver)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;receiver = receiver;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Receiver* receiver;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteCommad类，将一个Receiver对象绑定至一个动作，调用Reicever的相应动作，以实现Execute</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteCommand</span>(Receiver* receiver) : <span class="built_in">Command</span>(receiver) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">receiver-&gt;<span class="built_in">Action</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoker类，聚合Command，要求命令执行这个请求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCommand</span><span class="params">(Command* command)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;command = command;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于客户端的请求调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">command-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Command* command;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Receiver* r = <span class="keyword">new</span> <span class="built_in">Receiver</span>();</span><br><span class="line">Invoker* i = <span class="keyword">new</span> <span class="built_in">Invoker</span>();</span><br><span class="line">Command* c = <span class="keyword">new</span> <span class="built_in">ConcreteCommand</span>(r);</span><br><span class="line"></span><br><span class="line">i-&gt;<span class="built_in">SetCommand</span>(c);</span><br><span class="line">i-&gt;<span class="built_in">Notify</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="keyword">delete</span> i;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/UM72wCGAmEp6.jpg?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 烤肉师傅</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barbecuer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BakeMutton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"烤羊肉串！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BakeChickenwing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"烤鸡翅！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象命令类（Command）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Command</span>(Barbecuer* b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;receiver = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Barbecuer* receiver;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 烤羊肉串命令、烤鸡翅命令（ConcreteCommand）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BakeMuttonCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BakeMuttonCommand</span>(Barbecuer* b) : <span class="built_in">Command</span>(b) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Command::receiver-&gt;<span class="built_in">BakeMutton</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BakeChickenwingCommand</span> : <span class="keyword">public</span> Command</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BakeChickenwingCommand</span>(Barbecuer* b) : <span class="built_in">Command</span>(b) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Command::receiver-&gt;<span class="built_in">BakeChickenwing</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务员类(Invoker)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waiter</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetOrder</span><span class="params">(Command* command)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*command) == <span class="built_in">typeid</span>(BakeChickenwingCommand))</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"服务员：鸡翅没有了，请点别的烧烤。"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">orders.<span class="built_in">push_back</span>(command);</span><br><span class="line">cout &lt;&lt; <span class="string">"增加订单："</span> &lt;&lt; command-&gt;<span class="built_in">Tostring</span>() &lt;&lt; <span class="string">" 时间："</span> &lt;&lt; <span class="built_in">GetTimestamp</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CancelOrder</span><span class="params">(Command* command)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">orders.<span class="built_in">erase</span>(<span class="built_in">remove</span>(orders.<span class="built_in">begin</span>(), orders.<span class="built_in">end</span>(), command), orders.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">"取消订单："</span> &lt;&lt; command.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">" 时间："</span> &lt;&lt; <span class="built_in">GetTimestamp</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> command;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (Command* c : orders)</span><br><span class="line">{</span><br><span class="line">c-&gt;<span class="built_in">Execute</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Command*&gt; orders;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">GetTimestamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="type">time_t</span> currentTime = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">std</span>::tm* local_time = <span class="built_in">localtime</span>(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">ostringstream oss;</span><br><span class="line">oss &lt;&lt; <span class="built_in">put_time</span>(local_time, <span class="string">"%Y-%m-%d %H:%M:%S"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Barbecuer* b = <span class="keyword">new</span> <span class="built_in">Barbecuer</span>();</span><br><span class="line">Command* bakeMuttonCommand1 = <span class="keyword">new</span> <span class="built_in">BakeMuttonCommand</span>(b);</span><br><span class="line">Command* bakeMuttonCommand2 = <span class="keyword">new</span> <span class="built_in">BakeMuttonCommand</span>(b);</span><br><span class="line">Command* bakeChickenwingCommand1 = <span class="keyword">new</span> <span class="built_in">BakeChickenwingCommand</span>(b);</span><br><span class="line"></span><br><span class="line">Waiter* w = <span class="keyword">new</span> <span class="built_in">Waiter</span>();</span><br><span class="line"></span><br><span class="line">w-&gt;<span class="built_in">SetOrder</span>(bakeMuttonCommand1);</span><br><span class="line">w-&gt;<span class="built_in">SetOrder</span>(bakeMuttonCommand2);</span><br><span class="line">w-&gt;<span class="built_in">SetOrder</span>(bakeChickenwingCommand1);</span><br><span class="line"></span><br><span class="line">w-&gt;<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line"><span class="keyword">delete</span> bakeMuttonCommand1;</span><br><span class="line"><span class="keyword">delete</span> bakeMuttonCommand2;</span><br><span class="line"><span class="keyword">delete</span> bakeChickenwingCommand1;</span><br><span class="line"><span class="keyword">delete</span> w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>能较容易地设计一个<strong>命令队列</strong></li><li>在需要的情况下，可以较容易地将命令<strong>记入日志</strong></li><li>允许接收请求的一方决定是否要<strong>否决请求</strong></li><li>可以容易地实现对请求的<strong>撤销和重做</strong></li><li>由于加进新的具体命令类不影响其他的类，因此<strong>增加新的具体命令类很容易</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》22-桥接模式</title>
      <link href="/2023/12/21/da-hua-she-ji-mo-shi-22-qiao-jie-mo-shi/"/>
      <url>/2023/12/21/da-hua-she-ji-mo-shi-22-qiao-jie-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成/聚合复用原则"></a>合成/聚合复用原则</h3><ul><li><p><strong>聚合</strong>表示一种<strong>弱的‘拥有</strong>’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</p></li><li><p><strong>合成</strong>则是一种<strong>强的‘拥有’</strong>关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</p></li><li><p><strong>尽量使用合成/聚合，尽量不要使用类继承</strong></p></li><li><p>好处是优先使用对象的合成/聚合将有助于<strong>保持每个类被封装</strong>，并被集中在单个任务上</p></li><li><p>类和类<strong>继承层次会保持较小规模</strong>，并且不太可能增长为不可控制的庞然大物</p></li></ul><p><img src="https://gcdnb.pbrd.co/images/42dY56wnM6Ym.jpg?o=1"></p><h3 id="桥接模式定义"><a href="#桥接模式定义" class="headerlink" title="桥接模式定义"></a>桥接模式定义</h3><ul><li>将<strong>抽象部分与它的实现部分分离</strong>，使它们都可以独立地变化</li><li>实现指的是抽象类和它的派生类用来实现自己的<strong>对象</strong></li><li>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们<strong>独立变化</strong>，减少它们之间的耦合</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/bO8Qnfys2jDd.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementor类，实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Implementor</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteImplementor类，具体实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> : <span class="keyword">public</span> Implementor</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"具体实现A的方法"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> : <span class="keyword">public</span> Implementor</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"具体实现B的方法"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstraction类，抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstraction</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetImplementor</span><span class="params">(Implementor* implementor)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;implementor = implementor;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">implementor-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Implementor* implementor;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// RefinedAbstraction类，被提炼的抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> : <span class="keyword">public</span> Abstraction</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Abstraction::implementor-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Abstraction* ab = <span class="keyword">new</span> <span class="built_in">RefinedAbstraction</span>();</span><br><span class="line"></span><br><span class="line">ab-&gt;<span class="built_in">SetImplementor</span>(<span class="keyword">new</span> <span class="built_in">ConcreteImplementorA</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">ab-&gt;<span class="built_in">SetImplementor</span>(<span class="keyword">new</span> <span class="built_in">ConcreteImplementorB</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ab;  <span class="comment">// Don't forget to free the allocated memory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/77yeL53SOR9f.jpg?o=1" alt="按品牌分类实现"></p><p><img src="https://gcdnb.pbrd.co/images/usc1i4cC7fhZ.jpg?o=1" alt="按软件分类实现"></p><p><img src="https://gcdnb.pbrd.co/images/Yc87loADWW1L.jpg?o=1" alt="桥接模式实现"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机软件类（Implementor)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetSoft</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机游戏、通讯录（ConcreteImplementor）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetGame</span> : <span class="keyword">public</span> HandsetSoft</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"运行手机游戏！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetAddressList</span> : <span class="keyword">public</span> HandsetSoft</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"运行手机通讯录！"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机品牌类（Abstraction）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetBrand</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHandsetSoft</span><span class="params">(HandsetSoft* soft)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;soft = soft;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">HandsetSoft* soft;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体手机品牌M、N类（RefinedAbstraction）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetBrandM</span> : <span class="keyword">public</span> HandsetBrand</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"M牌手机"</span>;</span><br><span class="line">HandsetBrand::soft-&gt;<span class="built_in">Run</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandsetBrandN</span> : <span class="keyword">public</span> HandsetBrand</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"N牌手机"</span>;</span><br><span class="line">HandsetBrand::soft-&gt;<span class="built_in">Run</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">HandsetBrand* ab;</span><br><span class="line"></span><br><span class="line">ab = <span class="keyword">new</span> <span class="built_in">HandsetBrandM</span>();</span><br><span class="line">ab-&gt;<span class="built_in">SetHandsetSoft</span>(<span class="keyword">new</span> <span class="built_in">HandsetGame</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Run</span>();</span><br><span class="line">ab-&gt;<span class="built_in">SetHandsetSoft</span>(<span class="keyword">new</span> <span class="built_in">HandsetAddressList</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">ab = <span class="keyword">new</span> <span class="built_in">HandsetBrandN</span>();</span><br><span class="line">ab-&gt;<span class="built_in">SetHandsetSoft</span>(<span class="keyword">new</span> <span class="built_in">HandsetGame</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Run</span>();</span><br><span class="line">ab-&gt;<span class="built_in">SetHandsetSoft</span>(<span class="keyword">new</span> <span class="built_in">HandsetAddressList</span>());</span><br><span class="line">ab-&gt;<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》21-单例模式</title>
      <link href="/2023/12/20/da-hua-she-ji-mo-shi-21-dan-li-mo-shi/"/>
      <url>/2023/12/20/da-hua-she-ji-mo-shi-21-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>保证一个类<strong>仅有一个实例</strong>， 并提供一个访问它的<strong>全局访问点</strong></li><li>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保持它的唯一实例。这个类可以保证没有其它实例可以被创建，并且它可以提供一个访问该实例的方法</li><li>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地<strong>控制客户怎样访问以及何时访问它</strong>。简单地说就是对唯一实例的受控访问</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/5MuM2VqXKk41.png?o=1"></p><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p><strong>静态初始化，在自己被加载时就将自己实例化</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EagerSingleton</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> EagerSingleton* instance;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EagerSingleton</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> EagerSingleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">EagerSingleton* EagerSingleton::instance = <span class="keyword">new</span> <span class="built_in">EagerSingleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    EagerSingleton* singleton1 = EagerSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    EagerSingleton* singleton2 = EagerSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Address of singleton1: "</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Address of singleton2: "</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="懒汉式单例模式（双重锁定）"><a href="#懒汉式单例模式（双重锁定）" class="headerlink" title="懒汉式单例模式（双重锁定）"></a>懒汉式单例模式（双重锁定）</h3><p><strong>动态初始化，在第一次被引用时，才会将自己实例化</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazySingleton</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> LazySingleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">LazySingleton</span>() {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> LazySingleton* <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) {</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">LazySingleton* LazySingleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex LazySingleton::mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    LazySingleton* singleton1 = LazySingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    LazySingleton* singleton2 = LazySingleton::<span class="built_in">getInstance</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Address of singleton1: "</span> &lt;&lt; singleton1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Address of singleton2: "</span> &lt;&lt; singleton2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》20-迭代器模式</title>
      <link href="/2023/12/19/da-hua-she-ji-mo-shi-20-die-dai-qi-mo-shi/"/>
      <url>/2023/12/19/da-hua-she-ji-mo-shi-20-die-dai-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>提供一种方法<strong>顺序</strong>访问一个聚合对象中各个元素，而又<strong>不暴露该对象的内部表示</strong></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/mnehyVTnSs6b.png?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator抽象类，迭代器抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T* <span class="title">First</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T* <span class="title">Next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsLast</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> T* <span class="title">CurrentItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregate抽象类，容器抽象类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Aggregate</span>() = <span class="keyword">default</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteIterator类，具体迭代器，实现接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteAggregate类，具体容器类，拥有Count属性</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> : <span class="keyword">public</span> Aggregate&lt;T&gt;</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Iterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteIterator</span>&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;vec.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;vec[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;T&gt; vec;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteIterator类，具体迭代器，实现接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> : <span class="keyword">public</span> Iterator&lt;T&gt;</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteIterator</span>(ConcreteAggregate&lt;T&gt;* aggregate) : <span class="built_in">aggregate</span>(aggregate), <span class="built_in">current</span>(<span class="number">0</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">First</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> &amp;aggregate-&gt;<span class="keyword">operator</span>[](<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">Next</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">T* ret = <span class="literal">nullptr</span>;</span><br><span class="line">current++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current &lt; aggregate-&gt;<span class="built_in">Count</span>())</span><br><span class="line">{</span><br><span class="line">ret = &amp;aggregate-&gt;<span class="keyword">operator</span>[](current);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsLast</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> current &gt;= aggregate-&gt;<span class="built_in">Count</span>() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">CurrentItem</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> &amp;aggregate-&gt;<span class="keyword">operator</span>[](current);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ConcreteAggregate&lt;T&gt;* aggregate;</span><br><span class="line"><span class="type">int</span> current;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">ConcreteAggregate&lt;string&gt;* c = <span class="keyword">new</span> <span class="built_in">ConcreteAggregate</span>&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">(*c)[<span class="number">0</span>] = <span class="string">"a"</span>;</span><br><span class="line">(*c)[<span class="number">1</span>] = <span class="string">"b"</span>;</span><br><span class="line">(*c)[<span class="number">2</span>] = <span class="string">"c"</span>;</span><br><span class="line">(*c)[<span class="number">3</span>] = <span class="string">"d"</span>;</span><br><span class="line">(*c)[<span class="number">4</span>] = <span class="string">"e"</span>;</span><br><span class="line">(*c)[<span class="number">5</span>] = <span class="string">"f"</span>;</span><br><span class="line"></span><br><span class="line">Iterator&lt;string&gt;* i = c-&gt;<span class="built_in">CreateIterator</span>();</span><br><span class="line"></span><br><span class="line">string* first = i-&gt;<span class="built_in">First</span>();</span><br><span class="line"><span class="keyword">while</span> (!i-&gt;<span class="built_in">IsLast</span>())</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; *i-&gt;<span class="built_in">CurrentItem</span>() &lt;&lt; <span class="string">"请购买车票！"</span> &lt;&lt; endl;</span><br><span class="line">i-&gt;<span class="built_in">Next</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="keyword">delete</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》19-组合模式</title>
      <link href="/2023/12/18/da-hua-she-ji-mo-shi-19-zu-he-mo-shi/"/>
      <url>/2023/12/18/da-hua-she-ji-mo-shi-19-zu-he-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>将对象组合成树形结构以表示<strong>‘部分-整体</strong>’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有<strong>一致性</strong></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/gNCj1dzLExI6.png?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Component抽象类，实现所有类共有接口的默认行为，声明接口用于访问和管理Component的子部件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Component</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component* c)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component* c)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Leaf类，叶节点，没有子节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Leaf</span>(string name) : <span class="built_in">Component</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"叶子结点无法增加子节点"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"叶子结点无法移除子节点"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">'-'</span>) &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Composite类，枝节点，用来存储子部件，在Component接口中实现与子部件相关的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Composite</span>(string name) : <span class="built_in">Component</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Component* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">children.<span class="built_in">push_back</span>(c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Component* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// 利用erase-romove方法将vector要删除的元素移动到末尾后删除</span></span><br><span class="line">children.<span class="built_in">erase</span>(<span class="built_in">remove</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>(), c), children.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">'-'</span>) &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Component* c : children)</span><br><span class="line">{</span><br><span class="line">c-&gt;<span class="built_in">Display</span>(depth + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Component*&gt; children;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Composite* root = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">"Root"</span>);</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf A"</span>));</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf B"</span>));</span><br><span class="line"></span><br><span class="line">Composite* comp1 = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">"Composite X"</span>);</span><br><span class="line">comp1-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf XA"</span>));</span><br><span class="line">comp1-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf XB"</span>));</span><br><span class="line"></span><br><span class="line">root-&gt;<span class="built_in">Add</span>(comp1);</span><br><span class="line"></span><br><span class="line">Composite* comp2 = <span class="keyword">new</span> <span class="built_in">Composite</span>(<span class="string">"Composite XY"</span>);</span><br><span class="line">comp2-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf XYA"</span>));</span><br><span class="line">comp2-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf XYB"</span>));</span><br><span class="line"></span><br><span class="line">comp1-&gt;<span class="built_in">Add</span>(comp2);</span><br><span class="line"></span><br><span class="line">root-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf C"</span>));</span><br><span class="line"></span><br><span class="line">Leaf* leaf = <span class="keyword">new</span> <span class="built_in">Leaf</span>(<span class="string">"Leaf D"</span>);</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(leaf);</span><br><span class="line">root-&gt;<span class="built_in">Display</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">root-&gt;<span class="built_in">Remove</span>(leaf);</span><br><span class="line">root-&gt;<span class="built_in">Display</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放动态分配的对象</span></span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line"><span class="keyword">delete</span> comp1;</span><br><span class="line"><span class="keyword">delete</span> comp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>组合模式定义了包含基本对象和组合对象的类层次结构，基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，<strong>任何用到基本对象的地方都可以使用组合对象</strong></li><li>用户是不用关心到底是处理一个叶节点还是处理一个组合组件，也就用不着为定义组合而写一些选择判断语句，让客户可以<strong>一致地使用组合结构和单一对象</strong></li></ul><h3 id="透明方式与安全方式"><a href="#透明方式与安全方式" class="headerlink" title="透明方式与安全方式"></a>透明方式与安全方式</h3><ul><li>透明方式 在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是<strong>叶节点和枝节点对于外界没有区别</strong>，它们具备完全一致的行为接口。但问题也明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是<strong>没有意义</strong>的</li><li>安全模式 在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，不过由于<strong>不够透明</strong>，所以树叶和树枝类将不具有相同的接口，客户端调用需要做<strong>相应的判断</strong>，带来了不方便</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>需求中是体现<strong>部分与整体</strong>层次的结构时</li><li>希望用户可以<strong>忽略组合对象与单个对象的不同</strong>，统一地使用组合结构中的所有对象时，就应该考虑用组合模式</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/0bJEEpiCoGJ2.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Company抽象类（Component）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Company</span>(string name) : <span class="built_in">name</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Company* c)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Company* c)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LineDuty</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteCompany类（Composite），枝节点，实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCompany</span> : <span class="keyword">public</span> Company</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteCompany</span>(string name) : <span class="built_in">Company</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">children.<span class="built_in">push_back</span>(c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">children.<span class="built_in">erase</span>(<span class="built_in">remove</span>(children.<span class="built_in">begin</span>(), children.<span class="built_in">end</span>(), c), children.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">'-'</span>) &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Company* c : children)</span><br><span class="line">{</span><br><span class="line">c-&gt;<span class="built_in">Display</span>(depth + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LineDuty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (Company* c : children)</span><br><span class="line">{</span><br><span class="line">c-&gt;<span class="built_in">LineDuty</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Company*&gt; children;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// HRDepartment类(Leaf)，叶节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HRDepartment</span> : <span class="keyword">public</span> Company</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HRDepartment</span>(string name) : <span class="built_in">Company</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"人力资源部无法添加下属公司"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"人力资源部无法移除下属公司"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">'-'</span>) &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LineDuty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">"员工招聘培训管理"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// FinanceDepartment类(Leaf)，叶节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinanceDepartment</span> : <span class="keyword">public</span> Company</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">FinanceDepartment</span>(string name) : <span class="built_in">Company</span>(name) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"财务部无法添加下属公司"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(Company* c)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"财务部无法移除下属公司"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(depth, <span class="string">'-'</span>) &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">LineDuty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">"公司财务收支管理"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">ConcreteCompany* root = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">"北京总公司"</span>);</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">HRDepartment</span>(<span class="string">"北京总公司人力资源部"</span>));</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">FinanceDepartment</span>(<span class="string">"北京总公司财务部"</span>));</span><br><span class="line"></span><br><span class="line">ConcreteCompany* comp = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">"上海分公司"</span>);</span><br><span class="line">comp-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">HRDepartment</span>(<span class="string">"上海分公司人力资源部"</span>));</span><br><span class="line">comp-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">FinanceDepartment</span>(<span class="string">"上海分公司财务部"</span>));</span><br><span class="line">root-&gt;<span class="built_in">Add</span>(comp);</span><br><span class="line"></span><br><span class="line">ConcreteCompany* comp1 = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">"南京办事处"</span>);</span><br><span class="line">comp1-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">HRDepartment</span>(<span class="string">"南京办事处人力资源部"</span>));</span><br><span class="line">comp1-&gt;<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">FinanceDepartment</span>(<span class="string">"南京办事处财务部"</span>));</span><br><span class="line">comp-&gt;<span class="built_in">Add</span>(comp1);</span><br><span class="line"></span><br><span class="line">ConcreteCompany* comp2 = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">"成都办事处"</span>);</span><br><span class="line">HRDepartment* CDHR = <span class="keyword">new</span> <span class="built_in">HRDepartment</span>(<span class="string">"成都办事处人力资源部"</span>);</span><br><span class="line">comp2-&gt;<span class="built_in">Add</span>(CDHR);</span><br><span class="line">FinanceDepartment* CDFC = <span class="keyword">new</span> <span class="built_in">FinanceDepartment</span>(<span class="string">"成都办事处财务部"</span>);</span><br><span class="line">comp2-&gt;<span class="built_in">Add</span>(CDFC);</span><br><span class="line">comp-&gt;<span class="built_in">Add</span>(comp2);</span><br><span class="line"></span><br><span class="line">HRDepartment* PDHR = <span class="keyword">new</span> <span class="built_in">HRDepartment</span>(<span class="string">"郫都办事处人力资源部"</span>);</span><br><span class="line">CDHR-&gt;<span class="built_in">Add</span>(PDHR);</span><br><span class="line">FinanceDepartment* PDFC = <span class="keyword">new</span> <span class="built_in">FinanceDepartment</span>(<span class="string">"郫都办事处财务部"</span>);</span><br><span class="line">CDFC-&gt;<span class="built_in">Add</span>(PDFC);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"结构图："</span> &lt;&lt; endl;</span><br><span class="line">root-&gt;<span class="built_in">Display</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"职责："</span> &lt;&lt; endl;</span><br><span class="line">root-&gt;<span class="built_in">LineDuty</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》18-备忘录模式</title>
      <link href="/2023/12/17/da-hua-she-ji-mo-shi-18-bei-wang-lu-mo-shi/"/>
      <url>/2023/12/17/da-hua-she-ji-mo-shi-18-bei-wang-lu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>在不破坏<strong>封装性</strong>的前提下，捕获一个对象的<strong>内部状态</strong>，并<strong>在该对象之外保持这个状态</strong>，这样以后就可将该对象恢复到原先保持的状态。</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/TRFsRvqcZZCV.png?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录类，存储发起人类的内部状态，并防止除了发起人的其他对象访问备忘录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Memento</span>(string val)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;state = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">GetState</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;state;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string state;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起人类，创建备忘录记录当前内部状态，并可以借助备忘录恢复状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">GetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;state;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(string val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;state = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Memento <span class="title">CreateMemento</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Memento</span>(<span class="keyword">this</span>-&gt;state);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;state = memento.<span class="built_in">GetState</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前状态："</span> &lt;&lt; <span class="keyword">this</span>-&gt;state &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string state;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理者类，保存备忘录，不能对备忘录的内容进行操作或检查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Caretaker</span>() : <span class="built_in">memento</span>(<span class="string">" "</span>) {}</span><br><span class="line"></span><br><span class="line"><span class="function">Memento <span class="title">GetMemento</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;memento;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(<span class="type">const</span> Memento&amp; memento)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;memento = memento;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Memento memento;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Originator o;</span><br><span class="line">o.<span class="built_in">SetState</span>(<span class="string">"On"</span>);</span><br><span class="line">o.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">Caretaker c;</span><br><span class="line">c.<span class="built_in">SetMemento</span>(o.<span class="built_in">CreateMemento</span>());</span><br><span class="line"></span><br><span class="line">o.<span class="built_in">SetState</span>(<span class="string">"Off"</span>);</span><br><span class="line">o.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">o.<span class="built_in">SetMemento</span>(c.<span class="built_in">GetMemento</span>());</span><br><span class="line">o.<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>把要保存的细节给封装在了Memento中了，哪一天要更改保持的细节也不用影响客户端了</li><li>比较适用于功能比较复杂的，但<strong>需要维护或记录属性历史</strong>的类；或需要保存的属性只是众多属性中的一小<strong>部分</strong>时，Originator可以根据保存的Memento信息还原到前一状态</li><li>如果在某个系统中使用<strong>命令模式</strong>时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</li><li>使用备忘录可以把复杂的对象内部信息对其它的对象<strong>屏蔽</strong>起来</li><li>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/DKfQ0Wm3iRkh.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色状态备忘录类(Memento)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoleStateMemento</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RoleStateMemento</span>(<span class="type">int</span> hp, <span class="type">int</span> atk, <span class="type">int</span> def)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line"><span class="keyword">this</span>-&gt;atk = atk;</span><br><span class="line"><span class="keyword">this</span>-&gt;def = def;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetHp</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetHp</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetAtk</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;atk;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetAtk</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;atk = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDef</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;def;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetDef</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;def = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> atk;</span><br><span class="line"><span class="type">int</span> def;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏角色类(Originator)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Role</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">RoleStateMemento* <span class="title">SaveState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RoleStateMemento</span>(hp, atk, def);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecoveryState</span><span class="params">(RoleStateMemento* memento)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = memento-&gt;<span class="built_in">GetHp</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;atk = memento-&gt;<span class="built_in">GetAtk</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;def = memento-&gt;<span class="built_in">GetDef</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StateDisplay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"角色当前状态："</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"生命值："</span> &lt;&lt; <span class="keyword">this</span>-&gt;hp &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"攻击力："</span> &lt;&lt; <span class="keyword">this</span>-&gt;atk &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"防御力："</span> &lt;&lt; <span class="keyword">this</span>-&gt;def &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetInitState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;atk = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;def = <span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fighted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;atk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;def = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> atk;</span><br><span class="line"><span class="type">int</span> def;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色状态管理类(Caretaker)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">RoleStateMemento* <span class="title">GetMemento</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;memento;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMemento</span><span class="params">(RoleStateMemento* memento)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>-&gt;memento = memento;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RoleStateMemento* memento;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Role* r = <span class="keyword">new</span> <span class="built_in">Role</span>();</span><br><span class="line">r-&gt;<span class="built_in">GetInitState</span>();</span><br><span class="line">r-&gt;<span class="built_in">StateDisplay</span>();</span><br><span class="line"></span><br><span class="line">RoleStateCaretaker* stateAdmin = <span class="keyword">new</span> <span class="built_in">RoleStateCaretaker</span>();</span><br><span class="line">stateAdmin-&gt;<span class="built_in">SetMemento</span>(r-&gt;<span class="built_in">SaveState</span>());</span><br><span class="line"></span><br><span class="line">r-&gt;<span class="built_in">Fighted</span>();</span><br><span class="line">r-&gt;<span class="built_in">StateDisplay</span>();</span><br><span class="line"></span><br><span class="line">r-&gt;<span class="built_in">RecoveryState</span>(stateAdmin-&gt;<span class="built_in">GetMemento</span>());</span><br><span class="line">r-&gt;<span class="built_in">StateDisplay</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》17-适配器模式</title>
      <link href="/2023/12/16/da-hua-she-ji-mo-shi-17-gua-pei-qi-mo-shi/"/>
      <url>/2023/12/16/da-hua-she-ji-mo-shi-17-gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>将<strong>一个类的接口</strong>转换成客户希望的<strong>另外一个接口</strong>。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li><li>有两种类型：<strong>类适配器模式</strong>(用到多重继承)、<strong>对象适配模式</strong></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/JYYZTiB89hAt.png?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target类，是用户直接使用的接口，可以是抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"普通请求！"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adaptee类，提供源接口，需要适配</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SpecificRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"特殊请求！"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter类，内部包装一个Adaptee对象，把源接口转换为目标接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> : <span class="keyword">public</span> Target</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">adaptee.<span class="built_in">SpecificRequest</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Adaptee adaptee;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Target target = <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">    target.<span class="built_in">Request</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统的<strong>数据和行为都正确</strong>，但接口不符时，应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用与希望复用一些现存的类，但是<strong>接口又与复用环境要求不一致</strong>的情况</li><li>使用一个已经存在的类，但如果它的接口，也就是它的<strong>方法和要求不相同</strong>时，就应该考虑用适配器模式</li><li><strong>两个类所做的事情相同或相似</strong>，但是具有不同的接口时要使用它</li><li>客户代码可以统一调用统一接口，可以更简单、更直接、更紧凑</li><li>在<strong>双方都不太容易修改的时候</strong>再使用适配器模式适配</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/e0kJ2Q0DyGjL.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 球员类，包含进攻和防守两种方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(string name)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Attack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Defense</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前锋类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Forwards</span> : <span class="keyword">public</span> Player</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Forwards</span>(string name) : <span class="built_in">Player</span>(name){}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Attack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"前锋"</span> &lt;&lt; name &lt;&lt; <span class="string">"进攻"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">Defense</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"前锋"</span> &lt;&lt; name &lt;&lt; <span class="string">"防守"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中锋类、后卫类略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 外籍中锋类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForeignCenter</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">jingong</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"外籍中锋"</span> &lt;&lt; name &lt;&lt; <span class="string">"进攻"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fangshou</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"外籍中锋"</span> &lt;&lt; name &lt;&lt; <span class="string">"防守"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻译类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Translator</span> : <span class="keyword">public</span> Player</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Translator</span>(string name) : Player::<span class="built_in">name</span>(name){};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Attack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">wjzf.<span class="built_in">jingong</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Defense</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">wjzf.<span class="built_in">fangshou</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ForeignCenter wjzf;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Plaer f = <span class="keyword">new</span> <span class="built_in">Forwards</span>(<span class="string">"F"</span>);</span><br><span class="line">    f.<span class="built_in">Attack</span>();</span><br><span class="line">    </span><br><span class="line">    Plaer g = <span class="keyword">new</span> <span class="built_in">Guards</span>(<span class="string">"G"</span>);</span><br><span class="line">    g.<span class="built_in">Attack</span>();</span><br><span class="line">    </span><br><span class="line">    Plaer m = <span class="keyword">new</span> <span class="built_in">Translator</span>(<span class="string">"M"</span>);</span><br><span class="line">    m.<span class="built_in">Attack</span>();</span><br><span class="line">    m.<span class="built_in">Defense</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》16-状态模式</title>
      <link href="/2023/12/15/da-hua-she-ji-mo-shi-16-zhuang-tai-mo-shi/"/>
      <url>/2023/12/15/da-hua-she-ji-mo-shi-16-zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>当一个对象的内在<strong>状态改变时允许改变其行为</strong>，这个对象看起来是改变了其类</li><li>主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/svDpM1gBB1qs.png?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State抽象类，定义一个接口以封装与Context的一个特定状态相关的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(Context context)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteState类，具体状态，每一个子类实现一个与Context的一个状态相关的行为并实现状态转化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// 设置ConcreteStateA的下一状态是ConcreteStateB</span></span><br><span class="line">context.state = <span class="keyword">new</span> <span class="built_in">ConcreteStateB</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// 设置ConcreteStateB的下一状态是ConcreteStateA</span></span><br><span class="line">context.state = <span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context类，维护一个ConcreteState子类的实例，这个实例定义当前的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(State state)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function">State <span class="title">GetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(State value)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.state = value;</span><br><span class="line">        cout &lt;&lt; <span class="string">"当前状态为"</span> &lt;&lt; state.<span class="built_in">GetType</span>().Name &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        state.<span class="built_in">Handle</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State state;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Context c = <span class="keyword">new</span> <span class="built_in">Context</span>(<span class="keyword">new</span> <span class="built_in">ConcreteStateA</span>());<span class="comment">// 设置Context初始状态为ConcreteStateA</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不断请求并更改状态</span></span><br><span class="line">    c.<span class="built_in">Request</span>();</span><br><span class="line">    c.<span class="built_in">Request</span>();</span><br><span class="line">    c.<span class="built_in">Request</span>();</span><br><span class="line">    c.<span class="built_in">Request</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul><li>好处是将与特定状态的行为局部化，并且将<strong>不同状态的行为分割开来</strong></li><li>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在与某个ConcreteState中，所以通过<strong>定义新的子类可以很容易地增加新的状态和转移</strong></li><li>目的是<strong>消除庞大的条件分支语句</strong>，通过把各种状态转移逻辑分布到State子类之间，来减少相互间的依赖</li><li>当<strong>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</strong>时，就可以考虑使用状态模式了</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/7IH2314SWims.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作状态类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForenoonState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(w.hour &lt; <span class="number">12</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"上午工作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">w.<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">NoonState</span>());</span><br><span class="line">w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoonState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(w.hour &lt; <span class="number">13</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"中午工作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">w.<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">AfternoonState</span>());</span><br><span class="line">w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AfternoonState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(w.hour &lt; <span class="number">17</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"下午工作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">w.<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">EveningState</span>());</span><br><span class="line">w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EveningState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>（w.finished)</span><br><span class="line">{</span><br><span class="line">w.<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">RestState</span>());</span><br><span class="line">w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(w.hour &lt; <span class="number">21</span>)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"加班工作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">w.<span class="built_in">SetState</span>(<span class="keyword">new</span> <span class="built_in">SleepingState</span>());</span><br><span class="line">w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SleepingState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"睡着了"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestState</span> : <span class="keyword">public</span> State</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">WriteProgram</span><span class="params">(Work w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"当前时间为"</span> &lt;&lt; w.hour &lt;&lt; <span class="string">"下班了"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// Work工作类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Work</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> hour;</span><br><span class="line">    <span class="type">bool</span> finished = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">Work</span>()</span><br><span class="line">    {</span><br><span class="line">        current = <span class="keyword">new</span> <span class="built_in">ForenoonState</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetState</span><span class="params">(State s)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        current = s;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WriteProgram</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        current.<span class="built_in">WriteProgram</span>(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Work w = <span class="keyword">new</span> <span class="built_in">Work</span>();</span><br><span class="line">    w.hour = <span class="number">9</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">10</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">12</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">13</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">14</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">17</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    </span><br><span class="line">    w.finished = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">19</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    w.hour = <span class="number">22</span>;</span><br><span class="line">    w.<span class="built_in">WriteProgram</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第九章读书笔记</title>
      <link href="/2023/12/15/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-jiu-zhang-du-shu-bi-ji/"/>
      <url>/2023/12/15/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-jiu-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="DLL简介"><a href="#DLL简介" class="headerlink" title="DLL简介"></a>DLL简介</h2><p>相当于Linux下的共享库，Window系统大量采用dll机制，dll更加强调模块化，经常可以看到Windows平台大量的大型软件都通过升级dll的形式自我完善。</p><h3 id="进程地址空间和内存管理"><a href="#进程地址空间和内存管理" class="headerlink" title="进程地址空间和内存管理"></a>进程地址空间和内存管理</h3><p>一个DLL在不同进程中拥有<strong>不同的私有数据副本</strong>，由于DLL的代码<strong>不是地址无关</strong>的，所以只有某些情况下其可以被多个进程共享。</p><h3 id="基地址和相对地址"><a href="#基地址和相对地址" class="headerlink" title="基地址和相对地址"></a>基地址和相对地址</h3><p>当一个pe文件被装载时，其<strong>进程地址空间的起始地址就是基地址</strong>，每个文件都有一个优先装载地址，位于文件头中的<strong>Image Base</strong>。对于EXE文件来说，Image Base一般为0x400000，对于DLL文件来说，一般是0x10000000。<br>通常可执行文件的Image Base不会被占用，因为它总是第一个被装载的文件，dll文件可能会因为被其他已装载的dll文件而进行Rebasing。<br>RVA就是一个相对地址。当PE被装载到0x10000000,RVA为0x1000的地址为0x10001000。</p><h3 id="DLL共享数据段"><a href="#DLL共享数据段" class="headerlink" title="DLL共享数据段"></a>DLL共享数据段</h3><ul><li>dll的数据段在每个进程中都是独立的，但<strong>允许被设置成共享</strong>的，即<strong>任何进程都可以共享该DLL的同一份数据段</strong>。</li><li>dll可以<strong>一个数据段私有一个数据段共享</strong>，这种方式被用来作为一种进程间的通信方式。</li></ul><h3 id="DLL简单例子"><a href="#DLL简单例子" class="headerlink" title="DLL简单例子"></a>DLL简单例子</h3><p>elf共享库默认导出所有全局符号，而dll中需要<strong>显式告诉编译器要导出的符号</strong>。</p><p>MSVC编译器和支持Windows平台的编译器支持指定符号导入导出的扩展：<br>__declspec(dllexport)：表示该符号是从本DLL导出的符号；<br>__declspec(dllimport)：表示该符号是从别的DLL导入的符号。</p><p><strong>这实际上是通过目标文件的“.drectve”段指示编译器实现的。</strong></p><p>还可以使用**.def脚本**声明导入导出的符号。</p><h3 id="创建DLL"><a href="#创建DLL" class="headerlink" title="创建DLL"></a>创建DLL</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl /LDd Math.c// MSVC编译器编译debug版的dll</span><br><span class="line">cl /LD Math.c// 生成release版</span><br><span class="line">cl Math.c// 生成exe可执行文件</span><br></pre></td></tr></tbody></table></figure><p>上面编译结果生成**.dll .obj .exp .lib**四个文件。</p><p>.exp文件是连接器产生的中间目标文件，保存着收集的所有导出符号的<strong>导出表</strong>(保存在.edata段中)。</p><p>可以通过<strong>dumpbin</strong>工具看到DLL的导出符号：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /EXPORTS Math.dll</span><br></pre></td></tr></tbody></table></figure><h3 id="使用DLL"><a href="#使用DLL" class="headerlink" title="使用DLL"></a>使用DLL</h3><p>程序使用DLL的过程其实是<strong>引用DLL中导出的函数和符号</strong>的过程。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cl /c TestMath.c</span><br><span class="line"><span class="built_in">link</span> TestMath.obj Math.lib</span><br></pre></td></tr></tbody></table></figure><p>.lib文件(导入库)包含.dll的<strong>导出符号以及“桩代码”</strong>，以便将程序与dll粘在一起。</p><p><img src="https://gcdnb.pbrd.co/images/X5XNh1RjVbPH.png?o=1" alt="MSVC静态库链接"></p><h3 id="使用模块定义文件"><a href="#使用模块定义文件" class="headerlink" title="使用模块定义文件"></a>使用模块定义文件</h3><p>除了__declspec(dllexport)导出函数，还可以使用**.def**文件，类似链接脚本，用于控制链接过程，但功能比后者少。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Math.def</span></span><br><span class="line">LIBRARY Math</span><br><span class="line">EXPORTS</span><br><span class="line">Add</span><br><span class="line">Sub</span><br><span class="line">Mul</span><br><span class="line">Div</span><br></pre></td></tr></tbody></table></figure><p>编译Math.c:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl Math.c /LD /DEF Math.def</span><br></pre></td></tr></tbody></table></figure><ul><li>.def文件的好处：<br>可以给导出函数符号起别名,比如当Add函数采用“__stdcall”函数规范，可以在.def文件用Add=_Add@16，这样Add作为别名会被放到导出函数列表内(与_Add@16的RVA相同)。且.def支持“HEAPSIZE”、“NAME”<strong>控制输出文件</strong>的默认堆大小、输出文件名等。</li></ul><h3 id="dll显示运行时链接"><a href="#dll显示运行时链接" class="headerlink" title="dll显示运行时链接"></a>dll显示运行时链接</h3><p>Windows提供了3个API：</p><ul><li><strong>Loadlibrary</strong>（LoadLibraryEx）：用来<strong>装载一个DLL到进程的地址空间</strong>，功能和<strong>dlopen</strong>类似</li><li><strong>GetProcAddress</strong>：用来<strong>查找某个符号的地址</strong>，与<strong>dlsym</strong>类似</li><li><strong>FreeLibrary</strong>：用来<strong>卸载某个已加载的模块</strong>，与<strong>dlclose</strong>类似</li></ul><h2 id="符号导出导入表"><a href="#符号导出导入表" class="headerlink" title="符号导出导入表"></a>符号导出导入表</h2><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><p>Windows PE中，所有导出的符号被集中存放在了<strong>导出表</strong>中，它提供了一个<strong>符号名与符号地址的映射</strong>关系。</p><p>PE文件头有一个叫<strong>DataDirectory</strong>的数组，其第一个元素就是<strong>导出表的地址和长度</strong>。</p><p>导出表本质是一个<strong>IMAGE_EXPORT_DIRECTORY</strong>的结构体。其最后三个成员指向的是三个数组，分别代表<strong>导出地址表(EAT)、符号名表、名字序号对应表</strong>。</p><p>符号名表是导出符号表按照ASCII顺序排序的，符号名表和名字序号对应表一一映射，先通过名字找到符号名表对应下标，然后找到对应序号，序号对应着EAT的下标+Base。EAT保存着各个符号的地址。使用序号导入导出方便了名字查找过程，函数名表也不必保存在内存中，是早起内存不够的补救手段，但这种方法受限于序号可能发生变化。</p><p><strong>手工指定函数导出序号的方法可以通过.def文件实现。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》15-抽象工厂模式</title>
      <link href="/2023/12/14/da-hua-she-ji-mo-shi-15-chou-xiang-gong-han-mo-shi/"/>
      <url>/2023/12/14/da-hua-she-ji-mo-shi-15-chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/xdFKt18jaW6Q.png?o=1"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://gcdnb.pbrd.co/images/cDHvYeoiL0VO.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUser抽象类(AbstractProductA)，用于客户端访问，解除与具体数据库访问的耦合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IUser</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(User user)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> User <span class="title">GetUser</span><span class="params">(<span class="type">int</span> id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlserverUser类(ProductA1)，用于访问SQL Server的User</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerUser</span> : <span class="keyword">public</span> IUser</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在SQL Server中给User表增加一条记录"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">GetUser</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在SQL Server中根据ID找到User表的一条记录"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccessUser类(ProductA2)，用于访问Access的User</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccessUser</span> : <span class="keyword">public</span> IUser</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(User user)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在Access中给User表增加一条记录"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">GetUser</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在Access中根据ID找到User表的一条记录"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDepartment抽象类（AbstractProductB），用于客户端访问，解除与具体数据库访问的耦合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IDepartment</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(Department department)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Department <span class="title">GetDepartment</span><span class="params">(<span class="type">int</span> id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlserverDepartment类(ProductB1)，用于访问SQL Server的Department</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerDepartment</span> : <span class="keyword">public</span> IDepartment</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(Department department)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在SQL Server中给Department表增加一条记录"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Department <span class="title">GetDepartment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在SQL Server中根据ID找到Department表的一条记录"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccessDepartment类(ProductB2)，用于访问Access的Department</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccessDepartment</span> : <span class="keyword">public</span> IDepartment</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(Department departmentr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在Access中给Department表增加一条记录"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Department <span class="title">GetDepartment</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"在Access中根据ID找到Department表的一条记录"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// IFactory抽象类（AbstractFactory），包含所有产品创建的抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IFactory</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IUser <span class="title">CreateUser</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDepartment <span class="title">CreateDepartment</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlserverFactory类，实现IFactory，实例化SqlserverUser和SqlServerDepartment</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlServerFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IUser <span class="title">CreateUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SqlserverUser</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IDepartment <span class="title">CreateDepartment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SqlserverDepartment</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccessFactory类，实现IFactory，实例化AccessUser和AccessDepartment</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccessFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IUser <span class="title">CreateUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AccessUser</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> IDepartment <span class="title">CreateDepartment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AccessDepartment</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    User user = <span class="keyword">new</span> <span class="built_in">User</span>();</span><br><span class="line">    Department dept = <span class="keyword">new</span> <span class="built_in">Department</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IFactory factory = new SqlserverFactory();</span></span><br><span class="line">    IFactory factory = <span class="keyword">new</span> <span class="built_in">AccessFactory</span>();</span><br><span class="line">    </span><br><span class="line">    IUser iu = factory.<span class="built_in">CreateUser</span>();</span><br><span class="line">    iu.<span class="built_in">insert</span>(user);</span><br><span class="line">    iu.<span class="built_in">GetUser</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    IDepartment id = factory.<span class="built_in">CreateDepartment</span>();</span><br><span class="line">    id.<span class="built_in">insert</span>(dept);</span><br><span class="line">    id.<span class="built_in">GetDepartment</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h3><ul><li>易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它<strong>只需要改变具体工厂</strong>即可使用不同的产品</li><li>让<strong>具体的创建实例过程与客户端分离</strong>，客户端通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中</li><li>缺点是改动较大，可以用简单工厂来改进抽象工厂</li></ul><h3 id="用简单工厂模式改进抽象工厂"><a href="#用简单工厂模式改进抽象工厂" class="headerlink" title="用简单工厂模式改进抽象工厂"></a>用简单工厂模式改进抽象工厂</h3><p><img src="https://gcdnb.pbrd.co/images/65EAMYByzEXp.jpg?o=1"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataAccess类，简单工厂，在内部通过switch确定具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataAccess</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> IUser* <span class="title">CreateUser</span><span class="params">()</span> </span>{</span><br><span class="line">        IUser* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">switch</span> (db) {</span><br><span class="line">            <span class="keyword">case</span> DbType::SqlServer:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="built_in">SqlserverUser</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DbType::Access:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="built_in">AccessUser</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> IDepartment* <span class="title">CreateDepartment</span><span class="params">()</span> </span>{</span><br><span class="line">        IDepartment* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">switch</span> (db) {</span><br><span class="line">            <span class="keyword">case</span> DbType::SqlServer:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="built_in">SqlserverDepartment</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DbType::Access:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="built_in">AccessDepartment</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">DbType</span> {</span><br><span class="line">        SqlServer,</span><br><span class="line">        Access</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> DbType db = DbType::SqlServer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    IUser* user = DataAccess::<span class="built_in">CreateUser</span>();</span><br><span class="line">    user-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    user-&gt;<span class="built_in">GetUser</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    IDepartment* department = DataAccess::<span class="built_in">CreateDepartment</span>();</span><br><span class="line">    department-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">    department-&gt;<span class="built_in">GetDepartment</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>缺点：</strong>如果需要增加新的数据库访问，<strong>抽象工厂只需要增加一个工厂类</strong>即可，现在需要<strong>在DataAccess类中的每个方法的switch中加case</strong>。</p><h3 id="反射-抽象工厂"><a href="#反射-抽象工厂" class="headerlink" title="反射+抽象工厂"></a>反射+抽象工厂</h3><p>不希望通过switch的方式确定实例化对象，而是根<strong>据字符串db的值去某个地方找应该实例化的类</strong>。这就是<strong>依赖注入</strong>（Dependency Injection）。</p><p>只需要在程序顶端写上<strong>using System.Reflection</strong>来引用Reflection，就可以使用反射来克服抽象工厂模式的先天不足了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataAccess</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> IUser* <span class="title">CreateUser</span><span class="params">()</span> </span>{</span><br><span class="line">        std::string className = AssemblyName + <span class="string">"."</span> + db + <span class="string">"User"</span>;</span><br><span class="line">        <span class="comment">// 创建 IUser 对象的代码，需要使用 C++ 反射库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> IDepartment* <span class="title">CreateDepartment</span><span class="params">()</span> </span>{</span><br><span class="line">        std::string className = AssemblyName + <span class="string">"."</span> + db + <span class="string">"Department"</span>;</span><br><span class="line">        <span class="comment">// 创建 IDepartment 对象的代码，需要使用 C++ 反射库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string AssemblyName;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::string db;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::string DataAccess::AssemblyName = <span class="string">"抽象工厂模式"</span>;</span><br><span class="line"><span class="type">const</span> std::string DataAccess::db = <span class="string">"Sqlserver"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    IUser* user = DataAccess::<span class="built_in">CreateUser</span>();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">nullptr</span>) {</span><br><span class="line">        user-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">        user-&gt;<span class="built_in">GetUser</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    IDepartment* department = DataAccess::<span class="built_in">CreateDepartment</span>();</span><br><span class="line">    <span class="keyword">if</span> (department != <span class="literal">nullptr</span>) {</span><br><span class="line">        department-&gt;<span class="built_in">Insert</span>();</span><br><span class="line">        department-&gt;<span class="built_in">GetDepartment</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>扩展别的数据库访问时，只需要修改static const string db = “Oracle”即可。</p><p><strong>缺点：</strong>在更换数据库访问时，还是需要去该程序（改db这个字符串的值）重新编译。</p><h3 id="反射-配置文件"><a href="#反射-配置文件" class="headerlink" title="反射+配置文件"></a>反射+配置文件</h3><p>可以读文件来给db字符串赋值，在配置文件中写明具体要实例的类。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appSettings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"db"</span> <span class="attr">value</span>=<span class="string">"Sqlserver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appSettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》14-观察者模式</title>
      <link href="/2023/12/13/da-hua-she-ji-mo-shi-14-guan-cha-zhe-mo-shi/"/>
      <url>/2023/12/13/da-hua-she-ji-mo-shi-14-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>又叫<strong>发布-订阅模式</strong></li><li>定义了一种<strong>一对多</strong>的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/oPySEnAGKiIQ.png?o=1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subject类——抽象类或接口，保存所有观察者的引用，提供抽象接口增加或者删除观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Observer observer)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        observers.<span class="built_in">pop_back</span>(observer);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(Observer o : observers)</span><br><span class="line">        {</span><br><span class="line">            o.<span class="built_in">Update</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Observer&gt; observers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer类——抽象观察者，定义纯虚方法使具体观察者在收到通知后更新自己</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteSubject类——具体主题，将相关状态存入具体观察者，在具体主题内部状态改变时，给所有登记过的观察者发出通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">GetSubjectState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> subjectState;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSubjectState</span><span class="params">(string value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">subjectState = value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string subjectState;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteObserver类——具体观察者，实现更新接口，保存一个指向具体主题的引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteObserver</span>(ConcreteSubject subject, string name)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>.subject = subject;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Upate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">observerState = subject.GetSubjectState;</span><br><span class="line">cout &lt;&lt; <span class="string">"观察者"</span> &lt;&lt; name &lt;&lt; <span class="string">"的新状态是"</span> &lt;&lt; observerState &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ConcreteSubject <span class="title">GetSubject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetSubject</span><span class="params">(string value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">subject.<span class="built_in">SetSubjectState</span>(value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line">string observerState;</span><br><span class="line">ConcreteSubject subject;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ConcreteSubject s = <span class="keyword">new</span> <span class="built_in">ConcreteSubject</span>();</span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(s, <span class="string">"X"</span>));</span><br><span class="line">    s.<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(s, <span class="string">"Y"</span>));</span><br><span class="line">    s.<span class="built_in">Attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(s, <span class="string">"Z"</span>));</span><br><span class="line">    </span><br><span class="line">    s.SetSubjectState = <span class="string">"ABC"</span>;</span><br><span class="line">    s.<span class="built_in">Notify</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性，不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不变</li><li>当<strong>一个对象的改变需要同时改变其它对象</strong>，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式</li><li>一个抽象模型有两个方面，其中一个方面依赖于另一方面，这时用观察者模式可以将这两者<strong>封装在独立的对象中使它们各自独立地改变和复用</strong></li><li>所做的工作其实就是在<strong>解除耦合</strong>，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul><li><p>委托就是一种<strong>引用方法的类型</strong>。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。</p></li><li><p>委托方法的使用可以像其它任何方法一样，具有<strong>参数和返回值</strong>。委托可以看作是对函数的抽象，是函数的“类”，委托的实例将代表一个具体的函数</p></li><li><p>一个委托可以搭载多个方法，所有方法被<strong>依次唤起</strong>。可以使得委托对象所搭载的方法并不需要属于同一个类</p></li><li><p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是<strong>拥有相同的参数列表和返回值类型</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知者接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">GetSubjectState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> SubjectState;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetSubjectState</span><span class="params">(string value)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.SubjectState = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string SubjectState;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看股票的同事</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockObserver</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockObserver</span>(string name, Subject* sub)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sub = sub;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseStockMarket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; sub-&gt;<span class="built_in">GetSubjectState</span>() &lt;&lt; name &lt;&lt; <span class="string">"关闭股票详情"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Subject* sub;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看NBA的同事</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NBAObserver</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NBAObserver</span>(string name, Subject* sub)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sub = sub;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseNBADirectSeeding</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; sub-&gt;<span class="built_in">GetSubjectState</span>() &lt;&lt; name &lt;&lt; <span class="string">"关闭NBA直播"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Subject* sub;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 老板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> : <span class="keyword">public</span> Subject {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; Update;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Notify</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (Update) {</span><br><span class="line">            <span class="built_in">Update</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前台类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Secretary</span> : <span class="keyword">public</span> Subject</span><br><span class="line">{</span><br><span class="line"><span class="comment">// 与老板类相似，略</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Boss huhansan;</span><br><span class="line">    </span><br><span class="line">    <span class="function">StockObserver <span class="title">colledge1</span><span class="params">(<span class="string">"A"</span>, &amp;huhansan)</span></span>;</span><br><span class="line">    <span class="function">NBAObserver <span class="title">colledge2</span><span class="params">(<span class="string">"B"</span>, &amp;huhansan)</span></span>;</span><br><span class="line">    </span><br><span class="line">    huhansan.Update = [&amp;colledge1, &amp;colledge2]() {</span><br><span class="line">        colledge1.<span class="built_in">CloseStockMarket</span>();</span><br><span class="line">        colledge2.<span class="built_in">CloseNBADirectSeeding</span>();</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    huhansan.<span class="built_in">SetSubjectState</span>(<span class="string">"我胡汉三回来了！"</span>);</span><br><span class="line">    huhansan.<span class="built_in">Notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第八章读书笔记</title>
      <link href="/2023/12/13/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-ba-zhang-du-shu-bi-ji/"/>
      <url>/2023/12/13/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-ba-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="共享库版本"><a href="#共享库版本" class="headerlink" title="共享库版本"></a>共享库版本</h2><h3 id="共享库的兼容性"><a href="#共享库的兼容性" class="headerlink" title="共享库的兼容性"></a>共享库的兼容性</h3><ul><li>共享库的更新可以简单的分为两类：<ul><li><strong>兼容更新</strong>。所有的更新只是在原有的共享库基础上添加一些内容，所有原有的接口都保持不变。</li><li><strong>不兼容更新</strong>。共享库更新改变了原有的接口，使用该共享库原有接口的程序可能不能运行或运行不正常</li></ul></li></ul><p>接口指的是二进制接口ABI（Application Binary Interface），对于不同语言来说，主要包括一些诸如<strong>函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布</strong>等方面的规则。</p><ul><li><strong>导致C语言的共享库ABI发生变化</strong>的主要原因有以下4个：<ul><li><strong>导出函数的行为发生改变</strong>，调用这个函数产生的结果与以前不一样</li><li><strong>导出函数被删除</strong></li><li><strong>导出函数的结构发生变化</strong>，如共享库定义的结构体变量的结构被修改</li><li><strong>导出函数的接口发生变化</strong>，如函数返回值、参数被修改</li></ul></li><li>开发导出接口为C++的共享库，需要注意以下几点，防止ABI不兼容：<ul><li>不要再接口类内使用虚函数</li><li>不要改变类中任何成员变量的位置和类型</li><li>不要删除非内嵌的public或protected成员函数</li><li>不要将非内嵌的成员函数改变成内嵌成员函数</li><li>不要改变成员函数的访问权限</li><li>不要在接口中使用模板</li></ul></li></ul><h3 id="共享库版本命名"><a href="#共享库版本命名" class="headerlink" title="共享库版本命名"></a>共享库版本命名</h3><p>Linux中，共享库的文件命名规则必须如<strong>libname.so.x.y.z</strong>。</p><p>最前面使用前缀“lib”、中间是库的名字和后缀“.so”，最后面跟着的是三个数字组成的版本号。“x”表示<strong>主版本号</strong>（Major Version Number），“y”表示<strong>次版本号</strong>（Minor Version Number），“z”表示<strong>发布版本号</strong>（Release Version Number）。</p><ul><li>x表示主版本号，表示有重大升级，<strong>不同主版本号的库之间是不兼容的</strong></li><li>y表示次版本号，表示库的<strong>增量升级</strong>，即增加一些新的接口符号，且保持原来的符号不变，<strong>高的次版本号的库向后兼容低的次版本号的库</strong></li><li>z表示发布版本号，表示库的一些错误的修正、性能的改进，并不添加任何新的接口，相同主版本号、次版本号的共享库，<strong>不同发布版本号之间完全兼容</strong></li></ul><h3 id="SO-NAME"><a href="#SO-NAME" class="headerlink" title="SO-NAME"></a>SO-NAME</h3><p>程序依赖的共享库由.dynamic段指出，若指出完整版本（主次发布都有）的共享库名字，则每次更新共享库必须保存之前的版本，会造成磁盘和内存（会同时装载不同版本的共享库）的压力巨大，因此Linux制订了SO-NAME命名规则。即<strong>去掉次版本号和发布版本号，保留主版本号</strong>——<strong>libname.so.x</strong>。</p><p>系统会给每个共享库所在的目录创建一个与SO-NAME同名的软连接，指向<strong>最新版本的共享库（主版本号相同）</strong>，可见，一个共享库若安装了多个主版本，则会有多个对应的软连接。</p><p>建立SO-NAME为名的软链接的目的是，使得所有依赖某个共享库的模块，在编译、链接和运行时，都是<strong>用共享库的SO-NAME，而不使用详细的版本号</strong>。</p><p>Linux中有一个工具“<strong>ldconfig</strong>”，当系统安装或更新一个共享库时，会遍历默认共享库目录，更新或创建相应的软连接。</p><p><strong>gcc -lXXX</strong> 表示链接XXX共享库，系统会查找最新版本的XXX库(往往由-L指定)。其可以是动态的或是静态的,使用-lc 会根据输出文件的情况选择合适版本(静态或是动态)的库。比如使用“-static”参数时，就会查找.a文件，如果使用”-Bdynamic”参数（默认情况），就会查找最新的libname.so.x.y.z。</p><h2 id="符号版本"><a href="#符号版本" class="headerlink" title="符号版本"></a>符号版本</h2><p>若应用程序依赖lib.so的2.5版本而系统中只有2.3版，因为SO-NAME相同程序会正常运行，但是若引用到了2.5添加的符号则会异常退出，这就是<strong>次版本号交会问题</strong>。</p><h3 id="基于符号的版本机制"><a href="#基于符号的版本机制" class="headerlink" title="基于符号的版本机制"></a>基于符号的版本机制</h3><p>符号版本方法是对SO-NAME机制的一种补充。<strong>让每个导出和导入的符号都有一个相关联的版本号</strong>，它的实际做法类似于名称修饰的方法。</p><p>共享库构建的链接过程可以链接编写好的<strong>符号版本脚本</strong>。脚本里就是一些集合，集合有自己的名称如VERS_1.1，集合里包含共享库定义的符号，这样共享库的符号都有了自己的版本(所属集合名称)。同时集合之间可以有<strong>继承</strong>关系，如VERS_1.2继承于VERS_1.1，这样共享库构建完成的.so文件就会包含集合的相关内容。</p><p>程序里面记录的不是构建时共享库中版本最新的符号集合，而是程序<strong>所依赖的集合中版本号最小的那个</strong>。</p><h3 id="Linux中的符号版本"><a href="#Linux中的符号版本" class="headerlink" title="Linux中的符号版本"></a>Linux中的符号版本</h3><p>Linux下符号版本机制并没有广泛应用，主要使用的是glibc下的一部分共享库。<br>Linux下对Solaris的符号版本有两种扩展：</p><ul><li><p>除了可以在符号版本脚本中指定符号的版本外，可以在c/c++源代码中通过<br>asm(“<strong>.symver</strong> symbolInCode,<a href="mailto:symbolInScript@VERS_1.1">symbolInScript@VERS_1.1</a>“)<br>添加符号到符号标签。</p></li><li><p>gcc允许同一个符号存在于多个版本的共享库中,在链接层面的一种<strong>符号重载</strong>机制。<br>这种重载机制的好处是，可以在少量已有接口的接口或含义修改时，不用升级主版本，即可保证不影响旧版的功能。<br>asm(“.symver newprintf,<a href="mailto:printf@VERS_1.1">printf@VERS_1.1</a>“)<br>asm(“.symver oldprintf,<a href="mailto:printf@VERS_1.1">printf@VERS_1.1</a>“)<br>void oldprintf(){}<br>void newprintf(){}</p></li></ul><p>Linux下可以使用<strong>“–version_script”</strong>参数将符号版本脚本文件传递个链接器：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC lib.c -Xlinker --version-script lib.ver -o lib.so</span><br></pre></td></tr></tbody></table></figure><h3 id="共享库系统路径"><a href="#共享库系统路径" class="headerlink" title="共享库系统路径"></a>共享库系统路径</h3><p><strong>FHS</strong>(File Hierachy Standard)标准规定，一个系统中主要有3个存放共享库的位置：</p><ul><li>lib，这个位置主要存放系统<strong>最关键和基础的共享库</strong>，比如动态链接器、C语言运行库、数学库等，这些库主要是那些/bin和/sbin下的程序所需要用到的库，还有系统启动时需要的库。</li><li>/usr/lib，这个目录下主要保存的是一些<strong>非系统运行时所需要的关键性的共享库</strong>，主要是一些开发时用到的共享库，这些共享库一般不会被用户的程序或shell脚本直接用到。这个目录下面还包含了开发时可能会用到的静态库、目标文件等。</li><li>/usr/local/lib，这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些<strong>第三方的应用程序的库</strong>。</li></ul><h2 id="共享库查找过程"><a href="#共享库查找过程" class="headerlink" title="共享库查找过程"></a>共享库查找过程</h2><p>任何一个动态链接的模块所依赖的模块路径保存在“.dynamic”段里面，由<strong>DT_NEED</strong>类型的项表示。动态链接器对于模块的查找有一定的规则：如果DT_NEED里面保存的是<strong>绝对路径</strong>，那么动态链接器就按照这个路径去查找；如果DT_NEED里面保存的是<strong>相对路径，</strong>那么动态链接器会在**/lib、/usr/lib和由/etc/ld.so.conf配置文件指定的目录**中查找共享库。</p><p>如果遍历这些目录查找共享库的话，则查找的效率会非常低，特别是随着所安装的程序越来越多，ld.so.conf的内容会越来越多。因此为解决这一问题，linux 中存在一个 <strong>ldconfig</strong> 的程序。</p><p>ldconfig 命令的用途：主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库(格式如前介绍,lib.so)，进而创建出动态装入程序(ld.so)所需的连接和缓存文件，缓存文件默认为 <strong>/etc/ld.so.cache</strong>，此文件保存已排好序的动态链接库名字列表，通过缓存<strong>加快查找速度</strong>。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li><strong>LD_LIBRARY_PATH</strong><br>改变ld查找共享库的过程，会<strong>先查询由该变量指定的路径在默认查找</strong>。方便共享库开放的调试和测试。不应被滥用。且会影响gcc编译查找库的路径，效果相当于gcc的-L参数。</li><li><strong>LD_PRELOAD</strong><br>会提前装载指定的共享库，比前面那个变量优先级高。由于全局符号介入机制的存在，可以方便改写标准C库的某个或某几个函数而不影响其他函数，调试和测试有用。<br>(/etc/ld.so.preload与该变量作用一样)</li><li><strong>LD_DEBUG</strong><br>根据值的不同，动态链接器会在运行时打印出各种有用的信息。可以设置成以下几个值：<ul><li>bindings——显示动态链接的符号绑定过程</li><li>libs——显示共享库的查找过程</li><li>versions——显示符号版本的依赖关系</li><li>reloc——显示重定位过程</li><li>symbols——显示符号表查找过程</li><li>statistics——显示动态链接过程中各种统计信息</li><li>all——显示所有信息</li></ul></li></ul><h2 id="共享库的创建和安装"><a href="#共享库的创建和安装" class="headerlink" title="共享库的创建和安装"></a>共享库的创建和安装</h2><h3 id="共享库的创建"><a href="#共享库的创建" class="headerlink" title="共享库的创建"></a>共享库的创建</h3><p>最关键的参数即-shared与-fPIC，我们还可以使用**-W1,-soname,SO-NAME**(SO-NAME是使用者指定的字符串)来指定输出共享库的SO-NAME。</p><p>除了使用<strong>LD_LIBRARY_PATH</strong>之外，我们还可以使用ld的**-rpath<strong>参数，或者gcc的</strong>-W1,-rpath,path**参数来指定共享库查找路径。</p><h3 id="清除符号信息"><a href="#清除符号信息" class="headerlink" title="清除符号信息"></a>清除符号信息</h3><p>我们可以使用<strong>strip</strong>工具来清除共享库或可执行文件的所有符号和调试信息。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip libfoo.so</span><br></pre></td></tr></tbody></table></figure><p>除了使用“strip”工具，我们还可以使用ld的<strong>“-s”和“-S”</strong>参数，使得链接器生成输出文件时就不产生符号信息。“-s”和“-S”的区别是：“-S”消除调试符号信息，而“-s”消除所有符号信息。我们也可以在gcc中通过<strong>“-Wl,-s”</strong>和<strong>“-Wl,-S”</strong>给ld传递这两个参数。</p><h3 id="共享库的安装"><a href="#共享库的安装" class="headerlink" title="共享库的安装"></a>共享库的安装</h3><p>最简单的办法就是将共享库复制到某个标准的共享库目录，如/lib、/usr/lib等，然后运行<strong>ldconfig</strong>。</p><h3 id="共享库的构造和析构函数"><a href="#共享库的构造和析构函数" class="headerlink" title="共享库的构造和析构函数"></a>共享库的构造和析构函数</h3><p>GCC提供了一种共享库的构造函数，只要在函数声明时加上_<em>attribute</em>_((constructor))的属性，即指定该函数为共享库构造函数，拥有这种属性的函数会在共享库加载时被执行，即在程序的main函数之前执行(同样会在dlopen之前执行)。</p><p>与共享库构造函数相对应的是析构函数，我们可以使用在函数声明时加上_<em>attribute</em>_((destructor))的属性，这种函数会在main()函数执行完毕之后执行（或者是程序调用exit()时执行）。</p><p>有多个构造和析构函数时，我们还可以给它们指定<strong>优先级</strong>：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__((constructor(5))) init_function(void);</span><br><span class="line">void __attribute__((constructor(10))) init_function2(void);</span><br></pre></td></tr></tbody></table></figure><p><strong>对于构造函数来说，优先级数字越小越先执行，而对于析构函数来说，则刚好相反。</strong></p><h3 id="共享库脚本"><a href="#共享库脚本" class="headerlink" title="共享库脚本"></a>共享库脚本</h3><p>可以将几个现有共享库组合起来，从用户的角度来看就是一个新的共享库。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GROUP(/lib/libc.so.6 /lib/libm.so.2)</span><br></pre></td></tr></tbody></table></figure><p>语法命令方面跟链接脚本没有什么不同，作用也相似，即将一个或多个输入文件以一定格式经过变换后形成一个输出文件，所以共享库脚本也叫做<strong>动态链接脚本</strong>，链接过程是在运行时完成的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》13-建造者模式</title>
      <link href="/2023/12/12/da-hua-she-ji-mo-shi-13-jian-zao-mo-shi/"/>
      <url>/2023/12/12/da-hua-she-ji-mo-shi-13-jian-zao-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>将一个复杂<strong>对象的构建与它的表示分离</strong>，使得同样的构建过程可以创建不同的表示</li><li>又叫生成器模式，将一个产品的内部表象与产品的生成过程分割开来，是一个建造过程生成具有不同内部表象的产品对象</li><li>如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/pWZkWktysabS.png?o=1"></p><ul><li>主要用于创建一些复杂的对象，这些对象内部构建间的<strong>建造顺序通常是稳定的</strong>，但对象内部的构建通常面临着复杂的变化</li><li>好处就是使得<strong>建造代码与表示代码分离</strong>，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了</li><li>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Product类——产品类，由多个部件组成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(string part)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        parts.<span class="built_in">push_back</span>(part);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"产品创建："</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(string part : parts)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; part &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; parts;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder类——抽象建造者，确定产品的组成，并声明一个得到产品建造后结果的方法GetResult</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildPartB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product <span class="title">GetResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteBuilder1类——具体建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder1</span> : <span class="keyword">public</span> Builder</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteBuilder1</span>()</span><br><span class="line">{</span><br><span class="line">product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">BuildPartA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">product.<span class="built_in">Add</span>(<span class="string">"部件A"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">BuildPartB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">product.<span class="built_in">Add</span>(<span class="string">"部件B"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Product <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Product product;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteBuilder2类——具体建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder2</span> : <span class="keyword">public</span> Builder</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcreteBuilder2</span>()</span><br><span class="line">{</span><br><span class="line">product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">BuildPartA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">product.<span class="built_in">Add</span>(<span class="string">"部件X"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">BuildPartB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">product.<span class="built_in">Add</span>(<span class="string">"部件Y"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Product <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> product;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Product product;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director类——指挥者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Construct</span><span class="params">(Builder builder)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        builder.<span class="built_in">BuildPartA</span>();</span><br><span class="line">        builder.<span class="built_in">BuildPartB</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Director director = <span class="keyword">new</span> <span class="built_in">Director</span>();</span><br><span class="line">    Builder b1 = <span class="keyword">new</span> ConcreteBuilder1;</span><br><span class="line">    Builder b2 = <span class="keyword">new</span> ConcreteBuilder2;</span><br><span class="line">    </span><br><span class="line">    director.<span class="built_in">Construct</span>(b1);</span><br><span class="line">    Product p1 = b1.<span class="built_in">Getresult</span>();</span><br><span class="line">    p1.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    director.<span class="built_in">Construct</span>(b2);</span><br><span class="line">    Product p2 = b2.<span class="built_in">Getresult</span>();</span><br><span class="line">    p2.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》12-外观模式</title>
      <link href="/2023/12/11/da-hua-she-ji-mo-shi-12-wai-guan-mo-shi/"/>
      <url>/2023/12/11/da-hua-she-ji-mo-shi-12-wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p><p>外观模式用于解除系统与其他系统之间的强耦合，子系统通过Facade将功能暴露给外界，外界调用时<strong>无需考虑子系统实现对应功能时需要如何调整系统顺序、运行哪一个方法</strong>，而是直接调用Faxcade的接口就行。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/EUCfYDri4GpP.png?o=1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemOne</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"子系统1方法1"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemTwo</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"子系统2方法2"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemThree</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodThree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"子系统3方法3"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystemFour</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodFour</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"子系统4方法4"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Facade</span>()</span><br><span class="line">    {</span><br><span class="line">        one = <span class="keyword">new</span> <span class="built_in">SubSystemOne</span>();</span><br><span class="line">        two = <span class="keyword">new</span> <span class="built_in">SubSystemTwo</span>();</span><br><span class="line">        two = <span class="keyword">new</span> <span class="built_in">SubSystemThree</span>();</span><br><span class="line">        four = <span class="keyword">new</span> <span class="built_in">SubSystemFour</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"方法组A:"</span> &lt;&lt; endl;</span><br><span class="line">        one.<span class="built_in">MethodOne</span>();</span><br><span class="line">        two.<span class="built_in">MethodTwo</span>();</span><br><span class="line">        four.<span class="built_in">MethodFour</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MethodB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"方法组B:"</span> &lt;&lt; endl;</span><br><span class="line">        two.<span class="built_in">MethodTwo</span>();</span><br><span class="line">        three.<span class="built_in">MethodThree</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SubSystemOne one;</span><br><span class="line">    SubSystemTwo two;</span><br><span class="line">    SubSystemThree two;</span><br><span class="line">    SubSystemFour four;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Facade facade = <span class="keyword">new</span> <span class="built_in">Facade</span>();</span><br><span class="line">    </span><br><span class="line">    facade.<span class="built_in">MethodA</span>();</span><br><span class="line">    facade.<span class="built_in">MethodB</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>在设计初期阶段，应该有意识的将不同的两个层分离，层与层之间建立外观Facade</p></li><li><p>其次在开发阶段，子系统因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖</p></li><li><p>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比骄傲清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作</p><p><img src="https://gcdnb.pbrd.co/images/nR8wPRySH9VW.png?o=1"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》11-迪米特法则</title>
      <link href="/2023/12/10/da-hua-she-ji-mo-shi-11-di-mi-te-fa-ze/"/>
      <url>/2023/12/10/da-hua-she-ji-mo-shi-11-di-mi-te-fa-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><ul><li>最少知识原则</li><li>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过<strong>第三者转发</strong>这个调用</li><li>在类的结构设计上，每一个类都应当<strong>尽量降低成员的访问权限</strong>，即不需要让类知道的字段或行为就不要公开(private)</li><li>根本思想是 强调了类之间的松耦合</li><li>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》10-模板方法模式</title>
      <link href="/2023/12/09/da-hua-she-ji-mo-shi-10-mo-ban-mo-shi/"/>
      <url>/2023/12/09/da-hua-she-ji-mo-shi-10-mo-ban-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个操作中的算法的骨架，而将一些步骤<strong>延迟到子类</strong>中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/32vuzv9r6RDJ.png?o=1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractClass</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TemplateMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">PrimitiveOperation1</span>();</span><br><span class="line">        <span class="built_in">PrimitiveOperation2</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassA</span> : <span class="keyword">public</span> AbastractClass</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体类A方法1实现"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体类A方法2实现"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClassB</span> : <span class="keyword">public</span> AbastractClass</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体类B方法1实现"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体类B方法2实现"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    AbastractClass c;</span><br><span class="line">    </span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">ConcreteClassA</span>();</span><br><span class="line">    c.<span class="built_in">TemplateMethod</span>();</span><br><span class="line">    </span><br><span class="line">    c = <span class="keyword">new</span> <span class="built_in">ConcreteClassB</span>();</span><br><span class="line">    c.<span class="built_in">TemplateMethod</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>继承就应该成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复</li><li>当要完成某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，通常考虑用<strong>模板方法模式</strong>来处理</li><li>通过把不变行为搬迁到超类，去除子类中的重复代码来体现它的优势</li><li>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬迁到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》9-原型模式</title>
      <link href="/2023/12/08/da-hua-she-ji-mo-shi-9-yuan-xing-mo-shi/"/>
      <url>/2023/12/08/da-hua-she-ji-mo-shi-9-yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>用原型实例指定创建对象的种类，并且通过<strong>拷贝这些原型创建新的对象</strong></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/B8VYxgC8L5Jg.png?o=1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型类Prototype</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Prototype</span>(string id)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>._id = id;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    string Id</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _id;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抽象类关键就是有这个Clone纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">Clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类ConcretePrototype</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype1</span> : Prototype</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConcretePrototype1</span>(string id) : <span class="built_in">Prototype</span>(id){}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">Clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcretePrototype1</span>(*<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ConcretePrototype1 p1 = <span class="keyword">new</span> <span class="built_in">ConcretePrototype1</span>(<span class="string">"xiaohuang"</span>);</span><br><span class="line">    ConcretePrototype1 c1 = (ConcretePrototype1)p1.<span class="built_in">Clone</span>();<span class="comment">// 通过克隆对象p1就可以得到新对象c1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节</li><li>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又对性能是大大的提高</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li></ul><h3 id="深复制与浅复制"><a href="#深复制与浅复制" class="headerlink" title="深复制与浅复制"></a>深复制与浅复制</h3><ul><li>如果方法的字段是值类型，对该字段执行逐位复制；如果字段是引用类型，则复制引用而不复制引用的对象，即引用的对象数据是不会被克隆过来的</li><li>浅复制：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其它对象的引用仍然指向原来的对象</li><li>深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象</li></ul><p><strong>原型模式里面的深复制需要程序员设计实现。</strong></p><h3 id="深复制案例"><a href="#深复制案例" class="headerlink" title="深复制案例"></a>深复制案例</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作经历类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkExperience</span> : ICloneable</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _workdate;</span><br><span class="line">string _company;</span><br><span class="line"></span><br><span class="line"><span class="function">Object* <span class="title">Clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WorkExperience</span>(*<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简历类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span> : ICloneable</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Resume</span>(string name)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>._name = name;</span><br><span class="line">work = <span class="keyword">new</span> <span class="built_in">WorkExperience</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Resum</span>(WorkExperience work)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>._work = (WorkExperience)work.<span class="built_in">Clone</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPersonalInfo</span><span class="params">(string sex, string age)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>._sex = sex;</span><br><span class="line"><span class="keyword">this</span>._age = age;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetWorkExperience</span><span class="params">(string workdate, string company)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_work._workdate = workdate;</span><br><span class="line">_work._company = company;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; _name &lt;&lt; _sex &lt;&lt; _age &lt;&lt; _work._workdate &lt;&lt; _work._company;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">Clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Resume obj = <span class="keyword">new</span> <span class="built_in">Resume</span>(<span class="keyword">this</span>._work);</span><br><span class="line">obj._name = <span class="keyword">this</span>._name;</span><br><span class="line">obj._sex = <span class="keyword">this</span>._sex;</span><br><span class="line">obj._age = <span class="keyword">this</span>._age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _name;</span><br><span class="line">string _sex;</span><br><span class="line">string _age;</span><br><span class="line">WorkExperience _work;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》8-工厂模式</title>
      <link href="/2023/12/07/da-hua-she-ji-mo-shi-8-gong-han-mo-shi/"/>
      <url>/2023/12/07/da-hua-she-ji-mo-shi-8-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。<strong>工厂方法使一个类的实例化延迟到其子类。</strong></p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/FGOoTkdE2eyS.png?o=1"></p><p><img src="https://gcdnb.pbrd.co/images/PAFnQ6nw5bHz.png?o=1" alt="计算器的工厂模式实现"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IFactory</span></span><br><span class="line">{</span><br><span class="line"><span class="function">Operation <span class="title">CreateOpenration</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加减乘除各建一个具体工厂去实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OperationAdd</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OperationSub</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OperationMul</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivFactory</span> : <span class="keyword">public</span> IFactory</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Operation <span class="title">CreateOperation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OperationDiv</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">IFactory operFactory = <span class="keyword">new</span> <span class="built_in">AddFactory</span>();</span><br><span class="line">Operation oper = operFactory.<span class="built_in">CreateOperation</span>();</span><br><span class="line">oper.NumberA = <span class="number">1</span>;</span><br><span class="line">oper.NumberB = <span class="number">2</span>;</span><br><span class="line"><span class="type">double</span> result = oper.<span class="built_in">GetResult</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="简单工厂模式-VS-工厂模式"><a href="#简单工厂模式-VS-工厂模式" class="headerlink" title="简单工厂模式 VS 工厂模式"></a>简单工厂模式 VS 工厂模式</h3><ul><li>简单工厂模式的最大优点：工厂类包含了必要的逻辑判断（switch），根据客户端的选择动态实例化相关的类，对于客户端来说去除了与具体产品的依赖，<strong>想要加功能是通过改工厂类实现</strong></li><li>工厂方法模式实现时，客户端要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行，<strong>想要加功能是通过改客户端实现</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第七章读书笔记</title>
      <link href="/2023/12/07/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-qi-zhang-du-shu-bi-ji/"/>
      <url>/2023/12/07/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-qi-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要动态链接"><a href="#为什么需要动态链接" class="headerlink" title="为什么需要动态链接"></a>为什么需要动态链接</h2><h3 id="静态链接存在的问题"><a href="#静态链接存在的问题" class="headerlink" title="静态链接存在的问题"></a>静态链接存在的问题</h3><ol><li>内存和磁盘空间的<strong>浪费</strong>，会在内存和磁盘中存在多份同一程序的拷贝；</li><li>对程序的<strong>更新、部署、发布十分麻烦</strong>，程序开发和发布时不得不重新链接一遍所有文件，每次都需要用户下载新的连接之后的可执行文件</li></ol><h3 id="动态链接的优缺点"><a href="#动态链接的优缺点" class="headerlink" title="动态链接的优缺点"></a>动态链接的优缺点</h3><ol><li><strong>基本思想：</strong>把程序的模块相互分割开来，形成独立文件，等到程序<strong>运行时</strong>才进行链接；把链接这个过程从装载前推迟到了装载后。</li><li>解决了共享的目标文件多个副本浪费磁盘和内存空间的问题；</li><li>减少物理页面的换入换出，可以增加CPU<strong>缓存命中率</strong>；</li><li>使程序<strong>升级变得容易</strong>，当需要升级程序库或者程序共享的某个模块式，只要将旧的目标文件覆盖掉，无序将所有程序链接；</li><li>使程序在运行时可以动态地选择加载的模块，可以制作<strong>插件</strong>；</li><li>加强了程序的<strong>兼容性</strong>，消除了程序对不同平台之间依赖的差异性；</li><li><strong>缺点：</strong><ul><li>DLL Hell：当程序所依赖的某个模块更新后，由于新的模块和旧的模块之间某学接口不兼容，导致原有程序无法运行</li><li>每次装载都要重新链接，会造成一定的性能损失，但是可以通过“<strong>延迟绑定</strong>”解决</li></ul></li></ol><h2 id="简单的动态链接的例子"><a href="#简单的动态链接的例子" class="headerlink" title="简单的动态链接的例子"></a>简单的动态链接的例子</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">        foobar(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program2.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">        foobar(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Printing from Lib.so %d\n"</span>, i);</span><br><span class="line">        sleep(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foobar</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>使用<strong>GCC</strong>将Lib.c<strong>编译</strong>为一个共享对象文件：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared -o Lib.so Lib.c</span><br></pre></td></tr></tbody></table></figure><p><em>-shared：表示产生共享对象</em></p><ul><li>分别<strong>编译链接</strong>Program1.c和Program2.c：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o Program1 Program1.c ./Lib.so</span><br><span class="line">gcc -o Program2 Program2.c ./Lib.so</span><br></pre></td></tr></tbody></table></figure><p>整个编译链接过程如图：</p><p><img src="https://gcdnb.pbrd.co/images/OjQh75N6dcn6.png?o=1"></p><ul><li><p>如果是静态链接的情况下</p><ul><li>在Program1.o被链接成可执行文件这一步，会直接<strong>把Program1.o和Lib.o链接到一起</strong>，输出可执行文件Program1</li><li>如果foobar是一个定义在其他静态目标模块中的函数，链接器将会按照静态链接的规则，将Program1.o中的foobar<strong>地址引用重定位</strong></li></ul></li><li><p>如果是动态链接的情况下</p><ul><li>在Program1.o被链接成可执行文件这一步，链接的输入只有Program1.o</li><li>如果foobar是定义在某个动态共享对象中的函数，链接器就会将这个符号的引用标记为一个动态链接的符号，把地址重定位的过程留到<strong>装载时进行</strong></li></ul><p>链接器怎么知道foobar的引用是静态符号还是动态符号呢？</p><p><strong>Lib.so中保存了完整的符号信息，需要把其作为链接的输入文件之一。</strong></p></li><li><p><strong>Lib.so</strong>和Program1都被操作系统以同样的方法映射到进程的虚拟地址空间。</p></li><li><p><strong>ld-xx.so</strong>是Linux下的动态链接器，与普通共享对象一样被映射到了进程的地址空间。</p></li><li><p><strong>共享对象的最终装载地址在编译时不确定</strong>，在装载时装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p></li></ul><h2 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="*地址无关代码"></a>*地址无关代码</h2><ul><li><p><strong>固定装载地址的困扰</strong></p><p>为了实现动态链接，首先会遇到问题是<strong>共享对象地址的冲突问题</strong>。</p><p>静态共享库的做法就是将程序的各个模块统一交给操作系统来管理，操作系统在某个<strong>特定的地址划分出来一些地址块</strong>，为那些已知的模块预留足够的空间，存在以下几个问题：</p><ul><li>地址冲突问题！</li><li>升级问题！</li></ul><p><strong>解决：</strong></p><p><strong>共享对象在编译时不能假设自己在进程虚拟地址空间中的位置</strong>。</p><p>可执行文件是第一个被加载的文件，所以可以选择一个固定的空闲地址，<strong>Windows下是0x0040000，Linux下是0x08040000</strong>。</p></li><li><p><strong>装载时重定位</strong></p><p><strong>装载时重定位（基址重置）：</strong></p><p>当同时多个程序运行的时候，操作系统根据当时内存的空闲情况，动态分配一块大小合适的物理内存给程序。整个程序是按照一个整体被加载的，所以<strong>程序中指令和数据的相对位置不变</strong>，系统在装载程序的时候需要对程序的指令和数据中对绝对地址的引用进行重定位。</p><p><strong>如果只使用-shared参数，那么输出的共享对象就是使用装载时重定位的方法。</strong></p><p><em>例子：一个程序在编译时假定被装载的目标地址是0x1000，实际被分配地址是0x4000，那么程序中的指令或数据中的绝对引用都只要加上0x3000的偏移量即可</em></p><p><strong>问题：</strong></p><p>动态链接库被装载映射到虚拟空间后，指令部分是在多个进程之间共享，指令被重定位后对于每一个进程来说是不同的，失去了动态链接节省内存的优势！</p><p><strong>解决：</strong></p><p>希望模块中共享的指令部分在装载时不需要因为装载地址改变而改变，那就<strong>把指令中那些需要修改的部分提出来放在数据部分</strong>，这样指令部分就不变，数据部分在每个进程中有个副本。这种技术就是<strong>地址无关代码</strong>（PIC，Position-Independent Code）。</p></li><li><p><strong>地址无关代码</strong></p><p>对于共享模块的不同引用（模块内引用和模块外引用）、不同引用方式（指令引用和数据访问）可以把寻址方式分为四类：</p><ul><li><strong>模块内部</strong>的<strong>函数</strong>调用、跳转</li><li><strong>模块内部</strong>的<strong>数据</strong>访问</li><li><strong>模块外部</strong>的<strong>函数</strong>调用、跳转</li><li><strong>模块外部</strong>的<strong>数据</strong>访问</li></ul><p><img src="https://gcdnb.pbrd.co/images/ccLVwl0ge6M0.png?o=1"></p><ol><li><p>模块内部调用或者跳转</p><p>最简单，被调用的函数和调用者在同一个模块，他们之间的相对位置是固定的。模块内部的跳转和函数调用都可以是<strong>相对地址调用</strong>，或者<strong>基于寄存器的相对调用</strong>，这些指令是不需要重定位的。本身就是地址无关的。</p></li><li><p>模块内部数据访问</p><p>一个模块间各个页之间的相对位置固定，只需要<strong>当前指令加上固定的偏移量就可以访问模块内数据</strong>。但是没有这种相对当前指令的寻址方式，所以ELF通过“**_i686.get_pc_thunk.cx**”函数获取当前的PC值，然后再加上一个偏移量就可以访问到相应变量的地址了。</p></li><li><p>模块外部数据访问</p><p>比较麻烦，因为模块间的数据访问目标地址要等到装载时才确定，那就把跟地址相关的部分放到数据段，然后ELF通过<strong>在数据段里面建立一个指向这些变量的指针数组</strong>，也就是<strong>全局偏移表GOT</strong>（global offset table），当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。</p><p><img src="https://gcdnb.pbrd.co/images/qLCTSPJjDoEr.png?o=1"></p><p><strong>GOT的小设计</strong>：</p><ul><li>它本身是放在数据段的，所以每个进程有一个副本，那就可以在装载时被修改，进程间相互不受影响</li><li>因为模块在编译时就可以确定内部变量相对于当前指令的偏移（类型二），那么GOT在编译时就可以确定位置，然后根据变量地址在GOT中的偏移就可以得到变量的地址。</li></ul></li><li><p>模块外部调用或者跳转</p><p>类似于类型三，<strong>GOT中存的是目标函数的地址</strong>。先得到当前指令地址PC，然后加上一个偏移得到函数地址在GOT中的偏移，然后是一个间接引用。</p></li></ol><p><em>-fpic与-fPIC区别：小写编译参数在某些平台有限制，比如全局符号的数量或代码长度，大写没有。</em></p><p><em>如何区分一个DSO是否为PIC：readelf -d foo.so | grep TEXTREL，如果有输出就不是PIC，否则就是PIC的。TEXTREL是代码段的重定位表地址。</em></p></li><li><p><strong>共享模块的全局变量问题</strong></p><p><img src="https://img-blog.csdnimg.cn/20190307165409206.png"></p><p><strong>问题：</strong></p><p>当编译器编译上述代码时，无法根据上下文判断global是定义在同一个模块的其他目标文件，还是定义在另外一个共享对象之中的，即<strong>无法判断是否是跨模块间的调用</strong>。</p><p><strong>解决：</strong></p><p>链接器会在创建可执行文件时，在它的.bss段创建一个global的副本，所有的使用这个变量的指令都<strong>指向位于可执行文件中的那个</strong>。ELF共享库在编译的时候，默认都把定义在模块内部的全局变量当做定义在其他模块的全局变量（类型四），通过GOT来实现变量的访问。当共享模块被装载时：</p><ul><li>如果某个全局变量在<strong>可执行文件中有副本</strong>，那么动态链接库会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终就只有一个实例</li><li>如果变量在<strong>共享模块中被初始化</strong>，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本</li><li>如果该全局变量在<strong>程序主模块中没有副本</strong>，那么GOT中的相应地址就指向模块内部的该变量副本。</li></ul></li><li><p><strong>数据段地址无关</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span>* p = &amp;a;</span><br></pre></td></tr></tbody></table></figure><p><em>p的地址是一个绝对地址，指向a，而变量a的地址随着共享对象的装载地址改变而改变。</em></p><p>对于数据段来说，他在每个进程中的都有一个独立的副本，所以并不担心被进程改变。可以选择装载时重定位的方法解决数据段中绝对地址引用问题，对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器会产生一个重定位表，这个重定位表里面包含一个<strong>R_386_RELATIVE</strong>类型的重定位入口，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。</p></li></ul><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><ul><li><p><strong>基本思想</strong></p><p><strong>函数第一次被用到时才进行绑定</strong>。</p></li><li><p><strong>实现方式</strong></p><p><strong>PLT</strong>（procedure linkage table）：</p><p>第一次调用函数时，需要调用动态链接器的**_dl_runtime_resolve()<strong>函数，这个函数需要知道绑定的</strong>模块<strong>和哪个</strong>函数**等信息来进行绑定操作。当调用某个外部函数时，PLT为了实现延迟绑定，调用函数不直接通过GOT跳转，而是通过一个PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项。</p><p>ELF将GOT拆分成了两个表 <strong>.got</strong>和**.got.plt<strong>。.got用来保存</strong>全局变量引用<strong>的地址，.got.plt用来保存</strong>函数引用**的地址。所有对于外部函数的引用全部被分离出来存放到了.got.plt中。另外.got.plt还有前三个特殊的项</p><ul><li>第一项保存的是.dynamic段的地址，描述了本模块动态链接相关的信息</li><li>第二项是本模块的ID</li><li>第三项是保存的_dl_runtime_resolve的地址</li></ul><p><img src="https://gcdnb.pbrd.co/images/j4u7lEyIQpuC.png?o=1"></p></li></ul><h2 id="动态链接相关结构"><a href="#动态链接相关结构" class="headerlink" title="动态链接相关结构"></a>动态链接相关结构</h2><ul><li><p><strong>链接的具体过程！</strong></p><ul><li>操作系统首先读取可执行文件的头部，检查文件的合法性</li><li>然后从头部中的program header中读取每个segment的虚拟地址、文件地址、属性，将它们映射到进程虚拟地址空间的相应位置</li><li>接下来看是静态链接还是动态链接<ul><li>在静态链接的情况下，操作系统接着就可以把控制权转交给可执行文件的入口地址，然后程序开始执行</li><li>在动态链接的情况下，在映射完可执行文件后，操作系统会先启动一个动态链接器，在Linux下动态链接器ld.so其实是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中，操作系统在加载完动态链接库之后，就将控制权交给动态链接器的入口地址。当动态链接器得到控制权之后，就开始一系列自身的初始化操作，然后根据当时的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成以后，动态链接器就会将控制权交给可执行文件的入口地址，程序开始正式执行。</li></ul></li></ul></li><li><p><strong>.interp段</strong></p><p>动态链接器的位置不是由系统配置指定的，也不是由环境变量决定的，而是由<strong>ELF可执行文件的.interp段指定的</strong>。不同的系统，链接器的位置不同。</p></li><li><p><strong>.dynamic段</strong></p><p><strong>最重要的结构</strong>，存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    } d_un;</span><br><span class="line">} Elf32_Dyn;</span><br></pre></td></tr></tbody></table></figure><p>使用<strong>readelf -d</strong>工具来查看<code>.dynamic</code>段的内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -d Lib.so</span><br></pre></td></tr></tbody></table></figure><p>使用<strong>ldd</strong>工具来查看一个程序主模块或共享库依赖于哪些共享库。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd Program1</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>动态符号表</strong></p><p>为了表示动态链接这些模块之间的符号导入导出关系，ELF专门有一个动态符号表的段来保存这些信息，段名是**.dynsym**。</p><p>.dynsym只保存了与动态链接相关的符号，对于模块内部的符号则不保存。</p><p>动态符号表也需要一些辅助的表，比如用于保存符号名的字符串表**.dynstr**。</p><p>为了加快符号的查找过程，需要一个辅助的符号哈希表**.hash**。</p></li><li><p><strong>动态链接定位表</strong></p><p>动态链接的文件中，也有类似于重定位表，叫.rel.dyn和.rel.plt。**.rel.dyn<strong>实际上是对数据引用的修正，它所修正的位置是.got以及数据段，而</strong>.rel.plt**是对函数引用的修正，所修正的位置位于.got.plt。</p><p>使用<strong>readelf -r</strong>指令来查看一个动态链接文件的重定位表：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -r Lib.so</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>动态链接时进程堆栈初始化信息</strong></p><p>进程初始化时，堆栈中不仅有进程执行环境和命令行参数等信息，还保存了动态链接器所需的一些辅助信息数组：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct {</span><br><span class="line">    uint32_t a_type;</span><br><span class="line">    union {</span><br><span class="line">        uint32_t a_val;</span><br><span class="line">    } a_un;</span><br><span class="line">} Elf32_auxv_t;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="动态链接步骤和实现"><a href="#动态链接步骤和实现" class="headerlink" title="动态链接步骤和实现"></a>动态链接步骤和实现</h2><ul><li>动态链接的过程可分为3步：<ul><li>启动动态链接器本身</li><li>装载所有需要的共享对象</li><li>重定位和初始化</li></ul></li></ul><p>动态链接器就是一个库，其他库可以有动态链接器加载，那动态链接器自身呢？</p><p>动态链接器本身得满足两个条件：</p><ul><li><p>本身不可以依赖其他任何共享对象</p></li><li><p>本身所需要的全局和静态变量的重定位工作由它本身完成（自举）</p></li><li><p>自举流程：</p><ul><li>自举代码首先找到它的GOT</li><li>根据“.dynamic”段获得动态链接器本身的重定位表和符号表，从而得到动态链接器本身的重定位入口，将他们全部重定位</li></ul></li></ul><h3 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h3><p>完成基本自举后，动态链接器会将可执行文件和链接器本身的符号表都合并到一个符号表当中，称为<strong>全局符号表</strong>。</p><p>共享对象里面的全局符号被另一个共享对象的同名全局符号覆盖的现象叫做<strong>全局符号介入</strong>，一般是第一个被装载的符号优先，后续同名符号忽略，这种优先方式称为装载序列。</p><h3 id="重定位和初始化"><a href="#重定位和初始化" class="headerlink" title="重定位和初始化"></a>重定位和初始化</h3><p>链接器重新遍历可执行文件和每个共享对象的重定位表，将他们的GOT/PLT中的每个需要重定位的位置进行修正；重定位完成之后，如果某个共享对象有**.init**段，那么动态链接器会执行.init段中的代码，用以实现共享对象特有的初始化过程。</p><h3 id="Linux动态链接器实现"><a href="#Linux动态链接器实现" class="headerlink" title="Linux动态链接器实现"></a><strong>Linux动态链接器实现</strong></h3><p>动态链接器和一般的共享库不太一样，是可以直接执行的。Linux的共享库和可执行文件基本相同可能是ELF Header中某些标志不同而导致无法直接运行。</p><ul><li>对于静态链接的可执行文件来说，程序的入口就是ELF文件头里面的e_entry指定入口</li><li>对于动态链接的可执行文件来说，内核会分析它的动态链接器地址（在“.interp”段），将动态链接器映射至进程地址空间，然后把控制权交给动态链接器</li></ul><p><strong>动态链接器本身是静态链接，因为他不能依赖于其他共享对象；</strong></p><p><strong>动态链接器本身是PIC的；</strong></p><p><strong>动态链接器本身的装载地址和一般的共享对象没有区别，为0x00000000，内核在装载它时会选择一个合适的装载地址。</strong></p><h3 id="显式运行时链接"><a href="#显式运行时链接" class="headerlink" title="显式运行时链接"></a>显式运行时链接</h3><p>显式运行时链接：即在运行时通过代码控制动态库的加载与卸载而不是链接时添加。</p><ul><li><code>dlopen()</code>：打开动态库；</li><li><code>dlsym()</code>：找到符号；</li><li><code>dlerror()</code>：错误处理函数；</li><li><code>dlclose()</code>：卸载已经加载的模块。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》7-代理模式</title>
      <link href="/2023/12/06/da-hua-she-ji-mo-shi-7-dai-li-mo-shi/"/>
      <url>/2023/12/06/da-hua-she-ji-mo-shi-7-dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/PdxcIc3LcBdP.png?o=1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p><strong>Subject类</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>RealSubject类</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"真实的请求"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>Proxy类</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(realSubject == <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">realSubject = <span class="keyword">new</span> <span class="built_in">realSubject</span>();</span><br><span class="line">}</span><br><span class="line">realSubject.<span class="built_in">Request</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RealSubject &amp;realSubject;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>客户端</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Proxy proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br><span class="line">    proxy.<span class="built_in">Request</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul><li>远程代理<br>为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实</li><li>虚拟代理<br>根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象</li><li>安全代理<br>用来控制真实对象访问时的权限、</li><li>智能指引<br>指当调用真实的对象时，代理处理另外一些事</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》3、4、5-单一职责原则、开放封闭原则、依赖倒转原则</title>
      <link href="/2023/12/05/da-hua-she-ji-mo-shi-3-4-5-dan-yi-zhi-ze-yuan-ze-kai-fang-feng-bi-yuan-ze-yi-lai-dao-zhuan-yuan-ze/"/>
      <url>/2023/12/05/da-hua-she-ji-mo-shi-3-4-5-dan-yi-zhi-ze-yuan-ze-kai-fang-feng-bi-yuan-ze-yi-lai-dao-zhuan-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li>就一个类而言，应该仅有一个引起它变化的原因。</li><li>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。</li><li>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出类来。</li><li>如果能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。</li></ul><h3 id="单一职责应用——俄罗斯方块游戏设计"><a href="#单一职责应用——俄罗斯方块游戏设计" class="headerlink" title="单一职责应用——俄罗斯方块游戏设计"></a>单一职责应用——俄罗斯方块游戏设计</h3><ul><li><p>程序考虑分成两个类：<strong>游戏逻辑类、窗体类</strong></p></li><li><p>方块的可移动游戏区域设计为二维数组，方块的移动其实就是数组的下标变化</p></li><li><p>每个数组的值就是是否存在方块的标志，存在为1，不存在为0</p></li><li><p>是否撞墙：判断arrySquare[x,y]中的x-1是否小于0或x+1是否大于上界</p></li><li><p>左右两侧是否有堆积的方块：判断arrySquare[x-1,y]或arrySquare[x+1,y]是否等于1</p></li><li><p>是否上下达到堆积：判断arrySquare[x,y+1]是否为1，是则将arrySquare[x,y]改为1</p></li><li><p>消层：对于arrySquare[x,y]遍历x从0到上界，判断是否都为1，是则此行全部清0，并将上方数组值遍历下移一位。</p></li></ul><h2 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><ul><li>是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改</li><li>对于扩展时开放的，对于更改是封闭的</li><li>无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于设计的模块应该对哪种变化封闭做出选择。必须先猜测出最有可能发生变化种类，然后构造抽象来隔离那些变化</li><li>等到变化发生时立即采取行动在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化</li><li>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码</li><li>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难</li><li>不要对于应用程序中的每个部分都刻意地进行抽象，拒绝不成熟的抽象和抽象本身一样重要</li></ul><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>A. 高层模块不应该依赖底层模块。两个都应该依赖抽象。B.抽象不应该依赖细节，细节应该依赖抽象</p></li><li><p>针对接口编程，不要对实现编程</p><p><img src="https://gcdnb.pbrd.co/images/vfdXkM2gNM6F.png?o=1"></p></li></ul><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><ul><li>子类型必须能够替换掉它们的父类型</li><li>在软件里面，把父类都替换成它的子类，出现的行为没有变化</li><li>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为</li><li>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》6-装饰模式</title>
      <link href="/2023/12/05/da-hua-she-ji-mo-shi-6-zhuang-shi-mo-shi/"/>
      <url>/2023/12/05/da-hua-she-ji-mo-shi-6-zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活</li><li>需要人为的把所需的功能按正确的顺序串联起来进行控制</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://gcdnb.pbrd.co/images/jiuj0tp89xn7.png?o=1"></p><ul><li>Component 是定义一个<strong>接口对象</strong>，可以给这些对象动态地添加职责</li><li>ConcreteComponent 是定义了一个<strong>具体对象</strong>，也可以给这个对象添加一些职责</li><li>Decorator， 装饰<strong>抽象类</strong>，继承了Component 从外类来扩展Component 类的功能，但对于Component 来说，是无需知道Decorator存在的</li><li>ConcreteDecorator 是<strong>具体的装饰对象</strong>，起到给Component 添加职责的功能</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Component类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteComponent类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> : <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"具体对象的操作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorator类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Component</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetComponent</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(component != <span class="literal">nullptr</span>)</span><br><span class="line">{</span><br><span class="line">component.<span class="built_in">Operation</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Component &amp;component;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecoratorA类</span></span><br><span class="line">ConcreteDecoratorA : <span class="keyword">public</span> Decorator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Decorator::<span class="built_in">Operation</span>();</span><br><span class="line">addState = <span class="string">"New State"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"具体装饰对象A的操作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string addState;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecoratorB类</span></span><br><span class="line">ConcreteDecoratorB : <span class="keyword">public</span> Decorator</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Decorator::<span class="built_in">Operation</span>();</span><br><span class="line"><span class="built_in">AddedBehavior</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">"具体装饰对象B的操作"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddedBehavior</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ConcreteComponent c = <span class="keyword">new</span> <span class="built_in">ConcreteComponent</span>();</span><br><span class="line">ConcreteDecoratorA d1 = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorA</span>();</span><br><span class="line">ConcreteDecoratorB d2 = <span class="keyword">new</span> <span class="built_in">ConcreteDecoratorB</span>();</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">SetComponent</span>(c);</span><br><span class="line">d2.<span class="built_in">SetComponent</span>(d1);</span><br><span class="line">d2.<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>装饰模式是利用<strong>SetComponent</strong>来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>装饰模式是为已有功能<strong>动态地添加更多功能</strong>的一种方式</li><li>装饰模式把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为是，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了</li><li>装饰模式把类中的装饰功能从类中搬移去除，这样可以简化原有的类</li><li>有效地把类的<strong>核心职责和装饰功能</strong>区分开了，而且可以去除相关类中重复的装饰逻辑</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第六章读书笔记</title>
      <link href="/2023/12/04/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-liu-zhang-du-shu-bi-ji/"/>
      <url>/2023/12/04/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-liu-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="进程虚拟地址空间"><a href="#进程虚拟地址空间" class="headerlink" title="进程虚拟地址空间"></a>进程虚拟地址空间</h2><ol><li>程序和进程的区别，程序就是菜谱，是一个静态概念， 进程就是菜，是一个动态概念。</li><li>程序的寻址空间由CPU的位数决定，所以32位下的程序寻址空间是2^32bit即4GB， 64位下是17179869184 GB，32位下C语言指针的长度是4字节，64位系统下长度是8字节。</li><li>对于一个32位的程序，寻址空间虽然是4GB，但是程序并不能全部使用，例如在Linux下，1GB是留给操作系统的，剩下的3GB给进程，且这3GB内存程序也不能完全使用，还有一部分给其他用途； 在Windows上，默认情况下2GB留给系统，2GB留给进程， 但是可以通过修改winows根目录下Boot.ini文件调整内存分配和linux下一样。</li><li>1995年Pentium Pro CPU使用PAE(Physical Address Extension),将地址线扩充到了36位，所以理论上计算机<strong>可以寻址的物理空间变成了64G</strong>， 但是进程的寻址空间仍然是4G（32位系统下指针是4个字节）。</li></ol><h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>人们希望在不添加内存的情况下，让更多的程序运行起来，所以采用了一种<strong>动态装载</strong>的方法：将程序常用的部分驻留在内容中，而将一些不太常用的数据存放在磁盘中。</p><p><strong>覆盖装入</strong>和<strong>页映射</strong>是两种很经典的动态装载方法：</p><ul><li>覆盖装入：对于不互相调用的模块，可以放在同一虚拟地址。这种方式几乎被淘汰。因为，满足条件的程序少。在多个模块的情况下，程序员需要手工将模块按照他们之间的调用依赖关系组织成树状结构。这个树状结构中的从任何一个模块到树根都叫调用路径，模块被调用时，整个调用路径上的所有模块都必须在内存中，而且禁止跨树间调用。</li><li>页映射：就是常说的页表，LRU、LFU、FIFO调度。</li></ul><h2 id="从操作系统的角度看可执行文件的装载"><a href="#从操作系统的角度看可执行文件的装载" class="headerlink" title="从操作系统的角度看可执行文件的装载"></a>从操作系统的角度看可执行文件的装载</h2><h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><p>进程的建立，创建一个进程，然后装载相应的可执行文件并且执行，在有虚拟存储的情况下，主要做的事情如下：</p><ul><li><p><strong>创建一个独立的虚拟地址空间</strong></p><p>一个<strong>虚拟地址空间</strong>是由一组页映射函数将虚拟空间的各个页映射到相应的<strong>物理空间</strong>，创建虚拟地址空间实际上只是分配了一个页目录就可以了；</p></li><li><p><strong>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</strong></p><p>操作系统捕获到缺页错误的时候，他应该知道程序当前所需要的页在可执行文件中的哪一个位置。这就是虚拟空间与可执行文件之间的映射关系。这一步就是整个装载过程最重要的一步。这种映射关系只是保存在操作系统中的一个数据结构，linux中将进程虚拟空间中的一个段叫做虚拟内存区域VMA，在windows中叫做虚拟段。</p></li><li><p><strong>将CPU的指令寄存器设置成可执行文件的入口地址，启动执行。</strong></p><p>操作系统通过设置CPU的指令寄存器将控制权交给进程。由此进程开始执行。</p></li></ul><h3 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h3><p>当CPU开始打算执行一个地址的指令时，发现对应的页面是一个空页面，就会认为这是一个页错误。CPU会将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况：</p><p>操作系统会<strong>查询数据结构</strong>，然后知道空页面所在的<strong>VMA</strong>，计算出相应的页面在可执行文件中的<strong>偏移</strong>，然后在物理内存中<strong>分配一个物理页面</strong>，将进程中的该虚拟页与分配的物理页之间建立<strong>映射关系</strong>，然后把控制权交给进程，进程从刚才页错误的位置重新开始执行。</p><h2 id="进程虚拟空间分布"><a href="#进程虚拟空间分布" class="headerlink" title="进程虚拟空间分布"></a>进程虚拟空间分布</h2><h3 id="ELF文件链接视图和执行视图"><a href="#ELF文件链接视图和执行视图" class="headerlink" title="ELF文件链接视图和执行视图"></a>ELF文件链接视图和执行视图</h3><p>因为ELF文件被映射的时候，是以系统页长度为单位，每一个段在映射时的长度都是系统也长度的整数倍。当可执行文件中的段数量很多时候，就会产生内存空间浪费的问题。</p><p>段的权限往往只有几种组合：</p><ul><li>以代码段为代表，可读可执行</li><li>以数据段和BSS段为代表，可读可写</li><li>为只读数据段为代表，只读</li></ul><p><strong>对于相同权限的段，把它们合并到一起当做一个段进行映射。</strong></p><p>ELF可执行文件引入Segment的概念。一个segment（执行视图）包含了一个或者多个属性相似的section（链接视图）。</p><p>在装载的时候按照segment整体一起映射，就是说映射以后进程虚存空间只有一个相对应的VMA，这样就可以棉线的减少页面内部碎片，节省了内存空间。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>进程在执行时用到的堆和栈也是以VMA的形式存在的。很多情况下，一个进程的栈和堆都有一个对应的VMA。</p><p><img src="https://img-blog.csdnimg.cn/20190306150224296.png"></p><p>有5个VMA，前两个映射到可执行文件中的两个segment。另外三个段主设备号和次设备号都是0，表示他们没有映射到文件中，这种VMA叫做<strong>匿名虚拟内存区域</strong>。有两个区域是heap和stack，这两个VMA在所有的进程中几乎都存在。还有一个VMA叫vdso，地址位于内核空间，是一个内核模块，进程可以通过访问这个VMA跟内核进行通信。</p><p>综上，操作系统通过给进程空间或分出了一个个的VMA来管理进程空间的虚拟空间，基本原则就是将相同权限属性的、有相同映象文件的映射成一个VMA，一个进程分为如下几种VMA区域：</p><ul><li><p>代码VMA，权限只读、可执行，有映象文件</p></li><li><p>数据VMA，权限可读写、可执行，有映象文件</p></li><li><p>堆VMA，权限可读写，可执行，无映象文件，匿名，向上扩展</p></li><li><p>栈VMA，权限可读写，不可执行，无映象文件，匿名，向下扩展。</p><p>linux下虚拟地址空间分配为进程本身使用的是3G，windows上只能1.5G左右。</p></li></ul><h3 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h3><p>通常每个段的长度都不是页长度的整数倍，一种最简单的映射办法就是<strong>每个段分开映射</strong>，对于<strong>长度不足一个页的部分则占一个页</strong>。但是这样可能会导致非常多的内部碎片，浪费磁盘空间。</p><p><img src="https://img-blog.csdnimg.cn/20190306155842149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vdXNlMTU5ODE4OQ==,size_16,color_FFFFFF,t_70"></p><p>Unix采用了取巧的办法，即让那些<strong>各个段接壤的部分共享一个物理页面，然后该物理页面分别映射两次。</strong></p><p><img src="https://img-blog.csdnimg.cn/20190306155851416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vdXNlMTU5ODE4OQ==,size_16,color_FFFFFF,t_70"></p><p>这样做好处是进程中的某段区域就是整个ELF文件的映象，对于一些访问ELF文件头的操作，可以直接通过读写内存地址空间进行。</p><p>根据上面的段对齐方案，有一个规律，在ELF文件中，对于任何一个可装载的segment，它的<strong>p_vaddr除以对齐属性的余数等于p_offset除以对齐属性的余数</strong>。</p><h3 id="进程栈初始化"><a href="#进程栈初始化" class="headerlink" title="进程栈初始化"></a>进程栈初始化</h3><p>进程刚刚开始的时候，需要知道一些进程运行的环境，最基本的就是系统环境变量和进程的运行参数。最常见的一个做法就是操作系统在进程启动前<strong>将这些信息保存到进程的虚拟空间的栈中。</strong></p><p><img src="https://img-blog.csdnimg.cn/2019030616052654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vdXNlMTU5ODE4OQ==,size_16,color_FFFFFF,t_70"></p><p>栈顶寄存器<strong>esp指向的位置是初始化以后堆栈的顶部</strong>。最前面的四个字节是<strong>命令行参数的数量</strong>。紧接着就是分别指向这两个参数的字符串指针，后面跟一个0。接着是指向环境变量字符串的指针，后面跟一个0结尾。<br>进程在启动以后，程序的库部分会<strong>把堆栈里的初始化信息中的参数信息传递给main函数</strong>，也就是main的argc argv参数。</p><h2 id="Linux内核装载ELF过程简介"><a href="#Linux内核装载ELF过程简介" class="headerlink" title="Linux内核装载ELF过程简介"></a>Linux内核装载ELF过程简介</h2><ol><li>在用户层面，bash进程会调用<strong>fork</strong>系统调用创建一个新的进程，然后新的进程调用<strong>execve</strong>系统调用执行指定的ELF文件</li><li>execve系统调用的入口函数是<strong>sys_execve</strong>，sys_execve进行一些参数的检查和复制之后，调用<strong>do_execve</strong></li><li>do_execve首先查抄被执行的文件，如果找到文件，则<strong>读取文件的前128个字节</strong>。读128字节是为了文件的格式、然后调用<strong>search_binary_handler</strong>通过判断文件头部的<strong>魔数</strong>确定文件的格式，并且调用相应的装载处理过程。</li><li>ELF客户自行文件的装载处理过程叫做<strong>load_elf_binary</strong>。load_elf_binary主要的步骤如下：<ul><li>检查ELF可执行文件格式的有效性，比如魔数、程序头表中的段的数量</li><li>寻找动态链接的.interp段，设置动态链接器路径</li><li>根据ELF可执行文件的程序头表的描述，对ELF文件进行映射</li><li>初始化ELF进程环境，比如进程启动时EDX寄存器的地址应该是什么</li><li>将系统调用的返回地址修改成ELF可执行文件的入口点</li></ul></li><li>当sys_execve从内核态返回用户态时，EIP寄存器直接跳转到了ELF程序的入口地址，于是程序开始执行，ELF可执行文件装载完毕。</li></ol><h2 id="windows-PE的装载"><a href="#windows-PE的装载" class="headerlink" title="windows PE的装载"></a>windows PE的装载</h2><p>对于PE文件，链接器在生产可执行文件的时候，<strong>往往将所有的段尽可能的合并</strong>，所以一般只有<strong>代码段、数据段、只读数据段和BSS</strong>等为数不多的段。</p><p>对于PE装载，引入了一个<strong>RVA</strong>（relative virtual address）的概念，表示一个相对虚拟地址，是相对于PE文件的装载基地址的一个偏移地址。每个PE文件在装载时都会有一个装载目标地址，这个地址就是所谓的基地址。</p><p>装载一个PE可执行文件的过程如下：</p><ul><li>先读取文件的第一个页，在这个页中，包含了DOS头、PE文件头和段表</li><li>检查进程地址空间中，目标地址是否可用，如果不可用，则另选一个装载地址</li><li>使用段表中的提供的信息，将PE文件中所有的段一一映射到地址空间中的相应位置</li><li>如果装载地址不是目的地址，则进行rebasing</li><li>装载所有PE文件所需要的dll文件</li><li>对PE文件中的所有导入符号进行解析</li><li>根据PE头中指定的参数，建立初始化堆和栈</li><li>建立主线程并且启动进程</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》2-策略模式</title>
      <link href="/2023/12/01/da-hua-she-ji-mo-shi-2-ce-lue-mo-shi/"/>
      <url>/2023/12/01/da-hua-she-ji-mo-shi-2-ce-lue-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h3><p>定了了算法家族，分别封装起来，让它们之间可以互相替换，此策略让算法的变化，不会影响到使用算法的客户</p><p><img src="https://gcdnb.pbrd.co/images/EAoxBBgLlnpq.png?o=1" alt="策略模式结构图"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strategy类：定义所有支持的算法的公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteStrategyA/B/C类：封装了具体的算法或行为，继承于Strategy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// 算法A的实现</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context类：包含一个Strategy类，需要用一个ConcreteStrategy来构造，根据具体对象调用算法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Context</span>(Strategy strategy)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ContextInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        strategy.<span class="built_in">AlgorithmInterface</span>();</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy Strategy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>弊端：需要在客户端判断用哪一个方法。因此，可以将判断的过程从客户端程序转移走，这时候就需要将策略模式的<strong>Context</strong>和<strong>简单工厂</strong>相结合。</p><h3 id="简单工厂与策略相结合"><a href="#简单工厂与策略相结合" class="headerlink" title="简单工厂与策略相结合"></a>简单工厂与策略相结合</h3><figure class="highlight c#"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CashContext</span>{</span><br><span class="line"><span class="keyword">private</span> CashSuper cs;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造方法，传入具体的收费策略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CashContext</span>(<span class="params"><span class="built_in">int</span> cashType</span>)</span>{</span><br><span class="line"><span class="keyword">switch</span>(cashType){</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">this</span>.cs = <span class="keyword">new</span> CashNormal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">this</span>.cs = <span class="keyword">new</span> CashRebate(<span class="number">0.8</span>d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">this</span>.cs = <span class="keyword">new</span> CashRebate(<span class="number">0.7</span>d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">this</span>.cs = <span class="keyword">new</span> CashReturn(<span class="number">300</span>d,<span class="number">100</span>d);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getResult</span>(<span class="params"><span class="built_in">double</span> price,<span class="built_in">int</span> num</span>)</span>{</span><br><span class="line"><span class="comment">//根据收费策略的不同，获取计算结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.cs.accpetCash(price,num)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="comment">//根据用户输入，将对应的策略对象作为参数传入CashContext对象中</span></span><br><span class="line">CashContext cc = <span class="keyword">new</span> CashContext(discount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Context的getResult方法的调用，获取收取费用的结果，从而让具体算法和客户进行隔离</span></span><br><span class="line">totalPrices = cc.getResult(price,num);</span><br><span class="line">total = total + totalPrices;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>简单工厂模式需要让客户端认识两个类，<strong>CashSuper</strong> 和<strong>CashFactory</strong>，而策略模式与简单工厂结合的用法，客户端就只需要认识一个类<strong>CashContext</strong>就可以了，耦合更加降低。</p><h3 id="策略模式解析"><a href="#策略模式解析" class="headerlink" title="策略模式解析"></a>策略模式解析</h3><ul><li>策略模式是一种定义一系列算法的方法，完成的都是相同的工作，只是实现不同，可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合</li><li>如上图的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</li><li>简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</li><li>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句</li><li>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在<strong>不同时间应用不同的业务规则</strong>，就可以考虑使用策略模式处理这种变化的可能性</li><li>在基本的策略模式中，选择所用具体实现的职责有客户端对象承担，并转给策略模式的Context对象；策略模式和简单工厂模式结合后，选择具体实现的职责也由Context承担，简化了客户端职责</li><li>任何需求的变更都是需要成本的</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第五章读书笔记</title>
      <link href="/2023/12/01/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-wu-zhang-du-shu-bi-ji/"/>
      <url>/2023/12/01/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-wu-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows的二进制文件格式PE-COFF"><a href="#Windows的二进制文件格式PE-COFF" class="headerlink" title="Windows的二进制文件格式PE/COFF"></a>Windows的二进制文件格式PE/COFF</h2><p>在Windows平台下，可执行性文件采用<strong>PE文件格式</strong>，而Visual C++编译器产生的目标文件仍然使用<strong>COFF格式</strong>。64位的Windows中对PE文件格式做了一点小小的修改，叫做<strong>PE32+格式</strong>，只是将32位的字段换成了64位而已。</p><p>与ELF相同PE/COFF也是采用基于段的方式。GCC中使用__attribute__((section(“name”)))指定段，visual C++中也可以使用#pragma编译器指示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">"FOO"</span>)</span></span><br><span class="line"><span class="type">int</span> global = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">".data"</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>使用pragma将当前段切换至“FOO”段，存放全局变量global后，切换回“.data”段。</p><h2 id="COFF"><a href="#COFF" class="headerlink" title="COFF"></a>COFF</h2><p>通过命令行<strong>cl</strong>使用VC++编译器：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /c /Za simplesection.c</span><br></pre></td></tr></tbody></table></figure><ul><li>/c 表示只编译不链接，形成.obj文件，而不生成.exe文件</li><li>/Za 表示禁用Visual C++的一些专用扩展，是的程序跟标准的C/C++兼容</li></ul><p>使用<strong>dumpbin</strong>来查看obj文件的结构：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /ALL simplesection.obj &gt; simplesection.txt</span><br><span class="line">dumpbin simplesection.obj /SUMMAY</span><br></pre></td></tr></tbody></table></figure><ul><li>/ALL 表示打印输出目标文件的所有相关信息，包括文件头、每个段的属性、段的原始数据和符号表</li><li>/SUMMARY 表示查看基本信息，只输出所有段的段名和长度。</li></ul><h3 id="COFF文件结构"><a href="#COFF文件结构" class="headerlink" title="COFF文件结构"></a>COFF文件结构</h3><p>和ELF文件类似，COFF文件也是有文件头和后面若干段组成，再加上文件末尾的符号表、调试信息的内容。COFF文件头包括了两部分，<strong>一个是描述文件总体结构和属性的映像头，一个是描述该文件中包含的段属性的段表。</strong>文件头后面紧跟着就是文件的各个段。</p><p><img src="https://gcdnb.pbrd.co/images/0stwLoMVaQuM.png?o=1"></p><p><strong>映像头结构体</strong></p><p>windows中定义了一个WinNT.h文件的结构<strong>IMAGE_FILE_HEADER</strong></p><p><img src="https://gcdnb.pbrd.co/images/tQYjThW8GRpb.png?o=1"></p><p><strong>段表结构体数组</strong></p><p>映像头后面紧跟着就是COFF文件的段表，是一个<strong>IMAGE_SECTION_HEADER</strong>的结构数组</p><p><img src="https://gcdnb.pbrd.co/images/klKWgtilmqcC.png?o=1"></p><p>段表描述了每一个段的属性等信息。每一个段所拥有的属性包括<strong>段名、物理地址、虚拟地址、原始数据大小、段在文件中的位置、该段的重定位表在文件中的位置、该段的行号表在文件中的位置、标志位</strong>等。</p><h3 id="链接指示信息"><a href="#链接指示信息" class="headerlink" title="链接指示信息"></a>链接指示信息</h3><p><strong>.drectve段</strong>，是directive的缩写，内容是编译器传递给链接器的指令，即编译器希望告诉链接器应该怎样链接这个目标文件。<br>在RAW DATA #1部分，/default:”libcmt”链接指令，这就是cl希望传递给链接器的参数。</p><h2 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h2><p>调试信息位于**.debug段**。</p><ul><li>.debug$S表示包含的是符号(Symbol)相关的调试信息</li><li>.debug$P表示包含的是预编译头文件（Precompiled Header file）相关的调试信息段</li><li>.debug$T表示包含类型（Type）相关的调试信息</li></ul><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p><img src="https://gcdnb.pbrd.co/images/6FJ9pWmKPv5q.png?o=1"></p><ul><li>第一列：符号编号，符号在符号表中的下标</li><li>第二列：符号的大小，符号所表示对象所占空间</li><li>第三列：符号所在的位置，ABS表示符号是个绝对值，即一个常量，它不存在与任何段中；<br>SECT1表示符号锁表是的对象定义在COFF文件的第一个段中；UNDEF表示符号是未定义的，表示这个符号被定义在其他目标文件中</li><li>第四列：符号类型，COFF文件类型只区分了两种，一个是notype，一个是函数类型为notype()</li><li>第五列是符号的可见范围，static表示符号是局部变量，只有目标文件内部是可见的；external表示符号是全局变量，可以被其他目标哦文件引用。</li><li>第六列是符号名</li></ul><h2 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h2><p>PE 是基于COFF的扩展，比COFF多了好几个结构。最主要的而变化有两个：</p><ul><li>第一个是文件最开始的不是COFF头，而是DOS MZ可执行文件格式的文件头和桩代码</li><li>第二个变化是原来的COFF文件头中的IMAGE_FILE_HEADER部分扩展称为了PE文件头结构IMAGE_NT_HEADERS， 这个结构包含了原来的image hander，以及新增的PE扩展头部结构</li></ul><p><img src="https://gcdnb.pbrd.co/images/MPWlcl3Q44fs.png?o=1" alt="PE文件格式"></p><p>PE的设计之初必须兼容dos系统，所以PE文件中有<strong>image dos header</strong>和<strong>dos stub</strong>两个结构就是为了兼容而设计的。</p><p>DOS下的可执行文件windows下的可执行文件扩展名一样，都是.exe，但是DOS下的可执行文件格式是MZ格式。<br>当PE可执行映象在DOS下被加载的时候，DOS系统检测该文件，发现最开始两个字节是MZ，就认为是一个MZ可执行文件，然后DOS系统就将PE文件当做正常的MZ文件开始执行。DOS系统会读取<strong>e_cs</strong>和<strong>e_ip</strong>两个成员的值，以跳转到程序入口地址。但是e_cs和e_ip这两个成员并没有指向程序的真正入口地址，而是指向文件中的DOS stub。</p><p>dos stub是一段可以在dos下运行的小段程序，这段程序的唯一作用就是向终端输出一行“This program cannot be run in DOS”然后退出程序，表示该程序不能再DOS下运行。</p><p><strong>IMAGE_NT_HEADER</strong>是PE真正的文件头，它包含了一个标记和两个结构体（映像头、PE扩展头部结构）。</p><p><img src="https://gcdnb.pbrd.co/images/nMbpdQjZN9uJ.png?o=1"></p><p>IMAGE_OPTIONAL_HEADER，尽管是可选的，但是对于PE可执行文件来说（包括DLL）是必须要的。有些部分跟PE文件的装载与运行有关。</p><p><img src="https://img-blog.csdnimg.cn/20190305151954682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vdXNlMTU5ODE4OQ==,size_16,color_FFFFFF,t_70"></p><h3 id="PE数据目录"><a href="#PE数据目录" class="headerlink" title="PE数据目录"></a>PE数据目录</h3><p>当windows装载PE可执行文件时，往往可以很快的找到一些装载所需要的数据结构，比如导入表、导出表、资源、重定位表等。这些常用的数据的位置和长度都被保存在了数据目录结构中。即<strong>IMAGE_OPTIONAL_HEADER</strong>中的<strong>DataDirectory</strong>成员。</p><p><img src="https://img-blog.csdnimg.cn/20190305152039425.png"></p><p>DataDirectory是一个IMAGE_DATA_DIRECTORY类型数组，每一个元素定义了两个成员，即虚拟地址和长度。<br>DataDirectory中每一个元素都对应一个包含一定含义的表。这些表可以是导出表、导入表、异常表、资源表、重定位表、调试信息表、线程私有存储等地址和长度。这些表多数与装载和DLL动态链接有关。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》1-简单工厂模式与UML图</title>
      <link href="/2023/11/30/da-hua-she-ji-mo-shi-1-jian-dan-gong-han-mo-shi-yu-uml-tu/"/>
      <url>/2023/11/30/da-hua-she-ji-mo-shi-1-jian-dan-gong-han-mo-shi-yu-uml-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="面向对象的好处"><a href="#面向对象的好处" class="headerlink" title="面向对象的好处"></a>面向对象的好处</h3><ul><li>考虑通过封装、继承、多态把程序的耦合度降低，使用设计模式使得程序更加的灵活，容易修改，并且易于复用。</li></ul><h3 id="复制-Vs-复用"><a href="#复制-Vs-复用" class="headerlink" title="复制 Vs 复用"></a>复制 Vs 复用</h3><ul><li>有人说初级程序员的工作就是 Ctrl+C 和 Ctrl+V，这其实是非常不好的编码习惯，因为当你的代码中重复的代码多到一定程度，维护的时候，可能就是一场灾难。越大的系统，这种方式带来的问题越严重，编程有一原则，就是用尽可能的办法去避免重复。</li></ul><h3 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h3><ul><li>就是让<strong>业务逻辑与界面逻辑</strong>分开，让他们之间的耦合度下降。只有分离开，才可以达到容易维护或扩展。</li></ul><h3 id="紧耦合-Vs-松耦合"><a href="#紧耦合-Vs-松耦合" class="headerlink" title="紧耦合 Vs 松耦合"></a>紧耦合 Vs 松耦合</h3><p>紧耦合就是模块或者系统之间关系太紧密，存在相互调用。紧耦合系统的缺点在于<strong>更新一个模块的结果导致其它模块的结果变化</strong>，难以重用特定的关联模块。</p><h3 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li><p>概述</p><p>到底要实例化谁，将来会不会增加实例化对象，应该考虑<strong>用一个单独的类来做这个创造实例的过程</strong>。这就是工厂，定义的这个工厂类负责创建一些类的实例。</p></li><li><p>优点</p><p>客户端不需要再负责对象的创建，从而明确了各个类的职责。</p></li><li><p>缺点</p><p>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护。</p></li></ul><p><img src="https://gcdnb.pbrd.co/images/Sh0iGkxAcLlm.png?o=1" alt="简单工厂模式下的计算器"></p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://gcdnb.pbrd.co/images/dAEH0JX2rFQt.png?o=1" alt="UML类图样例"></p><ul><li><p><strong>矩形框</strong><br>表示一个类；<br>分三层：第一层显示类的<strong>名称</strong>，<strong>抽象类用斜体表示</strong>；第二层类的<strong>特性</strong>：字段、属性；第三层类的<strong>操作</strong>：方法、行为<br>前面的符号：**+** 表示public，**-** 表示 privae，**#** 表示 protected</p><p><img src="https://gcdnb.pbrd.co/images/EoO5OGoVSsMm.png?o=1"></p></li><li><p><strong>接口图</strong></p><ul><li><p>矩形表示法<br>顶端有 &lt;&lt;interface&gt;&gt;<br>第一行：接口名称<br>第二行：接口方法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IFly</span><br><span class="line">{</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fly</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/IQNpwUZhNlCb.png?o=1"></p></li><li><p>棒棒糖表示法</p><p>圆圈旁为接口名字，接口方法在类中实现</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface ILanguage</span><br><span class="line">{</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/VkOE0oiiD96M.png?o=1"></p></li></ul></li><li><p><strong>继承关系</strong><br>用<strong>空心三角形+实线</strong>表示</p><p><img src="https://gcdnb.pbrd.co/images/9B5Mdzi9HGhr.png?o=1"></p></li><li><p><strong>实现接口</strong><br>用空心<strong>三角形+虚线</strong>表示</p><p><img src="https://gcdnb.pbrd.co/images/ktwOJ37HPwqi.png?o=1"></p></li><li><p><strong>关联关系</strong><br>当一个类“知道”另一个类时，用<strong>实线箭头</strong>表示</p><p><img src="https://gcdnb.pbrd.co/images/pe62vqYYRJnr.png?o=1"></p></li><li><p><strong>聚合关系</strong><br>表示一个弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分<br>用<strong>空心的菱形+实线箭头</strong>表示</p><p><img src="https://gcdnb.pbrd.co/images/QY9NNjyGgqsp.png?o=1"></p></li><li><p><strong>合成(组合)关系</strong><br>是一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样<br>用实心的<strong>菱形+实线箭头</strong>表示</p><ul><li>连线两端分别有数字1和2，称为<strong>基数</strong>，即这一端的类可以有几个实例，无数个实例用“n”表示</li><li>关联关系、聚合关系也有基数</li></ul><p><img src="https://gcdnb.pbrd.co/images/IVmGEDpwx2X6.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span> Wing wing;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">wing = <span class="keyword">new</span> <span class="built_in">Wing</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>依赖关系</strong><br>用<strong>虚线箭头</strong>表示</p><p><img src="https://gcdnb.pbrd.co/images/VU2QxtJDZ2Ei.png?o=1"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Metabolism</span><span class="params">(Oxygen oxgen, Water water)</span></span></span><br><span class="line"><span class="function"></span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《大话设计模式》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 菜鸟教程</title>
      <link href="/2023/11/29/css-cai-niao-jiao-cheng/"/>
      <url>/2023/11/29/css-cai-niao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-简介"><a href="#CSS-简介" class="headerlink" title="CSS 简介"></a>CSS 简介</h2><h3 id="什么是-CSS"><a href="#什么是-CSS" class="headerlink" title="什么是 CSS"></a>什么是 CSS</h3><ul><li>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</li><li>样式定义<strong>如何显示</strong> HTML 元素</li><li>样式通常存储在<strong>样式表</strong>中</li><li>把样式添加到 HTML 4.0 中，是为了<strong>解决内容与表现分离的问题</strong></li><li><strong>外部样式表</strong>可以极大提高工作效率</li><li>外部样式表通常存储在 <strong>CSS 文件</strong>中</li><li>多个样式定义可<strong>层叠</strong>为一个</li></ul><h2 id="CSS-语法"><a href="#CSS-语法" class="headerlink" title="CSS 语法"></a>CSS 语法</h2><h3 id="CSS-规则"><a href="#CSS-规则" class="headerlink" title="CSS 规则"></a>CSS 规则</h3><p>CSS 规则由两个主要的部分构成：<strong>选择器，以及一条或多条声明:</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2013/07/632877C9-2462-41D6-BD0E-F7317E4C42AC.jpg"></p><p>选择器通常是需要改变样式的 HTML 元素。</p><p>每条声明由一个属性和一个值组成。</p><p>属性（property）是希望设置的样式属性（style attribute），每个属性有一个值，属性和值被冒号分开。</p><p>CSS声明总是以分号 <strong>;</strong> 结束，声明总以大括号 <strong>{}</strong> 括起来。</p><h3 id="CSS-注释"><a href="#CSS-注释" class="headerlink" title="CSS 注释"></a>CSS 注释</h3><p>注释是用来解释，并且可以随意编辑它，浏览器会忽略它。</p><p>CSS注释以 <strong>/*</strong> 开始, 以 ***/** 结束。</p><h3 id="CSS-id-和-class"><a href="#CSS-id-和-class" class="headerlink" title="CSS id 和 class"></a>CSS id 和 class</h3><p><strong>id 选择器</strong></p><p>id 选择器可以为<strong>标有特定 id 的 HTML 元素</strong>指定特定的样式。</p><p>HTML元素以id属性来设置id选择器，CSS 中 id 选择器以 “#” 来定义。</p><p>以下的样式规则应用于元素属性 id=”para1”:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#para1</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>class 选择器</strong></p><p>class 选择器用于<strong>描述一组元素的样式</strong>，class 选择器有别于id选择器，class可以在多个元素中使用。</p><p>class 选择器在 HTML 中以 class 属性表示，在 CSS 中，<strong>类选择器以一个点 . 号显示</strong>：</p><p>在以下的例子中，所有拥有 center 类的 HTML 元素均为居中。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> {<span class="attribute">text-align</span>:center;}</span><br></pre></td></tr></tbody></table></figure><p>也可以指定<strong>特定的 HTML 元素</strong>使用 class。在以下实例中，所有的 p 元素使<strong>用 class=”center”</strong> 让该元素的文本居中：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.center</span> {<span class="attribute">text-align</span>:center;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-创建"><a href="#CSS-创建" class="headerlink" title="CSS 创建"></a>CSS 创建</h2><h3 id="如何插入样式表"><a href="#如何插入样式表" class="headerlink" title="如何插入样式表"></a>如何插入样式表</h3><p>插入样式表的方法有三种:</p><ul><li>外部样式表(External style sheet)</li><li>内部样式表(Internal style sheet)</li><li>内联样式(Inline style)</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，可以通过改变一个文件来改变整个站点的外观。每个页面使用 &lt;link&gt; 标签链接到样式表。 &lt;link&gt; 标签在（文档的）头部：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>外部样式表可以在任何文本编辑器中进行编辑。文件<strong>不能包含任何的 html 标签</strong>。样式表应该以 .css 扩展名进行保存：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr {<span class="attribute">color</span>:sienna;}</span><br><span class="line"><span class="selector-tag">p</span> {<span class="attribute">margin-left</span>:<span class="number">20px</span>;}</span><br><span class="line"><span class="selector-tag">body</span> {<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">"/images/back40.gif"</span>);}</span><br></pre></td></tr></tbody></table></figure><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文档需要特殊的样式时，就应该使用内部样式表。可以使用 &lt;style&gt; 标签在文档头部定义内部样式表：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">hr {<span class="attribute">color</span>:sienna;}</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> {<span class="attribute">margin-left</span>:<span class="number">20px</span>;}</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> {<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">"images/back40.gif"</span>);}</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势，例如当样式仅需要在一个元素上应用一次时。</p><p>要使用内联样式，需要<strong>在相关的标签内</strong>使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:sienna;margin-left:20px"</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="多重样式"><a href="#多重样式" class="headerlink" title="多重样式"></a>多重样式</h3><p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p><p>例如，外部样式表拥有针对 h3 选择器的三个属性：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">8pt</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而内部样式表拥有针对 h3 选择器的两个属性：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么 h3 得到的样式是：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20pt</span>;</span><br></pre></td></tr></tbody></table></figure><p>颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p><h3 id="多重样式优先级"><a href="#多重样式优先级" class="headerlink" title="多重样式优先级"></a>多重样式优先级</h3><p>一般情况下，优先级如下：</p><p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p><h2 id="CSS-背景"><a href="#CSS-背景" class="headerlink" title="CSS 背景"></a>CSS 背景</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p><strong>background-color</strong> 属性定义了元素的背景颜色。页面的背景颜色使用在body的选择器中:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {<span class="attribute">background-color</span>:<span class="number">#b0c4de</span>;}</span><br></pre></td></tr></tbody></table></figure><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><p><strong>background-image</strong> 属性描述了元素的背景图像。默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'paper.gif'</span>);}</span><br></pre></td></tr></tbody></table></figure><p>默认情况下 background-image 属性会在页面的<strong>水平或者垂直方向同时</strong>平铺。</p><p>可以设置图像只在水平方向平铺 (<strong>repeat-x</strong>)：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'gradient2.png'</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>:repeat-x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果不想让图像平铺，可以使用 <strong>background-repeat</strong> 属性:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'img_tree.png'</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以利用 <strong>background-position</strong> 属性改变图像在背景中的位置：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'img_tree.png'</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line"><span class="attribute">background-position</span><span class="selector-pseudo">:right</span> <span class="attribute">top</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>为了简化这些属性的代码，可以将这些属性合并在同一个属性中。</p><p>当使用简写属性时，属性值的顺序为：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {<span class="attribute">background</span>:<span class="number">#ffffff</span> <span class="built_in">url</span>(<span class="string">'img_tree.png'</span>) no-repeat right top;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-文本"><a href="#CSS-文本" class="headerlink" title="CSS 文本"></a>CSS 文本</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><p>颜色color属性被用来设置文字的颜色。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {<span class="attribute">color</span>:red;}</span><br><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">color</span>:<span class="number">#00ff00</span>;}</span><br><span class="line"><span class="selector-tag">h2</span> {<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);}</span><br></pre></td></tr></tbody></table></figure><h3 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h3><p>文本排列属性<strong>text-align</strong>是用来设置文本的水平对齐方式。</p><p>文本可<strong>居中或对齐到左或右，两端对齐。</strong></p><p>当text-align设置为”<strong>justify</strong>“，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">text-align</span>:center;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.date</span> {<span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.main</span> {<span class="attribute">text-align</span>:justify;}</span><br></pre></td></tr></tbody></table></figure><h3 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h3><p><strong>text-decoration</strong> 属性用来设置或删除文本的装饰。主要是用来删除链接的下划线：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> {<span class="attribute">text-decoration</span>:none;}</span><br><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">text-decoration</span>:overline;}</span><br><span class="line"><span class="selector-tag">h2</span> {<span class="attribute">text-decoration</span>:line-through;}</span><br><span class="line"><span class="selector-tag">h3</span> {<span class="attribute">text-decoration</span>:underline;}</span><br></pre></td></tr></tbody></table></figure><h3 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h3><p>文本转换属性是用来指定在一个文本中的大写和小写字母。可用于所有字句变成大写或小写字母，或每个单词的首字母大写。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.uppercase</span> {<span class="attribute">text-transform</span>:uppercase;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.lowercase</span> {<span class="attribute">text-transform</span>:lowercase;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.capitalize</span> {<span class="attribute">text-transform</span>:capitalize;}</span><br></pre></td></tr></tbody></table></figure><h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><p>文本缩进属性是用来指定文本的第一行的缩进。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> {<span class="attribute">text-indent</span>:<span class="number">50px</span>;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-字体"><a href="#CSS-字体" class="headerlink" title="CSS 字体"></a>CSS 字体</h2><p>CSS字体属性定义字体，加粗，大小，文字样式。</p><h3 id="CSS字型"><a href="#CSS字型" class="headerlink" title="CSS字型"></a>CSS字型</h3><p>在CSS中，有两种类型的字体系列名称：</p><ul><li><strong>通用字体系列</strong> - 拥有相似外观的字体系统组合（如 “Serif” 或 “Monospace”）</li><li><strong>特定字体系列</strong> - 一个特定的字体系列（如 “Times” 或 “Courier”）</li></ul><h3 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h3><p><strong>font-family</strong> 属性设置文本的字体系列。应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，将尝试下一种字体。</p><p><strong>注意</strong>: 如果字体系列的名称超过一个字，它必须用引号，如Font Family：”宋体”。</p><p>多个字体系列是用一个逗号分隔指明：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>{<span class="attribute">font-family</span>:<span class="string">"Times New Roman"</span>, Times, serif;}</span><br></pre></td></tr></tbody></table></figure><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p><strong>font-style</strong>属性有三个值：</p><ul><li><strong>正常</strong> - 正常显示文本</li><li><strong>斜体</strong> - 以斜体字显示的文字</li><li><strong>倾斜的文字</strong> - 文字向一边倾斜（和斜体非常类似，但不太支持）</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.normal</span> {<span class="attribute">font-style</span>:normal;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.italic</span> {<span class="attribute">font-style</span>:italic;}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.oblique</span> {<span class="attribute">font-style</span>:oblique;}</span><br></pre></td></tr></tbody></table></figure><h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><p><strong>font-size</strong> 属性设置文本的大小。</p><p>字体大小的值可以是绝对或相对的大小。</p><p><strong>绝对大小：</strong></p><ul><li>设置一个指定大小的文本</li><li>不允许用户在所有浏览器中改变文本大小</li><li>确定了输出的物理尺寸时绝对大小很有用</li></ul><p><strong>相对大小：</strong></p><ul><li>相对于周围的元素来设置大小</li><li>允许用户在浏览器中改变文字大小</li></ul><p>如果你指定一个字体的大小，默认大小和普通文本段落一样，是<strong>16像素</strong>（16px=1em）。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">font-size</span>:<span class="number">40px</span>;}</span><br><span class="line"><span class="selector-tag">h2</span> {<span class="attribute">font-size</span>:<span class="number">30px</span>;}</span><br><span class="line"><span class="selector-tag">p</span> {<span class="attribute">font-size</span>:<span class="number">14px</span>;}</span><br></pre></td></tr></tbody></table></figure><p>1em的默认大小是16px。可以通过下面这个公式将像素转换为em：<strong>px/16=em</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">font-size</span>:<span class="number">2.5em</span>;} <span class="comment">/* 40px/16=2.5em */</span></span><br><span class="line"><span class="selector-tag">h2</span> {<span class="attribute">font-size</span>:<span class="number">1.875em</span>;} <span class="comment">/* 30px/16=1.875em */</span></span><br><span class="line"><span class="selector-tag">p</span> {<span class="attribute">font-size</span>:<span class="number">0.875em</span>;} <span class="comment">/* 14px/16=0.875em */</span></span><br></pre></td></tr></tbody></table></figure><p>设置 &lt;body&gt;元素的默认字体大小的是百分比：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {<span class="attribute">font-size</span>:<span class="number">100%</span>;}</span><br><span class="line"><span class="selector-tag">h1</span> {<span class="attribute">font-size</span>:<span class="number">2.5em</span>;}</span><br><span class="line"><span class="selector-tag">h2</span> {<span class="attribute">font-size</span>:<span class="number">1.875em</span>;}</span><br><span class="line"><span class="selector-tag">p</span> {<span class="attribute">font-size</span>:<span class="number">0.875em</span>;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-链接"><a href="#CSS-链接" class="headerlink" title="CSS 链接"></a>CSS 链接</h2><p>不同的链接可以有不同的样式。</p><h3 id="链接样式"><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h3><p>链接的样式，可以用任何CSS属性（如颜色，字体，背景等）。</p><p>特别的链接，可以有不同的样式，这取决于他们是什么状态。</p><p>这四个链接状态是：</p><ul><li>a:link - <strong>正常</strong>，未访问过的链接</li><li>a:visited - 用户<strong>已访问</strong>过的链接</li><li>a:hover - 当用户<strong>鼠标放在链接</strong>上时</li><li>a:active - 链接<strong>被点击</strong>的那一刻</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> {<span class="attribute">color</span>:<span class="number">#000000</span>;}      <span class="comment">/* 未访问链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> {<span class="attribute">color</span>:<span class="number">#00FF00</span>;}  <span class="comment">/* 已访问链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {<span class="attribute">color</span>:<span class="number">#FF00FF</span>;}  <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> {<span class="attribute">color</span>:<span class="number">#0000FF</span>;}  <span class="comment">/* 鼠标点击时 */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>a:hover 必须跟在 a:link 和 a:visited后面</li><li>a:active 必须跟在 a:hover后面</li></ul><h3 id="文本修饰-1"><a href="#文本修饰-1" class="headerlink" title="文本修饰"></a>文本修饰</h3><p><strong>text-decoration</strong> 属性主要用于删除链接中的下划线：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> {<span class="attribute">text-decoration</span>:none;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> {<span class="attribute">text-decoration</span>:none;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {<span class="attribute">text-decoration</span>:underline;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> {<span class="attribute">text-decoration</span>:underline;}</span><br></pre></td></tr></tbody></table></figure><h3 id="背景颜色-1"><a href="#背景颜色-1" class="headerlink" title="背景颜色"></a>背景颜色</h3><p><strong>background-color</strong>属性指定链接背景色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> {<span class="attribute">background-color</span>:<span class="number">#B2FF99</span>;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> {<span class="attribute">background-color</span>:<span class="number">#FFFF85</span>;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> {<span class="attribute">background-color</span>:<span class="number">#FF704D</span>;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-列表"><a href="#CSS-列表" class="headerlink" title="CSS 列表"></a>CSS 列表</h2><p>CSS 列表属性作用如下：</p><ul><li>设置不同的列表项标记为<strong>有序列表</strong></li><li>设置不同的列表项标记为<strong>无序列表</strong></li><li>设置列表项标记为<strong>图像</strong></li></ul><h3 id="不同的列表项标记"><a href="#不同的列表项标记" class="headerlink" title="不同的列表项标记"></a>不同的列表项标记</h3><p><strong>list-style-type</strong>属性指定列表项标记的类型是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.a</span> {<span class="attribute">list-style-type</span>: circle;}</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.b</span> {<span class="attribute">list-style-type</span>: square;}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">ol</span><span class="selector-class">.c</span> {<span class="attribute">list-style-type</span>: upper-roman;}</span><br><span class="line"><span class="selector-tag">ol</span><span class="selector-class">.d</span> {<span class="attribute">list-style-type</span>: lower-alpha;}</span><br></pre></td></tr></tbody></table></figure><h3 id="作为列表项标记的图像"><a href="#作为列表项标记的图像" class="headerlink" title="作为列表项标记的图像"></a>作为列表项标记的图像</h3><p>要指定列表项标记的图像，使用列表样式图像属性</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">sqpurple.gif</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">0px</span> <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">14px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>ul:<ul><li>设置列表类型为<strong>没有列表项标记</strong></li><li>设置<strong>填充和边距</strong> 0px（浏览器兼容性）</li></ul></li><li>ul 中所有 li:<ul><li>设置图像的 URL，并设置它只显示一次（无重复）</li><li>您需要的定位<strong>图像位置</strong>（左 0px 和上下 5px）</li><li>用 <strong>padding-left</strong> 属性把文本置于列表中</li></ul></li></ul><h3 id="简写-1"><a href="#简写-1" class="headerlink" title="简写"></a>简写</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">list-style</span>: square <span class="built_in">url</span>(<span class="string">"sqpurple.gif"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按顺序设置如下属性：</p><ul><li>list-style-type</li><li>list-style-position</li><li>list-style-image</li></ul><h2 id="CSS-表格"><a href="#CSS-表格" class="headerlink" title="CSS 表格"></a>CSS 表格</h2><h3 id="表格边框"><a href="#表格边框" class="headerlink" title="表格边框"></a>表格边框</h3><p>使用<strong>border</strong>属性指定CSS表格边框。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了显示一个表的单个边框，使用 <strong>border-collapse</strong>属性。</p><p><strong>border-collapse</strong> 属性设置表格的边框是否被折叠成一个单一的边框或隔开：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-collapse</span>:collapse;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">table</span>,<span class="selector-tag">th</span>, <span class="selector-tag">td</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="表格宽度和高度"><a href="#表格宽度和高度" class="headerlink" title="表格宽度和高度"></a>表格宽度和高度</h3><p>Width和height属性定义表格的宽度和高度。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="表格文字对齐"><a href="#表格文字对齐" class="headerlink" title="表格文字对齐"></a>表格文字对齐</h3><p>表格中的文本对齐和垂直对齐属性。</p><p><strong>text-align</strong>属性设置水平对齐方式，向左，右，或中心：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>vertical-align</strong>属性设置垂直对齐，比如顶部，底部或中间：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>:bottom;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="表格填充"><a href="#表格填充" class="headerlink" title="表格填充"></a>表格填充</h3><p>使用td和th元素的<strong>padding</strong>属性控制边框和表格内容之间的间距：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="表格颜色"><a href="#表格颜色" class="headerlink" title="表格颜色"></a>表格颜色</h3><p>指定边框的颜色，和th元素的文本和背景颜色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span>, <span class="selector-tag">th</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid green;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">th</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">background-color</span>:green;</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h2><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p><img src="https://www.runoob.com/images/box-model.gif"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h3 id="元素的宽度和高度"><a href="#元素的宽度和高度" class="headerlink" title="元素的宽度和高度"></a>元素的宽度和高度</h3><p>当指定一个 CSS 元素的宽度和高度属性时，你只是设置<strong>内容区域</strong>的宽度和高度，还必须添加内边距，边框和外边距。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">25px</span> solid green;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>元素的总宽度为 450px。</p><ul><li><p>最终元素的总宽度计算公式是这样的：</p><p>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</p></li><li><p>元素的总高度最终计算公式是这样的：</p><p>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</p></li></ul><h2 id="CSS-边框"><a href="#CSS-边框" class="headerlink" title="CSS 边框"></a>CSS 边框</h2><h3 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h3><p><strong>border-style</strong>属性用来定义边框的样式：</p><ul><li>none: 默认无边框</li><li>dotted: 定义一个点线边框</li><li>dashed: 定义一个虚线边框</li><li>solid: 定义实线边框</li><li>double: 定义两个边框。 两个边框的宽度和 border-width 的值相同</li><li>groove: 定义3D沟槽边框。效果取决于边框的颜色值</li><li>ridge: 定义3D脊边框。效果取决于边框的颜色值</li><li>inset:定义一个3D的嵌入边框。效果取决于边框的颜色值</li><li>outset: 定义一个3D突出边框。 效果取决于边框的颜色值</li></ul><h3 id="边框宽度"><a href="#边框宽度" class="headerlink" title="边框宽度"></a>边框宽度</h3><p>可以通过 <strong>border-width</strong> 属性为边框指定宽度。</p><p>可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.one</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">5px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.two</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-width</span>:medium;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="边框颜色"><a href="#边框颜色" class="headerlink" title="边框颜色"></a>边框颜色</h3><p><strong>border-color</strong>属性用于设置边框的颜色。</p><ul><li>name - 指定颜色的名称，如 “red”</li><li>RGB - 指定 RGB 值, 如 “rgb(255,0,0)”</li><li>Hex - 指定16进制值, 如 “#ff0000”</li></ul><p>border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.one</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.two</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="number">#98bf21</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="单独设置各边"><a href="#单独设置各边" class="headerlink" title="单独设置各边"></a>单独设置各边</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border-top-style</span>:dotted;</span><br><span class="line">    <span class="attribute">border-right-style</span>:solid;</span><br><span class="line">    <span class="attribute">border-bottom-style</span>:dotted;</span><br><span class="line">    <span class="attribute">border-left-style</span>:solid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>border-style属性可以有1-4个值：</p><ul><li>border-style:dotted solid double dashed;<ul><li>上边框是 dotted</li><li>右边框是 solid</li><li>底边框是 double</li><li>左边框是 dashed</li></ul></li><li>border-style:dotted solid double;<ul><li>上边框是 dotted</li><li>左、右边框是 solid</li><li>底边框是 double</li></ul></li><li>border-style:dotted solid;<ul><li>上、底边框是 dotted</li><li>右、左边框是 solid</li></ul></li><li>border-style:dotted;<ul><li>四面边框是 dotted</li></ul></li></ul><h3 id="简写-2"><a href="#简写-2" class="headerlink" title="简写"></a>简写</h3><p>可以在”border”属性中设置：</p><ul><li>border-width</li><li>border-style (required)</li><li>border-color</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">5px</span> solid red;</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-轮廓"><a href="#CSS-轮廓" class="headerlink" title="CSS 轮廓"></a>CSS 轮廓</h2><p>轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p><p><img src="https://www.runoob.com/images/box_outline.gif"></p><h3 id="轮廓属性"><a href="#轮廓属性" class="headerlink" title="轮廓属性"></a>轮廓属性</h3><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">值</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-outline.html">outline</a></td><td align="left">在一个声明中设置所有的轮廓属性</td><td align="left"><em>outline-color; outline-style; outline-width</em>; inherit</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-outline-color.html">outline-color</a></td><td align="left">设置轮廓的颜色</td><td align="left"><em>color-name; hex-number; rgb-number;</em> invert; inherit</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-outline-style.html">outline-style</a></td><td align="left">设置轮廓的样式</td><td align="left">none; dotted; dashed; solid; double; groove; ridge; inset; outset; inherit</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-outline-width.html">outline-width</a></td><td align="left">设置轮廓的宽度</td><td align="left">thin; medium; thick; *length;*inherit</td></tr></tbody></table><h2 id="CSS-外边距"><a href="#CSS-外边距" class="headerlink" title="CSS 外边距"></a>CSS 外边距</h2><p>CSS margin(外边距)属性定义元素周围的空间。</p><p>margin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。</p><p>margin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/08/VlwVi.png"></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">auto</td><td align="left">设置浏览器边距。 这样做的结果会依赖于浏览器</td></tr><tr><td align="left"><em>length</em></td><td align="left">定义一个固定的margin（使用像素，pt，em等）</td></tr><tr><td align="left"><em>%</em></td><td align="left">定义一个使用百分比的边距</td></tr></tbody></table><h3 id="单边外边距属性"><a href="#单边外边距属性" class="headerlink" title="单边外边距属性"></a>单边外边距属性</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-top</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin-right</span>:<span class="number">50px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>:<span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="简写-3"><a href="#简写-3" class="headerlink" title="简写"></a>简写</h3><p>margin属性可以有一到四个值。</p><ul><li>margin:25px 50px 75px 100px;<ul><li>上边距为25px</li><li>右边距为50px</li><li>下边距为75px</li><li>左边距为100px</li></ul></li><li>margin:25px 50px 75px;<ul><li>上边距为25px</li><li>左右边距为50px</li><li>下边距为75px</li></ul></li><li>margin:25px 50px;<ul><li>上下边距为25px</li><li>左右边距为50px</li></ul></li><li>margin:25px;<ul><li>所有的4个边距都是25px</li></ul></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">100px</span> <span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-填充"><a href="#CSS-填充" class="headerlink" title="CSS 填充"></a>CSS 填充</h2><p>CSS padding（填充）是一个简写属性，定义元素边框与元素内容之间的空间，即上下左右的内边距。</p><p>当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。</p><p>单独使用 padding 属性可以改变上下左右的填充。</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><em>length</em></td><td align="left">定义一个固定的填充(像素, pt, em,等)</td></tr><tr><td align="left"><em>%</em></td><td align="left">使用百分比值定义一个填充</td></tr></tbody></table><h3 id="单边内边距属性"><a href="#单边内边距属性" class="headerlink" title="单边内边距属性"></a>单边内边距属性</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding-top</span>:<span class="number">25px</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>:<span class="number">25px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>:<span class="number">50px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>:<span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="简写-4"><a href="#简写-4" class="headerlink" title="简写"></a>简写</h3><p>Padding属性，可以有一到四个值。</p><ul><li><p><strong>padding:25px 50px 75px 100px;</strong></p><ul><li>上填充为25px</li><li>右填充为50px</li><li>下填充为75px</li><li>左填充为100px</li></ul></li><li><p><strong>padding:25px 50px 75px;</strong></p><ul><li>上填充为25px</li><li>左右填充为50px</li><li>下填充为75px</li></ul></li><li><p><strong>padding:25px 50px;</strong></p><ul><li>上下填充为25px</li><li>左右填充为50px</li></ul></li><li><p><strong>padding:25px;</strong></p><ul><li>所有的填充都是25px</li></ul></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>:<span class="number">25px</span> <span class="number">50px</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-分组和嵌套选择器"><a href="#CSS-分组和嵌套选择器" class="headerlink" title="CSS 分组和嵌套选择器"></a>CSS 分组和嵌套选择器</h2><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="嵌套选择器"><a href="#嵌套选择器" class="headerlink" title="嵌套选择器"></a>嵌套选择器</h3><p>在下面的例子设置了四个样式：</p><ul><li><strong>p{ }</strong>: 为所有 <strong>p</strong> 元素指定一个样式。</li><li><strong>.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的元素指定一个样式。</li><li><strong>.marked p{ }</strong>: 为所有 <strong>class=”marked”</strong> 元素内的 <strong>p</strong> 元素指定一个样式。</li><li><strong>p.marked{ }</strong>: 为所有 <strong>class=”marked”</strong> 的 <strong>p</strong> 元素指定一个样式。</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.marked</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.marked</span> <span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:white;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.marked</span>{</span><br><span class="line">    <span class="attribute">text-decoration</span>:underline;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-尺寸"><a href="#CSS-尺寸" class="headerlink" title="CSS 尺寸"></a>CSS 尺寸</h2><p>dimension 属性允许控制元素的<strong>高度和宽度</strong>，同样允许<strong>增加行间距</strong>。</p><h3 id="所有CSS-尺寸-Dimension-属性"><a href="#所有CSS-尺寸-Dimension-属性" class="headerlink" title="所有CSS 尺寸 (Dimension)属性"></a>所有CSS 尺寸 (Dimension)属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-height.html">height</a></td><td align="left">设置元素的高度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-line-height.html">line-height</a></td><td align="left">设置行高。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-max-height.html">max-height</a></td><td align="left">设置元素的最大高度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-max-width.html">max-width</a></td><td align="left">设置元素的最大宽度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-min-height.html">min-height</a></td><td align="left">设置元素的最小高度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-min-width.html">min-width</a></td><td align="left">设置元素的最小宽度。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cssref/pr-dim-width.html">width</a></td><td align="left">设置元素的宽度。</td></tr></tbody></table><h2 id="CSS-显示与可见性"><a href="#CSS-显示与可见性" class="headerlink" title="CSS 显示与可见性"></a>CSS 显示与可见性</h2><p>display属性设置一个元素应<strong>如何显示</strong>，visibility属性指定一个元素应<strong>可见还是隐藏</strong>。</p><h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><p>隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。</p><ul><li><p>display:none可以隐藏某个元素，且隐藏的元素不会占用任何空间</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.hidden</span> {<span class="attribute">display</span>:none;}</span><br></pre></td></tr></tbody></table></figure></li><li><p>visibility:hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.hidden</span> {<span class="attribute">visibility</span>:hidden;}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="块和内联元素"><a href="#块和内联元素" class="headerlink" title="块和内联元素"></a>块和内联元素</h3><p>块元素是一个元素，占用了<strong>全部宽度</strong>，在前后都是换行符。</p><p>块元素的例子：</p><ul><li>&lt;h1&gt;</li><li>&lt;p&gt;</li><li>&lt;div&gt;</li></ul><p>内联元素<strong>只需要必要的宽度，不强制换行</strong>。</p><p>内联元素的例子：</p><ul><li>&lt;span&gt;</li><li>&lt;a&gt;</li></ul><h3 id="改变一个元素显示"><a href="#改变一个元素显示" class="headerlink" title="改变一个元素显示"></a>改变一个元素显示</h3><p>把列表项显示为内联元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> {<span class="attribute">display</span>:inline;}</span><br></pre></td></tr></tbody></table></figure><p>把span元素作为块元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> {<span class="attribute">display</span>:block;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS 定位"></a>CSS 定位</h2><p>position 属性指定了元素的定位类型：</p><ul><li><a href="https://www.runoob.com/css/css-positioning.html#position-static">static</a></li><li><a href="https://www.runoob.com/css/css-positioning.html#position-relative">relative</a></li><li><a href="https://www.runoob.com/css/css-positioning.html#position-fixed">fixed</a></li><li><a href="https://www.runoob.com/css/css-positioning.html#position-absolute">absolute</a></li><li><a href="https://www.runoob.com/css/css-positioning.html#position-sticky">sticky</a></li></ul><h3 id="static-定位"><a href="#static-定位" class="headerlink" title="static 定位"></a>static 定位</h3><p>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</p><p>静态定位的元素不会受到 top, bottom, left, right影响。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.static</span> {</span><br><span class="line">    <span class="attribute">position</span>: static;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#73AD21</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="fixed-定位"><a href="#fixed-定位" class="headerlink" title="fixed 定位"></a>fixed 定位</h3><p>元素的位置相对于浏览器窗口是固定位置。Fixed定位使元素的位置与文档流无关，因此不占据空间。</p><p>即使窗口是滚动的它也不会移动：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.pos_fixed</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">5px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="relative-定位"><a href="#relative-定位" class="headerlink" title="relative 定位"></a>relative 定位</h3><p>相对定位元素的定位是相对其正常位置。移动相对定位元素，但它原本所占的空间不会改变。相对定位元素经常被用来作为绝对定位元素的容器块。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_left</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.pos_right</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">20px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="absolute-定位"><a href="#absolute-定位" class="headerlink" title="absolute 定位"></a>absolute 定位</h3><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。</p><p>absolute 定位使元素的位置与文档流无关，因此不占据空间。</p><p>absolute 定位的元素和其他元素重叠。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">150px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sticky-定位"><a href="#sticky-定位" class="headerlink" title="sticky 定位"></a>sticky 定位</h3><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。</p><p>它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sticky</span> {</span><br><span class="line">    <span class="attribute">position</span>: -webkit-sticky; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#4CAF50</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="重叠的元素"><a href="#重叠的元素" class="headerlink" title="重叠的元素"></a>重叠的元素</h3><p>元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素。<strong>z-index</strong>属性指定了一个元素的堆叠顺序，具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h2><p><strong>overflow</strong> 属性用于控制内容溢出元素框时显示的方式。只工作于指定高度的块元素上。</p><h3 id="Overflow"><a href="#Overflow" class="headerlink" title="Overflow"></a>Overflow</h3><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">visible</td><td align="left">默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td align="left">hidden</td><td align="left">内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td align="left">scroll</td><td align="left">内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td align="left">auto</td><td align="left">如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td align="left">inherit</td><td align="left">规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table><h3 id="visible"><a href="#visible" class="headerlink" title="visible"></a>visible</h3><p>默认情况下，overflow 的值为 visible， 意思是内容溢出元素框：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: visible;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-浮动"><a href="#CSS-浮动" class="headerlink" title="CSS 浮动"></a>CSS 浮动</h2><p>Float（浮动）会使元素向左或向右移动，其周围的元素也会重新排列。往往是用于图像，但它在布局时一样非常有用。</p><h3 id="浮动方式"><a href="#浮动方式" class="headerlink" title="浮动方式"></a>浮动方式</h3><p>元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。</p><p>一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</p><p>浮动元素之后的元素将围绕它。</p><p>浮动元素之前的元素将不会受到影响。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:right</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="彼此相邻的浮动元素"><a href="#彼此相邻的浮动元素" class="headerlink" title="彼此相邻的浮动元素"></a>彼此相邻的浮动元素</h3><p>如果把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.thumbnail</span> </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">110px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。</p><p>clear 属性指定元素两侧不能出现浮动元素。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text_line</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-对齐"><a href="#CSS-对齐" class="headerlink" title="CSS 对齐"></a>CSS 对齐</h2><h3 id="元素居中对齐"><a href="#元素居中对齐" class="headerlink" title="元素居中对齐"></a>元素居中对齐</h3><p>要水平居中对齐一个元素(如 &lt;div&gt;), 可以使用 **margin: auto;**。</p><p>设置到元素的宽度将防止它溢出到容器的边缘。</p><p>元素通过指定宽度，并将两边的空外边距平均分配。</p><h3 id="文本居中对齐"><a href="#文本居中对齐" class="headerlink" title="文本居中对齐"></a>文本居中对齐</h3><p>为了文本在元素内居中对齐，可以使用 <strong>text-align: center;</strong></p><h3 id="图片居中对齐"><a href="#图片居中对齐" class="headerlink" title="图片居中对齐"></a>图片居中对齐</h3><p>让图片居中对齐, 可以使用 <strong>margin: auto;</strong> 并将它放到 <strong>块</strong> 元素中。</p><h3 id="左右对齐-使用定位方式"><a href="#左右对齐-使用定位方式" class="headerlink" title="左右对齐 - 使用定位方式"></a>左右对齐 - 使用定位方式</h3><p>可以使用 <strong>position: absolute;</strong> 属性来对齐元素:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#73AD21</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="左右对齐-使用-float-方式"><a href="#左右对齐-使用-float-方式" class="headerlink" title="左右对齐 - 使用 float 方式"></a>左右对齐 - 使用 float 方式</h3><p>也可以使用 <strong>float</strong> 属性来对齐元素:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#73AD21</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="垂直居中对齐-使用-padding"><a href="#垂直居中对齐-使用-padding" class="headerlink" title="垂直居中对齐 - 使用 padding"></a>垂直居中对齐 - 使用 padding</h3><p>头部顶部使用 <strong>padding</strong>:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">70px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果要水平和垂直都居中，可以使用 <strong>padding</strong> 和 <strong>text-align: center</strong>:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">70px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="垂直居中对齐-使用-line-height"><a href="#垂直居中对齐-使用-line-height" class="headerlink" title="垂直居中对齐 - 使用 line-height"></a>垂直居中对齐 - 使用 line-height</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid green;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 如果文本有多行，添加以下代码: */</span></span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">p</span> {</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="垂直居中-使用-position-和-transform"><a href="#垂直居中-使用-position-和-transform" class="headerlink" title="垂直居中 - 使用 position 和 transform"></a>垂直居中 - 使用 position 和 transform</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span> { </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> solid green; </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">p</span> {</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-组合选择符"><a href="#CSS-组合选择符" class="headerlink" title="CSS 组合选择符"></a>CSS 组合选择符</h2><p>组合选择符说明了两个选择器之间的关系。</p><p>在 CSS3 中包含了四种组合方式:</p><ul><li>后代选择器(以空格     分隔)</li><li>子元素选择器(以大于 <strong>&gt;</strong> 号分隔）</li><li>相邻兄弟选择器（以加号 <strong>+</strong> 分隔）</li><li>普通兄弟选择器（以波浪号 <strong>～</strong> 分隔）</li></ul><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>后代选择器用于选取某元素的后代元素。</p><p>选取所有 &lt;p&gt; 元素插入到 &lt;div&gt; 元素中: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>子元素选择器（Child selectors）只能选择作为某元素直接/一级子元素的元素。</p><p>选择&lt;div&gt;元素中所有直接子元素 &lt;p&gt; ：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。</p><p>选取所有位于 &lt;div&gt; 元素后的第一个 &lt;p&gt; 元素:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="后续兄弟选择器"><a href="#后续兄弟选择器" class="headerlink" title="后续兄弟选择器"></a>后续兄弟选择器</h3><p>后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。</p><p>选取所有 &lt;div&gt; 元素之后的所有相邻兄弟元素 &lt;p&gt; : </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-伪类"><a href="#CSS-伪类" class="headerlink" title="CSS 伪类"></a>CSS 伪类</h2><p>CSS伪类是用来添加一些选择器的特殊效果。</p><h3 id="伪类和CSS类"><a href="#伪类和CSS类" class="headerlink" title="伪类和CSS类"></a>伪类和CSS类</h3><p>伪类可以与 CSS 类配合使用。如果链接已被访问，它会显示为红色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.red</span><span class="selector-pseudo">:visited</span> {<span class="attribute">color</span>:<span class="number">#FF0000</span>;}</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">a</span> class="red" href="css-syntax<span class="selector-class">.html</span>"&gt;CSS 语法&lt;/<span class="selector-tag">a</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="first-child-伪类"><a href="#first-child-伪类" class="headerlink" title="first-child 伪类"></a>first-child 伪类</h3><p>可以使用 :first-child 伪类来选择父元素的第一个子元素。</p><ul><li><p>选择器匹配作为任何元素的第一个子元素的 &lt;p&gt; 元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child</span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>选择相匹配的所有&lt;p&gt;元素的第一个 &lt;i&gt; 元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &gt; <span class="selector-tag">i</span><span class="selector-pseudo">:first</span>-child</span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>选择器匹配所有作为元素的第一个子元素的 &lt;p&gt; 元素中的所有 &lt;i&gt; 元素：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child <span class="selector-tag">i</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="lang-伪类"><a href="#lang-伪类" class="headerlink" title="lang 伪类"></a>lang 伪类</h3><p>lang 伪类可以为不同的语言定义特殊的规则。lang 类为属性值为 no 的q元素定义引号的类型：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:lang</span>(no) {<span class="attribute">quotes</span>: <span class="string">"~"</span> <span class="string">"~"</span>;}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-伪元素"><a href="#CSS-伪元素" class="headerlink" title="CSS 伪元素"></a>CSS 伪元素</h2><p>CSS伪元素是用来添加一些选择器的特殊效果。</p><h3 id="first-line-伪元素"><a href="#first-line-伪元素" class="headerlink" title="first-line 伪元素"></a>first-line 伪元素</h3><p>“first-line” 伪元素用于向文本的首行设置特殊样式。</p><p>根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff0000</span>;</span><br><span class="line">    <span class="attribute">font-variant</span>:small-caps;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面的属性可应用于 “first-line” 伪元素：</p><ul><li>font properties</li><li>color properties </li><li>background properties</li><li>word-spacing</li><li>letter-spacing</li><li>text-decoration</li><li>vertical-align</li><li>text-transform</li><li>line-height</li><li>clear</li></ul><h3 id="first-letter-伪元素"><a href="#first-letter-伪元素" class="headerlink" title="first-letter 伪元素"></a>first-letter 伪元素</h3><p>“first-letter” 伪元素用于向文本的首字母设置特殊样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff0000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:xx-large;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面的属性可应用于 “first-letter” 伪元素： </p><ul><li>font properties</li><li>color properties </li><li>background properties</li><li>margin properties</li><li>padding properties</li><li>border properties</li><li>text-decoration</li><li>vertical-align (only if “float” is “none”)</li><li>text-transform</li><li>line-height</li><li>float</li><li>clear</li></ul><h3 id="伪元素和CSS类"><a href="#伪元素和CSS类" class="headerlink" title="伪元素和CSS类"></a>伪元素和CSS类</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.article</span><span class="selector-pseudo">:first</span>-letter {<span class="attribute">color</span>:<span class="number">#ff0000</span>;}</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">p</span> class="<span class="selector-tag">article</span>"&gt;文章段落&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面的例子会使所有 class 为 article 的段落的首字母变为红色。</p><h3 id="多个伪元素"><a href="#多个伪元素" class="headerlink" title="多个伪元素"></a>多个伪元素</h3><p>可以结合多个伪元素来使用。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter</span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff0000</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:xx-large;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#0000ff</span>;</span><br><span class="line">    <span class="attribute">font-variant</span>:small-caps;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="before-伪元素"><a href="#before-伪元素" class="headerlink" title="before 伪元素"></a>before 伪元素</h3><p>“:before” 伪元素可以在元素的内容前面插入新内容。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> </span><br><span class="line">{</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(<span class="string">smiley.gif</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="after-伪元素"><a href="#after-伪元素" class="headerlink" title="after 伪元素"></a>after 伪元素</h3><p>“:after” 伪元素可以在元素的内容之后插入新内容。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:after</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(<span class="string">smiley.gif</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-导航栏"><a href="#CSS-导航栏" class="headerlink" title="CSS 导航栏"></a>CSS 导航栏</h2><h3 id="导航栏-链接列表"><a href="#导航栏-链接列表" class="headerlink" title="导航栏=链接列表"></a>导航栏=链接列表</h3><p>导航条基本上是一个链接列表，所以使用 &lt;ul&gt; 和 &lt;li&gt;元素非常有意义：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#home</span>"&gt;主页&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#news</span>"&gt;新闻&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#contact</span>"&gt;联系&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#about</span>"&gt;关于&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ul</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>从列表中删除边距和填充：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>list-style-type:none</strong> - 移除列表前小标志。<strong>一个导航栏并不需要列表标记</strong></li><li>移除浏览器的默认设置将边距和填充设置为0</li></ul><h3 id="垂直导航栏"><a href="#垂直导航栏" class="headerlink" title="垂直导航栏"></a>垂直导航栏</h3><p>只需要 &lt;a&gt;元素的样式，建立一个垂直的导航栏：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>display:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度</li><li>width:60px - 指定一个60像素的宽度，块元素默认情况下是最大宽度</li></ul><h3 id="垂直导航条实例"><a href="#垂直导航条实例" class="headerlink" title="垂直导航条实例"></a>垂直导航条实例</h3><p>创建一个简单的垂直导航条实例，在鼠标移动到选项时，修改背景颜色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span> {</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 鼠标移动到选项上修改背景颜色 */</span></span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="激活-当前导航条实例"><a href="#激活-当前导航条实例" class="headerlink" title="激活/当前导航条实例"></a>激活/当前导航条实例</h3><p>在点击了选项后，可以添加 “<strong>active</strong>“ 类来标注哪个选项被选中：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-class">.active</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="创建链接并添加边框"><a href="#创建链接并添加边框" class="headerlink" title="创建链接并添加边框"></a>创建链接并添加边框</h3><p>可以在 &lt;li&gt; or &lt;a&gt; 上添加<strong>text-align:center</strong> 样式来让链接居中。</p><p>可以在 <strong>border</strong> &lt;ul&gt; 上添加 <strong>border</strong> 属性来让导航栏有边框。</p><p>如果要在每个选项上添加边框，可以在每个 &lt;li&gt; 元素上添加<strong>border-bottom</strong> :</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#555</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span> {</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#555</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> {</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="全屏高度的固定导航条"><a href="#全屏高度的固定导航条" class="headerlink" title="全屏高度的固定导航条"></a>全屏高度的固定导航条</h3><p>创建一个左边是全屏高度的固定导航条，右边是可滚动的内容：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>; <span class="comment">/* 全屏高度 */</span></span><br><span class="line">    <span class="attribute">position</span>: fixed; </span><br><span class="line">    <span class="attribute">overflow</span>: auto; <span class="comment">/* 如果导航栏选项多，允许滚动 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="水平导航栏"><a href="#水平导航栏" class="headerlink" title="水平导航栏"></a>水平导航栏</h3><p>有两种方法创建横向导航栏：**内联(inline)<strong>或</strong>浮动(float)**。</p><ul><li><p><strong>内联列表项</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span></span><br><span class="line">{</span><br><span class="line">    &lt;!--默认情况下，&lt;<span class="selector-tag">li</span>&gt; 元素是块元素。删除换行符之前和之后每个列表项，以显示一行--&gt;</span><br><span class="line">    <span class="attribute">display</span>:inline;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>浮动列表项</strong></p><p>上面的例子中链接有不同的宽度。对于所有的链接宽度相等，浮动 &lt;li&gt;元素，并指定为 &lt;a&gt;元素的宽度：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>float:left - 使用浮动块元素的幻灯片彼此相邻</li><li>display:block - 显示块元素的链接，让整体变为可点击链接区域（不只是文本），它允许我们指定宽度</li><li>width:60px - 块元素默认情况下是最大宽度。我们要指定一个60像素的宽度</li></ul></li></ul><h3 id="水平导航条实例"><a href="#水平导航条实例" class="headerlink" title="水平导航条实例"></a>水平导航条实例</h3><p>创建一个水平导航条，在鼠标移动到选项后修改背景颜色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span> {</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">14px</span> <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*鼠标移动到选项上修改背景颜色 */</span></span><br><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#111</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="链接右对齐"><a href="#链接右对齐" class="headerlink" title="链接右对齐"></a>链接右对齐</h3><p>将导航条最右边的选项设置右对齐 **(float:right;)**：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#home</span>"&gt;主页&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#news</span>"&gt;新闻&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span>&gt;&lt;<span class="selector-tag">a</span> href="<span class="selector-id">#contact</span>"&gt;联系&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span> style="<span class="attribute">float</span><span class="selector-pseudo">:right</span>"&gt;&lt;<span class="selector-tag">a</span> class="active" href="<span class="selector-id">#about</span>"&gt;关于&lt;/<span class="selector-tag">a</span>&gt;&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">ul</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="添加分割线"><a href="#添加分割线" class="headerlink" title="添加分割线"></a>添加分割线</h3><p>&lt;li&gt; 通过 <strong>border-right</strong> 样式来添加分割线：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 除了最后一个选项(last-child) 其他的都添加分割线 */</span></span><br><span class="line"><span class="selector-tag">li</span> {</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#bbb</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> {</span><br><span class="line">    <span class="attribute">border-right</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="固定导航条"><a href="#固定导航条" class="headerlink" title="固定导航条"></a>固定导航条</h3><p>设置页面的导航条固定在头部或者底部：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> {</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-下拉菜单"><a href="#CSS-下拉菜单" class="headerlink" title="CSS 下拉菜单"></a>CSS 下拉菜单</h2><h3 id="基本下拉菜单"><a href="#基本下拉菜单" class="headerlink" title="基本下拉菜单"></a>基本下拉菜单</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown</span> {</span></span><br><span class="line"><span class="language-css">  <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown-content</span> {</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">min-width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">8px</span> <span class="number">16px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropdown-content</span> {</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>鼠标移动到我这！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>菜鸟教程<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>HTML 部分</strong></p><ul><li><p>可以使用任何的 HTML 元素来打开下拉菜单，如：&lt;span&gt;, 或 a &lt;button&gt; 元素</p></li><li><p>使用容器元素 (如： &lt;div&gt;) 来创建下拉菜单的内容，并放在任何位置上</p></li><li><p>使用 &lt;div&gt; 元素来包裹这些元素，并使用 CSS 来设置下拉内容的样式</p></li></ul></li><li><p><strong>CSS 部分</strong></p><ul><li><code>.dropdown</code> 类使用 <code>position:relative</code>, 这将设置下拉菜单的内容放置在下拉按钮 (使用 <code>position:absolute</code>) 的<strong>右下角</strong>位置</li><li><code>.dropdown-content</code> 类中是实际的下拉菜单。默认是隐藏的，在鼠标移动到指定元素后会显示。如果想设置下拉内容与下拉按钮的宽度一致，可设置 <code>width</code> 为 100% ( <code>overflow:auto</code> 设置可以在小尺寸屏幕上滚动)</li><li>使用 <code>box-shadow</code> 属性让下拉菜单看起来像一个”卡片”</li><li><code>:hover</code> 选择器用于在用户将鼠标移动到下拉按钮上时显示下拉菜单</li></ul></li></ul><h3 id="复杂下拉菜单"><a href="#复杂下拉菜单" class="headerlink" title="复杂下拉菜单"></a>复杂下拉菜单</h3><p>创建下拉菜单，并允许用户选取列表中的某一项：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 下拉按钮样式 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.dropbtn</span> {&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;&nbsp;&nbsp;&nbsp; <span class="attribute">color</span>: white;&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">padding</span>: <span class="number">16px</span>;&nbsp;&nbsp;&nbsp; <span class="attribute">font-size</span>: <span class="number">16px</span>;&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">border</span>: none;&nbsp;&nbsp;&nbsp; <span class="attribute">cursor</span>: pointer;}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 容器 &lt;div&gt; - 需要定位下拉内容 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.dropdown</span> {&nbsp;&nbsp;&nbsp; <span class="attribute">position</span>: relative;&nbsp;&nbsp;&nbsp; <span class="attribute">display</span>: </span></span><br><span class="line"><span class="language-css">inline-block;}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 下拉内容 (默认隐藏) */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown-content</span> {&nbsp;&nbsp;&nbsp; <span class="attribute">display</span>: none;&nbsp;&nbsp;&nbsp; <span class="attribute">position</span>: </span></span><br><span class="line"><span class="language-css">absolute;&nbsp;&nbsp;&nbsp; <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">min-width</span>: <span class="number">160px</span>;&nbsp;&nbsp;&nbsp; <span class="attribute">box-shadow</span>: </span></span><br><span class="line"><span class="language-css"><span class="number">0px</span> <span class="number">8px</span> <span class="number">16px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 下拉菜单的链接 */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown-content</span> <span class="selector-tag">a</span> {&nbsp;&nbsp;&nbsp; <span class="attribute">color</span>: black;&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">16px</span>;&nbsp;&nbsp;&nbsp; <span class="attribute">text-decoration</span>: none;&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">display</span>: block;}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 鼠标移上去后修改下拉菜单链接颜色 */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.dropdown-content</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {<span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 在鼠标移上去后显示下拉菜单 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropdown-content</span> {&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">display</span>: block;}</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 当下拉内容显示后修改下拉按钮的背景颜色 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.dropdown</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.dropbtn</span> {&nbsp;&nbsp;&nbsp; </span></span><br><span class="line"><span class="language-css"><span class="attribute">background-color</span>: <span class="number">#3e8e41</span>;}</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown"</span>&gt;</span>&nbsp; <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"dropbtn"</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&nbsp; </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dropdown-content"</span>&gt;</span>&nbsp;&nbsp;&nbsp; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>菜鸟教程 </span><br><span class="line">1<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&nbsp;&nbsp;&nbsp; </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>菜鸟教程 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&nbsp;&nbsp;&nbsp; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>菜鸟教程 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&nbsp; <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-提示工具"><a href="#CSS-提示工具" class="headerlink" title="CSS 提示工具"></a>CSS 提示工具</h2><p>提示工具在鼠标移动到指定元素后触发。</p><h3 id="基础提示框-Tooltip"><a href="#基础提示框-Tooltip" class="headerlink" title="基础提示框(Tooltip)"></a>基础提示框(Tooltip)</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="comment">/* Tooltip 容器 */</span></span><br><span class="line"><span class="selector-class">.tooltip</span> {</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted black; <span class="comment">/* 悬停元素上显示点线 */</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Tooltip 文本 */</span></span><br><span class="line"><span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span> {</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 定位 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 鼠标移动上去后显示提示框 */</span></span><br><span class="line"><span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.tooltiptext</span> {</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">}&lt;/style&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class="tooltip"&gt;鼠标移动到这</span><br><span class="line">  &lt;<span class="selector-tag">span</span> class="tooltiptext"&gt;提示文本&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>HTML部分</strong></p><ul><li>使用容器元素 (如 &lt;div&gt;) 并添加 <strong>“tooltip”</strong> 类。在鼠标移动到 &lt;div&gt; 上时显示提示信息</li><li>提示文本放在内联元素上(如 &lt;span&gt;) 并使用<strong>class=”tooltiptext”</strong></li></ul></li><li><p><strong>CSS部分</strong></p><ul><li><strong>tooltip</strong> 类使用 <strong>position:relative</strong>, 提示文本需要设置定位值 <strong>position:absolute</strong></li><li><strong>tooltiptext</strong> 类用于实际的提示文本，模式是隐藏的，在鼠标移动到元素显示，设置了一些宽度、背景色、字体色等样式</li><li>CSS3 <strong>border-radius</strong> 属性用于为提示框添加圆角</li><li><strong>:hover</strong> 选择器用于在鼠标移动到到指定元素 &lt;div&gt; 上时显示的提示</li></ul></li></ul><h3 id="定位提示工具"><a href="#定位提示工具" class="headerlink" title="定位提示工具"></a>定位提示工具</h3><p>提示工具显示在指定元素的右侧(<strong>left:105%</strong>) :</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span> {</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">105%</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>top:-5px</strong> 同于定位在容器元素的中间。使用数字 <strong>5</strong> 因为提示文本的顶部和底部的内边距（padding）是 5px。如果修改 padding 的值，top 值也要对应修改，这样才可以确保它是居中对齐的。</p><h3 id="添加箭头"><a href="#添加箭头" class="headerlink" title="添加箭头"></a>添加箭头</h3><p>以用CSS 伪元素 <strong>::after</strong> 及 <strong>content</strong> 属性为提示工具创建一个小箭头标志，箭头是由边框组成的，但组合起来后提示工具像个语音信息框：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span><span class="selector-pseudo">::after</span> {</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100%</span>; <span class="comment">/* 提示工具底部 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: black transparent transparent transparent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="淡入效果"><a href="#淡入效果" class="headerlink" title="淡入效果"></a>淡入效果</h3><p>可以使用 CSS3 <strong>transition</strong> 属性及 <strong>opacity</strong> 属性来实现提示工具的淡入效果：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tooltip</span> <span class="selector-class">.tooltiptext</span> {</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: opacity <span class="number">1s</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.tooltiptext</span> {</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-图片透明"><a href="#CSS-图片透明" class="headerlink" title="CSS 图片透明"></a>CSS 图片透明</h2><h3 id="创建一个透明图像"><a href="#创建一个透明图像" class="headerlink" title="创建一个透明图像"></a>创建一个透明图像</h3><p>CSS3中属性的透明度是 <strong>opacity</strong>。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.4</span>;</span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">40</span>); <span class="comment">/* IE8 及其更早版本 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="悬停效果"><a href="#悬停效果" class="headerlink" title="悬停效果"></a>悬停效果</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.4</span>;</span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">40</span>); <span class="comment">/*  IE8 及其更早版本 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">1.0</span>;</span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">100</span>); <span class="comment">/* IE8 及其更早版本 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="透明的盒子中的文字"><a href="#透明的盒子中的文字" class="headerlink" title="透明的盒子中的文字"></a>透明的盒子中的文字</h3><ol><li>首先，创建一个固定的高度和宽度的div元素，带有一个背景图片和边框；</li><li>然后在第一个div内部创建一个较小的div元素。 这个div也有一个固定的宽度，背景颜色，边框，而且它是透明的；</li><li>在透明的div里面，在P元素内部添加一些文本。</li></ol><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset="utf-<span class="number">8</span>"&gt;</span><br><span class="line">&lt;style&gt;<span class="selector-tag">div</span><span class="selector-class">.background</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">https://www.runoob.com/images/klematis.jpg</span>) repeat;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid black;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">180px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">30px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">opacity</span>:<span class="number">0.6</span>;</span><br><span class="line">  <span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">60</span>); <span class="comment">/* IE8 及更早版本 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.transbox</span> <span class="selector-tag">p</span></span><br><span class="line">{</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>:bold;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#000000</span>;</span><br><span class="line">}&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class="<span class="attribute">background</span>"&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class="transbox"&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。这些文本在透明框里。</span><br><span class="line">&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="CSS-图像拼合"><a href="#CSS-图像拼合" class="headerlink" title="CSS 图像拼合"></a>CSS 图像拼合</h3><p>图像拼合就是单个图像的集合。</p><p>有许多图像的网页可能需要很长的时间来加载和生成多个服务器的请求。</p><p>使用图像拼合会降低服务器的请求数量，并节省带宽。</p><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>在下面的例子CSS指定显示 “img_navsprites.gif” 的图像的一部分：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-class">.home</span></span><br><span class="line">{</span><br><span class="line"><span class="attribute">width</span>:<span class="number">46px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">44px</span>;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">img_navsprites.gif</span>) <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>&lt;img class=”home” src=”img_trans.gif” /&gt; -因为不能为空，src属性只定义了一个小的透明图像。显示的图像将是我们在CSS中指定的背景图像</li><li>宽度：46px;高度：44px; - 定义我们使用的那部分图像</li><li>background:url(img_navsprites.gif) 0 0; - 定义背景图像和它的位置（左0px，顶部0px）</li></ul><h3 id="创建一个导航列表"><a href="#创建一个导航列表" class="headerlink" title="创建一个导航列表"></a>创建一个导航列表</h3><p>使用拼合图像 (“img_navsprites.gif”)，以创建一个导航列表。</p><p>使用一个HTML列表，因为它可以链接，同时还支持背景图像：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#navlist</span>{<span class="attribute">position</span>:relative;}// 位置设置相对定位，让里面的绝对定位</span><br><span class="line"><span class="selector-id">#navlist</span> <span class="selector-tag">li</span>{<span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>:<span class="number">0</span>;list-style:none;<span class="attribute">position</span>:absolute;<span class="attribute">top</span>:<span class="number">0</span>;}// <span class="attribute">margin</span>和<span class="attribute">padding</span>设置为<span class="number">0</span>，列表样式被删除，所有列表项是绝对定位</span><br><span class="line"><span class="selector-id">#navlist</span> <span class="selector-tag">li</span>, <span class="selector-id">#navlist</span> <span class="selector-tag">a</span>{<span class="attribute">height</span>:<span class="number">44px</span>;<span class="attribute">display</span>:block;}// 所有图像的高度是<span class="number">44px</span></span><br><span class="line"><span class="selector-id">#home</span>{<span class="attribute">left</span>:<span class="number">0px</span>;<span class="attribute">width</span>:<span class="number">46px</span>;}// 定位到最左边的方式，以及图像的宽度是<span class="number">46px</span></span><br><span class="line"><span class="selector-id">#home</span>{<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'img_navsprites.gif'</span>) <span class="number">0</span> <span class="number">0</span>;}// 定义背景图像和它的位置（左<span class="number">0px</span>，顶部<span class="number">0px</span>）</span><br><span class="line"><span class="selector-id">#prev</span>{<span class="attribute">left</span>:<span class="number">63px</span>;<span class="attribute">width</span>:<span class="number">43px</span>;}// 右侧定位<span class="number">63px</span>，宽度为<span class="number">43px</span></span><br><span class="line"><span class="selector-id">#prev</span>{<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'img_navsprites.gif'</span>) -<span class="number">47px</span> <span class="number">0</span>;}// 定义背景图像右侧<span class="number">47px</span></span><br><span class="line"><span class="selector-id">#next</span>{<span class="attribute">left</span>:<span class="number">129px</span>;<span class="attribute">width</span>:<span class="number">43px</span>;}// 右边定位<span class="number">129px</span>, 宽度是<span class="number">43px</span></span><br><span class="line"><span class="selector-id">#next</span>{<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'img_navsprites.gif'</span>) -<span class="number">91px</span> <span class="number">0</span>;}// 定义背景图像右边<span class="number">91px</span></span><br></pre></td></tr></tbody></table></figure><h3 id="悬停效果-1"><a href="#悬停效果-1" class="headerlink" title="悬停效果"></a>悬停效果</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>{<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'img_navsprites_hover.gif'</span>) <span class="number">0</span> -<span class="number">45px</span>;}</span><br><span class="line"><span class="selector-id">#prev</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>{<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'img_navsprites_hover.gif'</span>) -<span class="number">47px</span> </span><br><span class="line">-<span class="number">45px</span>;}</span><br><span class="line"><span class="selector-id">#next</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>{<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'img_navsprites_hover.gif'</span>) -<span class="number">91px</span> </span><br><span class="line">-<span class="number">45px</span>;}</span><br></pre></td></tr></tbody></table></figure><ul><li>由于该列表项包含一个链接，可以使用：hover伪类</li><li>#home a:hover{background: transparent url(img_navsprites_hover.gif) 0 -45px;} - 对于所有三个悬停图像，指定相同的背景位置，只是每个再向下45px</li></ul><h2 id="CSS-媒体类型"><a href="#CSS-媒体类型" class="headerlink" title="CSS 媒体类型"></a>CSS 媒体类型</h2><p>媒体类型可以指定文件将<strong>如何在不同媒体呈现</strong>。该文件可以以不同的方式显示在屏幕上，在纸张上，或听觉浏览器等等。</p><h3 id="media-规则"><a href="#media-规则" class="headerlink" title="@media 规则"></a>@media 规则</h3><p>@media 规则允许在相同样式表为不同媒体设置不同的样式。</p><p>在浏览器屏幕上显示一个 14 像素的 Verdana 字体样式，但是如果页面打印，将是 10 个像素的 Times 字体。font-weight 在屏幕上和纸上设置为粗体：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@media screen</span><br><span class="line">{</span><br><span class="line">    p.test {font-family:verdana,sans-serif;font-size:14px;}</span><br><span class="line">}</span><br><span class="line">@media print</span><br><span class="line">{</span><br><span class="line">    p.test {font-family:times,serif;font-size:10px;}</span><br><span class="line">}</span><br><span class="line">@media screen,print</span><br><span class="line">{</span><br><span class="line">    p.test {font-weight:bold;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他媒体类型"><a href="#其他媒体类型" class="headerlink" title="其他媒体类型"></a>其他媒体类型</h3><table><thead><tr><th align="left">媒体类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">all</td><td align="left">用于所有的媒体设备。</td></tr><tr><td align="left">aural</td><td align="left">用于语音和音频合成器。</td></tr><tr><td align="left">braille</td><td align="left">用于盲人用点字法触觉回馈设备。</td></tr><tr><td align="left">embossed</td><td align="left">用于分页的盲人用点字法打印机。</td></tr><tr><td align="left">handheld</td><td align="left">用于小的手持的设备。</td></tr><tr><td align="left">print</td><td align="left">用于打印机。</td></tr><tr><td align="left">projection</td><td align="left">用于方案展示，比如幻灯片。</td></tr><tr><td align="left">screen</td><td align="left">用于电脑显示器。</td></tr><tr><td align="left">tty</td><td align="left">用于使用固定密度字母栅格的媒体，比如电传打字机和终端。</td></tr><tr><td align="left">tv</td><td align="left">用于电视机类型的设备。</td></tr></tbody></table><h2 id="CSS-属性选择器"><a href="#CSS-属性选择器" class="headerlink" title="CSS 属性选择器"></a>CSS 属性选择器</h2><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>把包含标题（title）的所有元素变为蓝色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title]</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="属性和值选择器"><a href="#属性和值选择器" class="headerlink" title="属性和值选择器"></a>属性和值选择器</h3><p>改变标题title=’runoob’元素的边框样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title=runoob]</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">5px</span> solid green;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="多值"><a href="#多值" class="headerlink" title="多值"></a>多值</h3><p>指定值的title属性的元素样式的例子，使用（~）分隔属性和值：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[title~=hello]</span> { <span class="attribute">color</span>:blue; }</span><br></pre></td></tr></tbody></table></figure><p>指定值的lang属性的元素样式的例子，使用（|）分隔属性和值：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[lang|=en]</span> { <span class="attribute">color</span>:blue; }</span><br></pre></td></tr></tbody></table></figure><h3 id="表单样式"><a href="#表单样式" class="headerlink" title="表单样式"></a>表单样式</h3><p>属性选择器样式无需使用class或id的形式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"text"</span>]</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:yellow;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"button"</span>]</span></span><br><span class="line">{</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-表单"><a href="#CSS-表单" class="headerlink" title="CSS 表单"></a>CSS 表单</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span>, select {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">14px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#45a049</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入框-input-样式"><a href="#输入框-input-样式" class="headerlink" title="输入框(input) 样式"></a>输入框(input) 样式</h3><p>使用 width 属性来设置输入框的宽度：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果只想设置指定类型的输入框可以使用以下属性选择器：</p><ul><li><code>input[type=text]</code> - 选取文本输入框</li><li><code>input[type=password]</code> - 选择密码的输入框</li><li><code>input[type=number]</code> - 选择数字的输入框</li></ul><h3 id="输入框填充"><a href="#输入框填充" class="headerlink" title="输入框填充"></a>输入框填充</h3><p>使用 <strong>padding</strong> 属性可以在输入框中添加内边距：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;// 确保浏览器呈现出带有指定宽度和高度的输入框是把边框和内边距一起计算进去的</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入框-input-边框"><a href="#输入框-input-边框" class="headerlink" title="输入框(input) 边框"></a>输入框(input) 边框</h3><p>使用 <strong>border</strong> 属性可以修改 input 边框的大小或颜色，使用 <strong>border-radius</strong> 属性可以给 input 添加圆角：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>只想添加底部边框可以使用 <strong>border-bottom</strong> 属性:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid red;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入框-input-颜色"><a href="#输入框-input-颜色" class="headerlink" title="输入框(input) 颜色"></a>输入框(input) 颜色</h3><p>可以使用 <strong>background-color</strong>属性来设置输入框的背景颜色，<strong>color</strong> 属性用于修改文本颜色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#3CBC8D</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入框-input-聚焦"><a href="#输入框-input-聚焦" class="headerlink" title="输入框(input) 聚焦"></a>输入框(input) 聚焦</h3><p>使用 :<strong>focus</strong>选择器可以设置输入框在获取焦点时的样式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span> {</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#555</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="输入框-input-图标"><a href="#输入框-input-图标" class="headerlink" title="输入框(input) 图标"></a>输入框(input) 图标</h3><p>可以使用 <strong>background-image</strong> 属性和用于定位的<strong>background-position</strong> 属性：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'searchicon.png'</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">10px</span> <span class="number">10px</span>; </span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="带动画的搜索框"><a href="#带动画的搜索框" class="headerlink" title="带动画的搜索框"></a>带动画的搜索框</h3><p>使用  <strong>transition</strong> 属性设置输入框在获取焦点时会向右延展。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span> {</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: width <span class="number">0.4s</span> ease-in-out;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">0.4s</span> ease-in-out;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文本框（textarea）样式"><a href="#文本框（textarea）样式" class="headerlink" title="文本框（textarea）样式"></a>文本框（textarea）样式</h3><p>使用 <strong>resize</strong> 属性来禁用文本框可以重置大小的功能（一般拖动右下脚可以重置大小）：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f8f8f8</span>;</span><br><span class="line">  <span class="attribute">resize</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="下拉菜单（select）样式"><a href="#下拉菜单（select）样式" class="headerlink" title="下拉菜单（select）样式"></a>下拉菜单（select）样式</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="按钮样式"><a href="#按钮样式" class="headerlink" title="按钮样式"></a>按钮样式</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=button]</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=reset]</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span> <span class="number">32px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">4px</span> <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 提示: 使用 width: 100% 设置全宽按钮 */</span></span><br></pre></td></tr></tbody></table></figure><h3 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h3><p>响应式表单可以根据浏览器窗口的大小重新布局各个元素，可以通过重置浏览器窗口大小来查看效果：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">* {</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span>, select, <span class="selector-tag">textarea</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">resize</span>: vertical;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">label</span> {</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">12px</span> <span class="number">12px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4CAF50</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#45a049</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.container</span> {</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.col-25</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">6px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.col-75</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">6px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 清除浮动 */</span></span><br><span class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 响应式布局 layout - 在屏幕宽度小于 600px 时， 设置为上下堆叠元素 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) {</span><br><span class="line">  <span class="selector-class">.col-25</span>, <span class="selector-class">.col-75</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=submit]</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-计数器"><a href="#CSS-计数器" class="headerlink" title="CSS 计数器"></a>CSS 计数器</h2><h3 id="使用计数器自动编号"><a href="#使用计数器自动编号" class="headerlink" title="使用计数器自动编号"></a>使用计数器自动编号</h3><p>计数器根据规则来递增变量。使用到以下几个属性：</p><ul><li><code>counter-reset</code> - 创建或者重置计数器</li><li><code>counter-increment</code> - 递增变量</li><li><code>content</code> - 插入生成的内容</li><li><code>counter()</code> 或 <code>counters()</code> 函数 - 将计数器的值添加到元素</li></ul><p>在页面创建一个计数器 (在 body 选择器中)，每个 &lt;h2&gt; 元素的计数值都会递增，并在每个 &lt;h2&gt; 元素前添加 “Section &lt;计数值&gt;:”</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">counter-reset</span>: section;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">counter-increment</span>: section;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"Section "</span> <span class="built_in">counter</span>(section) <span class="string">": "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="嵌套计数器"><a href="#嵌套计数器" class="headerlink" title="嵌套计数器"></a>嵌套计数器</h3><p>在页面创建一个计数器，在每一个 &lt;h1&gt; 元素前添加计数值 “Section &lt;主标题计数值&gt;.”, 嵌套的计数值则放在 &lt;h2&gt; 元素的前面，内容为 “&lt;主标题计数值&gt;.&lt;副标题计数值&gt;”:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">counter-reset</span>: section;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">h1</span> {</span><br><span class="line">  <span class="attribute">counter-reset</span>: subsection;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">counter-increment</span>: section;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"Section "</span> <span class="built_in">counter</span>(section) <span class="string">". "</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">counter-increment</span>: subsection;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(section) <span class="string">"."</span> <span class="built_in">counter</span>(subsection) <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-网页布局"><a href="#CSS-网页布局" class="headerlink" title="CSS 网页布局"></a>CSS 网页布局</h2><p>一般分为以下几个部分：<strong>头部区域、菜单导航区域、内容区域、底部区域</strong>。</p><h3 id="头部区域"><a href="#头部区域" class="headerlink" title="头部区域"></a>头部区域</h3><p>一般用于设置网页的标题或者网页的 logo：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F1F1F1</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="菜单导航区域"><a href="#菜单导航区域" class="headerlink" title="菜单导航区域"></a>菜单导航区域</h3><p>菜单导航条包含了一些链接，可以引导用户浏览其他页面：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 导航条 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> {</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 导航链接 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> <span class="selector-tag">a</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">14px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 链接 - 修改颜色 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="内容区域"><a href="#内容区域" class="headerlink" title="内容区域"></a>内容区域</h3><p>内容区域一般有三种形式:</p><ul><li><strong>1 列</strong>：一般用于移动端</li><li><strong>2 列</strong>：一般用于平板设备</li><li><strong>3 列</strong>：一般用于 PC 桌面设备</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2019/04/D105F34E-6592-47AC-A9DF-EEDC1E2172B3.jpg"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建三个相等的列 */</span></span><br><span class="line"><span class="selector-class">.column</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">33.33%</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 列后清除浮动 */</span></span><br><span class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 响应式布局 - 小于 600 px 时改为上下布局 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) {</span><br><span class="line">  <span class="selector-class">.column</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>不相等的列</strong>一般是在中间部分设置内容区域，这块也是最大最主要的，左右两次侧可以作为一些导航等相关内容，这三列加起来的宽度是 100％。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.column</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 左右侧栏的宽度 */</span></span><br><span class="line"><span class="selector-class">.column</span><span class="selector-class">.side</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 中间列宽度 */</span></span><br><span class="line"><span class="selector-class">.column</span><span class="selector-class">.middle</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 响应式布局 - 宽度小于600px时设置上下布局 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) {</span><br><span class="line">  <span class="selector-class">.column</span><span class="selector-class">.side</span>, <span class="selector-class">.column</span><span class="selector-class">.middle</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="底部区域"><a href="#底部区域" class="headerlink" title="底部区域"></a>底部区域</h3><p>底部区域在网页的最下方，一般包含版权信息和联系方式等。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footer</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F1F1F1</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="响应式网页布局"><a href="#响应式网页布局" class="headerlink" title="响应式网页布局"></a>响应式网页布局</h3><p>创建一个响应式等页面，页面的布局会根据屏幕的大小来调整：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">* {</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">font-family</span>: Arial;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 头部标题 */</span></span><br><span class="line"><span class="selector-class">.header</span> {</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">h1</span> {</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 导航条 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> {</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 导航条链接 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> <span class="selector-tag">a</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">14px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 链接颜色修改 */</span></span><br><span class="line"><span class="selector-class">.topnav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 创建两列 */</span></span><br><span class="line"><span class="comment">/* Left column */</span></span><br><span class="line"><span class="selector-class">.leftcolumn</span> {   </span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 右侧栏 */</span></span><br><span class="line"><span class="selector-class">.rightcolumn</span> {</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 图像部分 */</span></span><br><span class="line"><span class="selector-class">.fakeimg</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 文章卡片效果 */</span></span><br><span class="line"><span class="selector-class">.card</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 列后面清除浮动 */</span></span><br><span class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 底部 */</span></span><br><span class="line"><span class="selector-class">.footer</span> {</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 响应式布局 - 屏幕尺寸小于 800px 时，两列布局改为上下布局 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) {</span><br><span class="line">  <span class="selector-class">.leftcolumn</span>, <span class="selector-class">.rightcolumn</span> {   </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 响应式布局 -屏幕尺寸小于 400px 时，导航等布局改为上下布局 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">400px</span>) {</span><br><span class="line">  <span class="selector-class">.topnav</span> <span class="selector-tag">a</span> {</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-important-规则"><a href="#CSS-important-规则" class="headerlink" title="CSS !important 规则"></a>CSS !important 规则</h2><h3 id="什么是-important"><a href="#什么是-important" class="headerlink" title="什么是 !important"></a>什么是 !important</h3><p><strong>!important</strong> 规则用于增加样式的权重。其与优先级无关，但它与最终的结果直接相关，使用一个 !important 规则时，此声明将覆盖任何其他声明。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#myid</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.myclass</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">p</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: red <span class="meta">!important</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三个段落背景颜色都显示为红色，因为 !important 规则会覆盖 background-color 属性。</p><h3 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h3><p>应该尽量避免使用!important 规则，因为这破坏了样式表中的固有的级联规则，使得调试找 bug 变得更加困难。</p><p>当两条相互冲突的带有 !important 规则的声明被应用到相同的元素上时，<strong>拥有更大优先级的声明将会被采用。</strong></p><ul><li><strong>一定</strong>要<strong>优先考虑使用样式规则的优先级</strong>来解决问题而不是 <code>!important</code></li><li><strong>只有</strong>在需要<strong>覆盖全站或外部 CSS 的特定页面</strong>中使用 <code>!important</code></li><li><strong>永远不要</strong>在你的<strong>插件</strong>中使用 <code>!important</code></li><li><strong>永远不要</strong>在<strong>全站范围</strong>的 CSS 代码中使用 <code>!important</code></li></ul><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>如果要在网站上设定一个<strong>全站样式的 CSS 样式</strong>可以使用 !important。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#8c8c8c</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">color</span>: white <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black <span class="meta">!important</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="selector-id">#myDiv</span> <span class="selector-tag">a</span> {</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第四章读书笔记</title>
      <link href="/2023/11/28/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-si-zhang-du-shu-bi-ji/"/>
      <url>/2023/11/28/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-si-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h2><p>本章以如何将a.c文件与b.c文件链接成一个可执行文件来探讨如何进行<strong>静态链接</strong><br><strong>a.c文件</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    swap(&amp;a,&amp;shared);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>b.c文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span><br><span class="line">{</span><br><span class="line">    *a ^= *b ^= *a ^= *b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>首先将他们编译成目标文件“a.o”和“b.o”</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c a.c b.c</span><br></pre></td></tr></tbody></table></figure><ul><li>b.c中定义了两个全局符号：变量shared和函数swap()；</li><li>a.c中定义了一个全局符号main；</li><li>a.c引入了b.c中的shared和swap。</li></ul><p>接下来把a.o和b.o两个目标文件链接成一个可执行文件ab。</p><h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><p>对于多个输入目标文件，链接器如何将它们的各个段合并到一个输出文件？</p><p><strong>”链接器为目标文件分配地址和空间“</strong>：这里既指在输出的可执行文件中的空间、也指装载后的虚拟地址的空间。<strong>但对.bss段来说只限于后者。</strong></p><h3 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h3><p>直接将各个目标文件依次合并。</p><p><img src="https://gcdnb.pbrd.co/images/Mhf63uIyX4Xv.png?o=1" alt="ABC三个目标文件按序叠加"></p><p>由于地址和空间对齐的关系，会<strong>造成内存空间大量的碎片</strong>。段的装载地址与空间的对其单位是页（4096字节），如果一个段只有1个字节，也要在内存中占用4096字节。</p><h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p>相同性质的段合并到一起。</p><p><img src="https://gcdnb.pbrd.co/images/vz9apxJBR653.png?o=1"></p><p>一般采用<strong>两步链接法</strong>（Two-pass Linking）：</p><ol><li><p><strong>空间与地址分配</strong><br>扫描所有输入文件，并获得它们各个段的<strong>长度、属性和位置</strong>；将它们符号表中所有的符号定义和符号引用收集起来，统一放到一个<strong>全局符号表</strong>中。</p></li><li><p><strong>符号解析与重定位</strong></p><p>利用上一步获得的信息，读取输入文件中段的数据、重定位信息，并进行<strong>符号解析和重定位</strong>。</p><p>使用<strong>ld</strong>链接器，将目标文件链接起来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ld a.o b.o -e main -o ab</span><br></pre></td></tr></tbody></table></figure><ul><li>ld链接器默认程序入口是_start，**-e main** 表示将main函数作为程序的入口。</li><li><strong>-o ab</strong> 表示链接输出文件名是ab。</li></ul><p>使用<strong>odjdump -h</strong>命令分别查看a.o/b.o/ab可以发现链接前后地址分配VMA的变化：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -h a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000027  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000067  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000067  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002e  0000000000000000  0000000000000000  00000067  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000095  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  00000098  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -h b.o</span></span><br><span class="line"></span><br><span class="line">b.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000004a  0000000000000000  0000000000000000  00000040  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000004  0000000000000000  0000000000000000  0000008c  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .comment      0000002e  0000000000000000  0000000000000000  00000090  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000be  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .eh_frame     00000038  0000000000000000  0000000000000000  000000c0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -h ab</span></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000071  00000000004000e8  00000000004000e8  000000e8  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .eh_frame     00000058  0000000000400160  0000000000400160  00000160  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .data         00000004  0000000000601000  0000000000601000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .comment      0000002d  0000000000000000  0000000000000000  00001004  2**0</span><br></pre></td></tr></tbody></table></figure><p>可以看出，链接后.text的长度=两个目标文件中.text的长度之和；</p><p><strong>链接前所有的VMA都是0，因为他们还未被分配虚拟地址空间，默认为0。</strong></p><p><img src="https://gcdnb.pbrd.co/images/JpsHC5Ri7IKo.png?o=1"></p><p><strong>在Linux下，ELF可执行文件默认从地址0x08048000开始分配。</strong></p></li></ol><h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>链接器首先根据前面的空间分配方法，对各个段的虚拟地址进行确定。如.text段的起始位置是：0x4000e8，.data段的起始位置是：0x6001b8。然后根据各个符号在段内的偏移，确定其真正的虚拟地址，只需对段的基址加上偏移量即可。</p><p><img src="https://gcdnb.pbrd.co/images/Z87aqTb4zYuB.png?o=1"></p><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>使用<strong>objdump -d a.o</strong> 查看a.o文件的反汇编结果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -d a.o</span></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 83 ec 10             sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">   8:   c7 45 <span class="built_in">fc</span> 64 00 00 00    movl   <span class="variable">$0x64</span>,-0x4(%rbp)</span><br><span class="line">   f:   48 8d 45 <span class="built_in">fc</span>             lea    -0x4(%rbp),%rax</span><br><span class="line">  13:   be 00 00 00 00          mov    <span class="variable">$0x0</span>,%esi</span><br><span class="line">  18:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  1b:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  20:   e8 00 00 00 00          callq  25 &lt;main+0x25&gt;</span><br><span class="line">  25:   c9                      leaveq </span><br><span class="line">  26:   c3                      retq  </span><br></pre></td></tr></tbody></table></figure><ul><li><strong>a.o文件中对shared的引用为偏移为0x13的位置：</strong>be 00 00 00 00<br>它的作用是将shared的地址赋值到<strong>esi寄存器</strong>中，该指令一共5个字节，第1个字节是指令码，后4个字节是shared的地址。由于源码在编译时，编译器不知道shared的地址，因此<strong>把0作为它们的地址</strong>。</li><li><strong>a.o文件中对swap的引用为偏移为0x20的位置</strong>：e8 00 00 00 00<br>该指令一共5个字节，前面的0xe8是操作码。根据Intel的IA-32体系软件开发者手册，这是一条<strong>近址相对位移调用指令</strong>。后面4个字节是被调用的函数相对调用指令的下一条指令的偏移量。</li></ul><p>编译器把这两条指令的地址用“00 00 00 00”代替，把真正的地址计算工作留给了链接器，链接器可以根据符号的地址对每个需要重定位的指令进行修正。</p><p>使用<strong>objdump -d ab</strong>命令查看ab的反汇编代码：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -d ab</span></span><br><span class="line"></span><br><span class="line">ab:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000004000e8 &lt;main&gt;:</span><br><span class="line">  4000e8:       55                      push   %rbp</span><br><span class="line">  4000e9:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  4000ec:       48 83 ec 10             sub    <span class="variable">$0x10</span>,%rsp</span><br><span class="line">  4000f0:       c7 45 <span class="built_in">fc</span> 64 00 00 00    movl   <span class="variable">$0x64</span>,-0x4(%rbp)</span><br><span class="line">  4000f7:       48 8d 45 <span class="built_in">fc</span>             lea    -0x4(%rbp),%rax</span><br><span class="line">  4000fb:       be 00 10 60 00          mov    <span class="variable">$0x601000</span>,%esi</span><br><span class="line">  400100:       48 89 c7                mov    %rax,%rdi</span><br><span class="line">  400103:       b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  400108:       e8 02 00 00 00          callq  40010f &lt;swap&gt;</span><br><span class="line">  40010d:       c9                      leaveq </span><br><span class="line">  40010e:       c3                      retq   </span><br><span class="line"></span><br><span class="line">000000000040010f &lt;swap&gt;:</span><br><span class="line">  40010f:       55                      push   %rbp</span><br><span class="line">  400110:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  400113:       48 89 7d f8             mov    %rdi,-0x8(%rbp)</span><br><span class="line">  400117:       48 89 75 f0             mov    %rsi,-0x10(%rbp)</span><br><span class="line">  40011b:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">  40011f:       8b 10                   mov    (%rax),%edx</span><br><span class="line">  400121:       48 8b 45 f0             mov    -0x10(%rbp),%rax</span><br><span class="line">  400125:       8b 08                   mov    (%rax),%ecx</span><br><span class="line">  400127:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">  40012b:       8b 30                   mov    (%rax),%esi</span><br><span class="line">  40012d:       48 8b 45 f0             mov    -0x10(%rbp),%rax</span><br><span class="line">  400131:       8b 00                   mov    (%rax),%eax</span><br><span class="line">  400133:       31 c6                   xor    %eax,%esi</span><br><span class="line">  400135:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">  400139:       89 30                   mov    %esi,(%rax)</span><br><span class="line">  40013b:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">  40013f:       8b 00                   mov    (%rax),%eax</span><br><span class="line">  400141:       31 c1                   xor    %eax,%ecx</span><br><span class="line">  400143:       48 8b 45 f0             mov    -0x10(%rbp),%rax</span><br><span class="line">  400147:       89 08                   mov    %ecx,(%rax)</span><br><span class="line">  400149:       48 8b 45 f0             mov    -0x10(%rbp),%rax</span><br><span class="line">  40014d:       8b 00                   mov    (%rax),%eax</span><br><span class="line">  40014f:       31 c2                   xor    %eax,%edx</span><br><span class="line">  400151:       48 8b 45 f8             mov    -0x8(%rbp),%rax</span><br><span class="line">  400155:       89 10                   mov    %edx,(%rax)</span><br><span class="line">  400157:       5d                      pop    %rbp</span><br><span class="line">  400158:       c3                      retq  </span><br></pre></td></tr></tbody></table></figure><p>​发现shared的地址变为0x6001b8，而swap函数的地址为0x40010d+0x7 = 0x400114。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>重定位表用来保存与重定位相关的信息。<strong>每个要被重定位的ELF段都有一个重定位表</strong>。一个重定位表往往是ELF文件中的一个段。如代码段“.text”有要被重定位的地方，那么就有’.ref.text’的段保存了代码段的重定位表。</p><p>使用<strong>objdump -r a.o</strong> 查看a.o文件的重定位表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># objdump -r a.o</span></span><br><span class="line"></span><br><span class="line">a.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000014 R_X86_64_32       shared</span><br><span class="line">0000000000000021 R_X86_64_PC32     swap-0x0000000000000004</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.eh_frame]:</span><br><span class="line">OFFSET           TYPE              VALUE </span><br><span class="line">0000000000000020 R_X86_64_PC32     .text</span><br></pre></td></tr></tbody></table></figure><p>每个要被重定位的地方叫一个<strong>重定位入口</strong>。重定位入口的偏移表示该入口在要被重定位段中的位置。根据前面的反汇编结果，这里的0x14和0x21分别是代码段中shared和swap的地址所在的位置。</p><p>对于32位的Intel x86系列处理器来说，重定位表是一个<strong>Elf32_Rel</strong>结构的数组，每个数组元素对应一个重定位入口。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">Elf32_Addr r_offset; <span class="comment">//重定位入口的偏移。</span></span><br><span class="line">Elf32_Word r_info; <span class="comment">//重定位入口的类型和符号。</span></span><br><span class="line">}Elf32_Rel;</span><br></pre></td></tr></tbody></table></figure><ul><li>r_offset：对可重定位文件来说，是该重定位入口所要修正的位置的第一个字节相对于段起始地偏移。</li><li>r_info：低8位表示重定位入口的类型；高24位表示重定位入口的符号在符号表中的下标。</li></ul><h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>使用<strong>readelf -s a.o</strong>查看a.o的符号表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ Chapter4]<span class="comment"># readelf -s a.o</span></span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">'.symtab'</span> contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     8: 0000000000000000    39 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared</span><br><span class="line">    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap</span><br></pre></td></tr></tbody></table></figure><p>每个重定位的入口都是对一个符号的引用，链接器会去查找所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。</p><p>“shared”和“swap”类型都是UND类型，这种未定义符号都是因为该目标文件中有关于它们的重定位项，链接器在扫描完所有输入目标文件后，所有的这些未定义符号应该能在全局符号表中找到，否则链接器报符号未定义错误。</p><h3 id="指令修正方式"><a href="#指令修正方式" class="headerlink" title="指令修正方式"></a>指令修正方式</h3><p>不同处理器指令对地址的格式和方式都不一样。寻址方式有多种，如：</p><ul><li>近址寻址或远址寻址；</li><li>绝对寻址或相对寻址；</li><li>寻址长度有8、16、32、64位等区别。</li></ul><p>但对于32位x86平台的ELF文件的重定位入口所修正的指令寻址方式，只有两种；</p><ul><li>绝对近址32位寻址；</li><li>相对近址32位寻址。</li></ul><p>重定位入口的r_info成员低8位表示重定位入口类型，如表所示：</p><p><img src="https://gcdnb.pbrd.co/images/D3E8tdIs7e2g.png?o=1"></p><p>其中，A=保存在被修正位置的值；P=被修正的位置（相对于段开始的偏移量或虚拟地址，可以通过r_offset计算得到）；S=符号的实际地址（r_info的高24位）</p><p><strong>绝对寻址修正后的地址为该符号的实际地址，相对寻址修正后的地址为符号距离被修正位置的地址差。</strong></p><h2 id="COMMON块"><a href="#COMMON块" class="headerlink" title="COMMON块"></a>COMMON块</h2><p>由于弱符号机制允许同一个符号的定义存在多个文件中。但是如果一个弱符号定义在多个目标文件中，它们的类型又不同。而连接器本身并不支持符号的类型辨别，那么链接器该如何处理呢？</p><p>考虑到三种情况：<br>（1）两个或两个以上强符号不一致；<br>（2）有一个强符号，其他都是弱符号，出现类型不一致；<br>（3）两个或两个以上弱符号类型不一致；</p><p>对于第（1）中情况，无须额外处理，链接器会报符号多重定义错误；链接器处理的是后两种情况。</p><p>事实上，现在的编译器和链接器支持一种叫做<strong>COMMON块</strong>的机制。当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准。COMMON类型的链接规则是针对符号都是弱符号的情况。</p><p>如果其中有一个符号是强符号，则<strong>输出结果中符号所占空间与强符号相同</strong>。如果链接过程又弱符号大小大于强符号，那么ld链接器会报错。</p><p><em>问题：为什么编译器不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理，在.bss段为其分配空间，而是将其标记为一个COMMON类型的变量？</em></p><p><em>回答：当编译器将一个编译单元编译成目标文件时，如果包含弱符号，则其所占空间是未知的，因为有可能在链接到其他文件中也定义了该弱符号，而弱符号以占用空间大的为准，因此无法确定在.bss段为其分配多少空间。而链接时，则大小就能确定了，所以它可以在最终输出文件的.bss段为其分配空间。所以总体来看，<strong>未初始化全局变量还是放在.bss段的</strong>。</em></p><p>GCC的“**-fno-common<strong>”允许把未初始化的全局变量不以COMMON块的形式处理，或者使用“</strong>attribute**”扩展：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global __attribute__((nocommon));</span><br></pre></td></tr></tbody></table></figure><p>一旦一个未初始化的全局变量不以COMMON块的形式存在，它就相当于一个<strong>强符号</strong>。如果其他目标文件中还有一个变量的强符号定义，链接时就会发生符号重复定义错误。</p><h2 id="C-相关问题"><a href="#C-相关问题" class="headerlink" title="C++相关问题"></a>C++相关问题</h2><h3 id="重复代码消除"><a href="#重复代码消除" class="headerlink" title="重复代码消除"></a>重复代码消除</h3><p>C++的语言特性导致它可能会产生大量的重复代码，如模板、虚函数表等。</p><p>以模板为例，一种有效的消除重复代码的手段是：将每个模板的实例代码都<strong>单独地存放在一个段里</strong>，每个段只包含一个模板实例。当不同的编译单元以相同的类型实例化该模板后，也会生成同样的名字，进而链接的时候可以辨别出这些相同的模板实例段，然后进行合并，丢弃重复的段。</p><p>GCC把这种段叫做“.gnu.linkonce.name”，VISUAL C++把这种段叫做“COMDAT”。</p><p><strong>函数级别链接:</strong></p><p> 通常的链接过程都是<strong>文件或者编译单元</strong>级别的链接，但是当只需要使用某个目标为见中的一个函数或变量的时候，就需要全部包含该文件，导致体积很大，编译器为此专门提供了函数级别的链接，与重复代码消除和相似，编译器<strong>将所有函数都像模板函数一样单独保存到一个段中</strong>，需要的时候再将其包含到输出文件，其他的则直接抛弃，这虽然可以产生较小的最终文件的体积，但是由于段的数目增减，减慢了编译和链接的过程。</p><p>GCC使用**-fdata-sections<strong>和</strong>-ffunction-sections**可以将变量或者函数分别保存到独立的段中。</p><h3 id="全局构造与析构"><a href="#全局构造与析构" class="headerlink" title="全局构造与析构"></a>全局构造与析构</h3><p>全局对象的构造在main函数之前执行，全局对象的析构在main函数之后执行。</p><p>Linux下的入口函数是**_star**t，用于在main执行前进行初始化，在main之后执行清理工作。</p><p>ELF文件定义了两种特殊的段：</p><ul><li>.init：该段里面保存的是可执行指令，它构成了进程的初始化代码。当一个程序开始运行时，在main函数被调用之前，Glibc的初始化部分安排执行这个段的中的代码。</li><li>.fini：该段保存着进程终止代码指令。当一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码。<br>可以借助这两个特殊段实现C++的全局构造和析构函数。</li></ul><h3 id="C-与ABI"><a href="#C-与ABI" class="headerlink" title="C++与ABI"></a>C++与ABI</h3><p>两个编译器编译出来的目标文件能够相互连接需要满足这些条件：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同。这些规范统称为<strong>ABI</strong>（Application Binary Interface）</p><p>影响ABI的因素很多，对于<strong>C语言</strong>的目标代码来说，有这几个方面：</p><ul><li>内置类型的大小和在存储器中的放置方式</li><li>组合类型的存储方式和内存方式</li><li>外部符号与用户定义的符号之间的命名方式和解析方式</li><li>函数调用方式</li><li>堆栈的分布方式</li><li>寄存器使用约定</li></ul><p>对于C++来说，更加复杂，需要考虑：</p><ul><li>继承体系的内存分布</li><li>指向成员函数的指针的内存分布，如何通过指向成员函数的指针来调用成员函数，如果传递this指针</li><li>如何调用虚函数，vtable的内容和分布形式，vtable指针在object中的位置等</li><li>template如何实例化</li><li>外部符号的修饰</li><li>全局对象的修饰</li><li>全局对象的构造与析构</li><li>异常的产生和捕获机制</li><li>标准库的细节问题，RTTI如何实现</li><li>内嵌函数访问细节</li></ul><h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><p>程序如何使用操作系统提供的API。在一般情况下，一种语言的开发环境往往会附带语言库。这些库就是对操作系统API的包装。比如printf，就是对write系统调用的封装。库里面还有一些很常用的函数。一个静态库可以简单看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</p><p>glibc由很多源文件组成的，编译完后的目标文件，经过<strong>ar</strong>压缩程序压缩到一起，并且对其编号索引，便于查找和检索，然后就形成了libc.a这个静态库。</p><p>linux下使用<strong>ar -t xx.a</strong>可以查看.a文件中包含的.o文件。在windows平台下可以使用<strong>lib /LIST xx.lib</strong>查看。</p><p>使用<strong>objdump -t xx.a | grep xxx</strong>查找特定的目标文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar -x libc.a// 解压</span><br><span class="line">ld hello.o printf.o// 链接两个目标文件</span><br></pre></td></tr></tbody></table></figure><p>以上代码会报错，因为printf.o中依赖其他目标文件，系统库之间相互交织，相互调用。就算将hello.o和整个libc.a链接，也不一定能形成可执行文件，因为还需要一些其他辅助性质的目标文件和库，具体过程可以通过<strong>gcc -static –verbose -fno-builtin hello.c</strong>将编译链接过程的中间步骤打印出来， 即使写的代码非常简单，这也是一个非常长的依赖关系。</p><h2 id="链接过程控制"><a href="#链接过程控制" class="headerlink" title="链接过程控制"></a>链接过程控制</h2><p>链接器一般都提供多种控制整个链接过程的方法，以用来产生用户所需要的文件。一般链接器有以下三种方法：</p><ul><li>ld命令行指定参数</li><li>目标文件中放置指令</li><li>链接控制脚本</li></ul><h3 id="链接控制脚本"><a href="#链接控制脚本" class="headerlink" title="链接控制脚本"></a>链接控制脚本</h3><p>visual C++把这样的控制脚本叫做模板定义文件，扩展名为**.def**</p><p>linux下通过<strong>ld -verbose</strong>查看默认的链接脚本。存放在/usr/lib/ldscripts/下。</p><p>使用-T来指定一个链接脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -T link.script</span><br></pre></td></tr></tbody></table></figure><h3 id="最小程序演示链接"><a href="#最小程序演示链接" class="headerlink" title="最小程序演示链接"></a>最小程序演示链接</h3><p><img src="https://gcdnb.pbrd.co/images/ZL8LIwmM1Equ.png?o=1" alt="使用GCC内嵌汇编的Helloworld程序"></p><ul><li>先使用下面方式以普通命令方式编译和链接：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fno-builtin tinyhelloworld.c</span><br><span class="line">ld -static -e nomain -o tinyhelloworld tinyhelloworld.o</span><br></pre></td></tr></tbody></table></figure><p>​-fno-builtin：关闭GCC内置函数功能，防止将printf函数替换为puts、exit函数替换成内置</p><p>​-static：使用静态链接的方式链接</p><p>​-e nomain：表示程序的入口函数为nomain，本质是把ELF文件头Elf32_Ehdr的e_entry参数赋值为nomain函数地址</p><p>​通过这种方式会发现可执行ELF文件有四个段：.text、.rodata、.data、.comment。</p><ul><li><p>使用ld链接脚本</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(nomain)// 指定程序的入口为nomain函数</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">{</span><br><span class="line">. = 0x08048000 + SIZEOF_HEADERS;// 设置当前虚拟地址</span><br><span class="line">tinytext : { *(.text) *(.data) *(.rodata) }// 将所有输入文件中的.text、.data、.rodata段合并到输出文件的tinytext段</span><br><span class="line">/DISCARD/ : { *(.comment) }// 丢弃所有输入文件中的.comment段，不保存到输出文件中</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>TinyHelloword可执行文件中除了tinytext段，还有.shstrtab、.symtabhe 、.strtab段，分别是<strong>段名字符串表（必不可少）、符号表（可以通过-s参数或strip命令去除）、字符串表</strong>。</p></li></ul><h3 id="ld链接脚本语法简介"><a href="#ld链接脚本语法简介" class="headerlink" title="ld链接脚本语法简介"></a>ld链接脚本语法简介</h3><ul><li><p>常用命令语句</p><p><img src="https://gcdnb.pbrd.co/images/i3zYnEIiw7Gw.png?o=1"></p><p><img src="https://gcdnb.pbrd.co/images/CTIWQK1PKEDc.png?o=1"></p></li></ul><h2 id="BFD库"><a href="#BFD库" class="headerlink" title="BFD库"></a>BFD库</h2><p><strong>BFD（binary file description library）</strong>是binutils项目的一个子项目，希望通过一种统一的接口来处理不同的目标文件格式。</p><p><strong>BFD库把目标文件抽象成一个同一的模型，程序只要通过操纵抽象目标文件模型就可以实现操作所有BFD支持的目标文件格式。</strong></p><p>现在gcc（gnu汇编器GAS GNU assembler）链接器ld 调试器GDB及binutils的其他工具都是通过BFD库来处理文件，而不是直接操作目标文件。这样做最大的好处是将编译器和链接器本身同具体的目标文件格式隔离开来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第三章读书笔记</title>
      <link href="/2023/11/22/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-san-zhang-du-shu-bi-ji/"/>
      <url>/2023/11/22/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-san-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>编译器编译源代码后生成的文件叫做目标文件。从结构上讲，它是已经编译后的可执行文件格式，只是<strong>还没有经过链接的过程</strong>，其中可能有些符号或地址还没有调整。它本身就是按照可执行文件格式存储的,只是和真正的可执行文件在结构上稍有不同（在Windows中文件格式为PE-COFF,Linux中文件格式为ELF）。</p><p><strong>动态链接库（DLL,Dynamic Linking Library）</strong>（Windows的.dll和Linux的.so)以及<strong>静态链接库(Static Linking Library)<strong>（Windows的.lib和Linux的.a）文件也是按照可执行文件格式存储。只是静态链接库稍有不同，它是将很多目标文件捆绑在一起形成一个文件,再加上一些索引，</strong>可以将其理解为包含有很多目标文件的文件包。</strong></p><p><img src="https://gcdnb.pbrd.co/images/HLNS9iS2V8tB.png?o=1" alt="ELF格式不同文件类型"></p><h3 id="目标文件的内容"><a href="#目标文件的内容" class="headerlink" title="目标文件的内容"></a>目标文件的内容</h3><p>目标文件中的内容至少有编译后的<strong>机器指令代码、数据，</strong>以及其他链接时需要的信息，如<strong>符号表、调试信息、字符串</strong>等。</p><p>程序源代码编译后的<strong>机器指令</strong>经常被放在<strong>代码段</strong>(Code Section)中。代码段常见的名字有“*.code<em>”或“</em>.text*”；</p><p>已初始化的全局变量和已初始化的局部静态变量保存在数据段”*.data*“；</p><p>未初始化的全局变量和未初始化的局部静态变量保存在”<em>.bss</em>“段；</p><p>未初始化的全局变量和局部静态变量默认值都为0，本来它们也可以被放在.data段中，但因为它们是0，所以在.data段中为其分配空间存放0是没有必要的。而<code>.bss</code>段也<strong>只是为未初始化的全局变量以及局部静态变量预留位置而已，它并没有内容，所以它在文件中也不占据空间</strong>。</p><p><img src="https://gcdnb.pbrd.co/images/9eh8i5MczcFZ.png?o=1"></p><p><em>总体来说，程序源代码被编译之后主要分为两种段：程序指令和程序数据。代码段属于程序指令，而数据段属于程序数据。</em></p><p><strong>为什么将程序的指令和数据分开存放?</strong></p><ul><li>当程序被装载后，数据和指令会被分别映射到两个虚存区域。<strong>数据区域对进程来说是可读写的，但指令区域对于进程来说是只读的。</strong>所以这两个虚存区域的权限被设置成可读写和只读，可以防止程序指令被有意或无意改写。</li><li>程序的指令和数据被分开存放可以<strong>提高CPU的缓存命中率</strong>，因为现代CPU的缓存一般都将数据缓存和指令缓存分离。</li><li>最重要的一点：如果系统中运行了多个同一程序的副本，由于它们的指令都是一样的，所以内存中只需要保存一份程序的指令部分，其他资源，如图片，文本等是可以共享的。这种<strong>分开存放的方法可以节省大量空间</strong>。</li></ul><h2 id="例程分析：SimpleSection-o"><a href="#例程分析：SimpleSection-o" class="headerlink" title="例程分析：SimpleSection.o"></a>例程分析：SimpleSection.o</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SimpleSection.c</span></span><br><span class="line"><span class="comment"> * Linux:</span></span><br><span class="line"><span class="comment"> * gcc -c SimpleSection.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">func1( static_var + static_var2 + a + b );</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>使用<strong>gcc</strong>编译这个文件：</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c SimpleSection.c</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>使用binutils的工具<strong>objdump</strong>查看目标文件的结构和内容：</p><p>参数“-h”：打印ELF文件各个段的基本信息：</p></li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h SimpleSection.o</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/SErhDsnZJcAp.png?o=1" alt="SimpleSection.o的结构和内容"></p><p>SimpleSection.o的段除了最基本的<strong>代码段、数据段</strong>以及<strong>BSS段</strong>以外，还有<strong>只读数据段</strong>(.rodata)，<strong>注释信息段</strong>(.comment)和<strong>堆栈提示段</strong>(.note.GNU-stack)。</p><ol start="3"><li><strong>各字段含义：</strong></li></ol><ul><li><strong>Size</strong>：段的长度，以字节为单位</li><li><strong>VMA（Virtual Memory Address，虚拟内存地址）</strong>: 段的起始虚拟内存地址</li><li><strong>LMA（Load Memory Address，加载内存地址）</strong>: 段的起始加载内存地址</li><li><strong>File off</strong>：段在目标文件中的偏移量，表示该段在文件中的位置</li><li><strong>Align（对齐）</strong>: 段的对齐要求，以字节为单位</li><li><strong>CONTENTS（内容）</strong>: 表示<strong>段是否包含实际的数据</strong>。如果这个标志被设置，那么段包含实际的内容；如果未设置，那么段可能是一个占位符或仅包含标志信息而没有实际的数据（BSS段就没有CONTENTS标识）</li><li><strong>ALLOC（分配）</strong>: 表示<strong>段是否需要在程序运行时分配内存</strong>。</li><li><strong>LOAD（加载）</strong>: 表示<strong>段是否需要被加载到内存中</strong>。如果设置了这个标志，那么在程序加载到内存时，该段的内容会被加载到内存中；如果未设置，那么该段在运行时可能不会被加载。</li><li><strong>RELOC（重定位）</strong>: 表示<strong>段是否包含需要进行重定位的信息</strong>。</li><li><strong>READONLY（只读）</strong>: 表示<strong>段是否只读</strong>。</li><li><strong>CODE（代码）</strong>: 表示<strong>段包含可执行的机器代码</strong>。</li><li><strong>DATA（数据）</strong>: 表示<strong>段包含程序的数据</strong>。</li></ul><ol start="4"><li><p>使用<strong>size</strong>查看ELF文件的代码段、数据段、BSS端的长度：</p><p><img src="https://gcdnb.pbrd.co/images/pjoTnS2OwX5z.png?o=1"></p></li><li><p>使用<strong>objdump的“-s”</strong>参数查看所有段中的内容（十六进制），“-d”参数可以将所有包含指令的段反汇编：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ test]# objdump -s -d SimpleSection.o</span><br><span class="line"></span><br><span class="line">SimpleSection.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 4883ec10 897dfc8b 45fc89c6  UH..H....}..E...</span><br><span class="line"> 0010 bf000000 00b80000 0000e800 000000c9  ................</span><br><span class="line"> 0020 c3554889 e54883ec 10c745fc 01000000  .UH..H....E.....</span><br><span class="line"> 0030 8b150000 00008b05 00000000 01c28b45  ...............E</span><br><span class="line"> 0040 fc01c28b 45f801d0 89c7e800 0000008b  ....E...........</span><br><span class="line"> 0050 45fcc9c3                             E...</span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000                    T...U...        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..            </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202847 4e552920 342e382e  .GCC: (GNU) 4.8.</span><br><span class="line"> 0010 35203230 31353036 32332028 52656420  5 20150623 (Red </span><br><span class="line"> 0020 48617420 342e382e 352d3434 2900      Hat 4.8.5-44).  </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 14000000 00000000 017a5200 01781001  .........zR..x..</span><br><span class="line"> 0010 1b0c0708 90010000 1c000000 1c000000  ................</span><br><span class="line"> 0020 00000000 21000000 00410e10 8602430d  ....!....A....C.</span><br><span class="line"> 0030 065c0c07 08000000 1c000000 3c000000  .\..........&lt;...</span><br><span class="line"> 0040 00000000 33000000 00410e10 8602430d  ....3....A....C.</span><br><span class="line"> 0050 066e0c07 08000000                    .n......        </span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func1&gt;:</span><br><span class="line">   0:   55                      push   %rbp</span><br><span class="line">   1:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   4:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">   8:   89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">   b:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">   e:   89 c6                   mov    %eax,%esi</span><br><span class="line">  10:   bf 00 00 00 00          mov    $0x0,%edi</span><br><span class="line">  15:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  1a:   e8 00 00 00 00          callq  1f &lt;func1+0x1f&gt;</span><br><span class="line">  1f:   c9                      leaveq </span><br><span class="line">  20:   c3                      retq   </span><br><span class="line"></span><br><span class="line">0000000000000021 &lt;main&gt;:</span><br><span class="line">  21:   55                      push   %rbp</span><br><span class="line">  22:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  25:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  29:   c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%rbp)</span><br><span class="line">  30:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 36 &lt;main+0x15&gt;</span><br><span class="line">  36:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 3c &lt;main+0x1b&gt;</span><br><span class="line">  3c:   01 c2                   add    %eax,%edx</span><br><span class="line">  3e:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  41:   01 c2                   add    %eax,%edx</span><br><span class="line">  43:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  46:   01 d0                   add    %edx,%eax</span><br><span class="line">  48:   89 c7                   mov    %eax,%edi</span><br><span class="line">  4a:   e8 00 00 00 00          callq  4f &lt;main+0x2e&gt;</span><br><span class="line">  4f:   8b 45 fc                mov    -0x4(%rbp),%eax</span><br><span class="line">  52:   c9                      leaveq </span><br><span class="line">  53:   c3                      retq </span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>代码段</strong></p><p>其中，”Contents of section .text“就是.text段数据以十六进制打印的结果。</p><p>最左边一列是偏移量，中间一列是十六进制内容，最右边一列是.text段的ASCII码形式。</p><p>对照下面的反汇编结果可以很明显的看出来.text里包含的就是SimpleSection.c里两个函数func1和main()的指令。</p></li><li><p><strong>数据段和只读数据段</strong></p><p>.data段保存的是<strong>已经初始化了的全局静态变量和局部静态变量</strong>。SimpleSection.c中有两个这样的变量：global_init_var、static_var，一共8字节。</p><p>.rodata段保存的是<strong>只读变量（const修饰的变量）和字符常量</strong>。在调用printf时用到了一个字符常量“%d\n”，是一个只读数据，所以放在了.rodata段中。单独设立只读数据段不仅在语义上支持了C++的const关键字，还可以在操作系统加载时将该段映射为只读，保证了程序的安全性。</p></li><li><p><strong>BSS段</strong></p><p>.bss段存放的是<strong>未初始化的全局变量和局部静态变量</strong>。global_uninit_var、static_var2就是被存放在.bss段。其实更准确的说法是，bss段为它们预留了空间。.bss段的size只有4个字节，global_uninit_var、static_var2两个变量加起来应该8字节。</p><p>这其实是因为只有static_var2被存放bss段，而global_uninit_var没有放在这个段（实际上没有放在任何段），它只是一个未定义的**”COMMON符号”<strong>，造成这种结果的主要原因在于编译器。有些编译器会将未初始化的全局变量存放在bss，有些不存放，只预留一个未定义的全局变量符号，等到</strong>最终链接称可执行文件的时候再在.bss段为其分配空间<strong>（但也可以理解未它存放在bss段），</strong>编译单元内部可见的静态变量确实是存在.bss段的。**</p></li><li><p><strong>其他段</strong></p><p><img src="https://gcdnb.pbrd.co/images/PxJZ69ocnD1v.png?o=1"></p></li><li><p><strong>自定义段</strong></p><p>有时候可能希望变量或部分代码放到人为指定的段中，以实现某些特定功能。</p><p>比如为了满足某些硬件的内存和I/O的地址布局，或者像Linux操作系统内核中用来完成一些初始化，用户空间复制是出现页错误异常等。</p><p>GCC提供了扩展机制让程序员可以指定变量所处的段，在<strong>全局变量或函数</strong>前面加上“_<em>atribute_</em>((section(“name”)))就可以把它们放到以”name“为名的段中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__atribute__((section(<span class="string">"FOO"</span>))) <span class="type">int</span> global = <span class="number">42</span>;</span><br><span class="line">__attribute__((section(<span class="string">"BAR"</span>))) <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ol><h2 id="ELF文件描述"><a href="#ELF文件描述" class="headerlink" title="ELF文件描述"></a>ELF文件描述</h2><p><img src="https://gcdnb.pbrd.co/images/cXMkbJcMP68w.png?o=1" alt="ELF目标文件的总体结构"></p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a><strong>文件头</strong></h3><p>使用<strong>readelf</strong>来详细查看ELF文件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ test]# readelf -h SimpleSection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1056 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 12</span><br></pre></td></tr></tbody></table></figure><p>文件头中定义了<strong>ELF魔数，文件机器字长，数据存储方式，版本，运行平台，ABI版本，ELF重定位类型，硬件平台，硬件平台版本，入口地址，程序头入口和长度，段表的位置和长度及段的数量</strong>等。</p><p>以32位版本的文件头结构体“Elf32_Ehdr”为例，其定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">Elf32_Half e_type;</span><br><span class="line">Elf32_Half e_machine;</span><br><span class="line">Elf32_Word e_version;</span><br><span class="line">Elf32_Addr e_entry;</span><br><span class="line">Elf32_Off e_phoff;</span><br><span class="line">Elf32_Off e_shoff;</span><br><span class="line">Elf32_Word e_flags;</span><br><span class="line">Elf32_Half e_ehsize;</span><br><span class="line">Elf32_Half e_phentsize;</span><br><span class="line">Elf32_Half e_phnum;</span><br><span class="line">Elf32_Half e_shentsize;</span><br><span class="line">Elf32_Half e_shnum;</span><br><span class="line">Elf32_Half e_shstrndx;</span><br><span class="line">}Elf32_Ehdr;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/ty2hdWn6I5g3.png?o=1"></p><p><img src="https://gcdnb.pbrd.co/images/vBRzirR7WP3u.png?o=1" alt="ELF文件头结构成员含义"></p><ul><li><p><strong>ELF魔数</strong></p><p>用16个字节来表示ELF的平台属性，比如<strong>ELF字长（32/64位）、字节序、ELF文件版本</strong>等。</p></li><li><p><strong>文件类型</strong></p><p>系统通过常量来判断ELF的真正文件类型，而不是通过文件的扩展名。</p><p><img src="https://gcdnb.pbrd.co/images/20bVngWctiTN.png?o=1" alt="ELF三种文件类型"></p></li><li><p><strong>机器类型</strong></p><p>不同平台下的ELF文件都遵循同一套ELF标准，不同常量值标识不同的平台属性。</p><p><img src="https://gcdnb.pbrd.co/images/r7PtANya83kp.png?o=1"></p></li></ul><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段表描述ELF的各个段的信息，比如<strong>每个段的段名，段的长度，在文件中的偏移，读写权限及段的其他属性</strong>，ELF文件的段结构就是由段表决定的，编译器，链接器和装载器都是依靠段来定位和访问各个段的属性的。段表在ELF文件中位置由ELF文件头的”e_shoff”成员决定。</p><p>段表中的内容可以通过<strong>readelf</strong>命令查看：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ test]# readelf -S SimpleSection.o</span><br><span class="line">There are 13 section headers, starting at offset 0x420:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000054  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000310</span><br><span class="line">       0000000000000078  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000094</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000009c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  0000009c</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     1</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000a0</span><br><span class="line">       000000000000002e  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000ce</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000d0</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  00000388</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000128</span><br><span class="line">       0000000000000180  0000000000000018          11    11     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  000002a8</span><br><span class="line">       0000000000000066  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  000003b8</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></tbody></table></figure><p>段表的结构比较简单，它<strong>是一个以”Elf32_Shdr” 结构体为元素的数组</strong>。数组元素的个数等于段的个数，每个”Elf32_Shdr” 结构体对应一个段。”Elf32_Shdr” 又称段描述符。ELF段表的这个数组的第一个元素是无效的段描述符，它的类型为”NULL”，除此之外每个段描述符都对应一个段。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">       Elf32_Word      sh_name；</span><br><span class="line">       Elf32_Word      sh_type；</span><br><span class="line">       Elf32_Word      sh_flags；</span><br><span class="line">       Elf32_Addr       sh_addr；</span><br><span class="line">       Elf32_Off          sh_offset；</span><br><span class="line">       Elf32_Word      sh_size；</span><br><span class="line">       Elf32_Word      sh_link；</span><br><span class="line">       Elf32_Word      sh_info；</span><br><span class="line">       Elf32_Word      sh_addralign；</span><br><span class="line">       Elf32_Word      sh_entsize；</span><br><span class="line">} Elf32_Shdr；</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/sYuFMFBjRtSH.png?o=1" alt="&quot;Elf32_Shdr&quot; 结构体各成员含义"></p><ul><li><p><strong>段的类型</strong></p><p>事实上段的名字对于编译器、链接器来说是有意义的，但是对于操作系统来说并没有实际的意义。对于操作系统来说，一个段该如何处理取决于由<strong>段的类型</strong>和<strong>段的标志位</strong>这两个成员。</p><p><img src="https://gcdnb.pbrd.co/images/kmjRGnCp9tAF.png?o=1" alt="段的类型与对应常量"></p></li><li><p><strong>段的标志位</strong></p><p>标记段的属性，如是否可写、是否可执行等。</p><p><img src="https://gcdnb.pbrd.co/images/2wb2RO54T5gj.png?o=1" alt="段的标志位与对应常量"></p></li></ul><p>对于系统保留段，它们的属性（段的类型和标志位）如下图所示：</p><p><img src="https://gcdnb.pbrd.co/images/YuFjGXxz5yTg.jpg?o=1" alt="系统保留段的属性"></p><ul><li><p><strong>段的链接信息</strong></p><p>如果段的类型是与链接相关的，比如重定位表、符号表等，则sh_link和sh_info这两个成员所包含的意义如图所示。对于其他段，这两个成员无意义。</p><p><img src="https://gcdnb.pbrd.co/images/8oywjShLUD3u.png?o=1" alt="段的链接信息"></p></li></ul><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中哪些绝对地址的引用的位置。这些重定位的信息都记录在ELF文件中重定位表里面，对于每个须要重定位的代码段或数据段，都会有一个相应的重定位表。</p><p>“.rel.text”段的类型为”SHT_REL”，也就是<strong>重定位表</strong>，是针对”.text“段的重定位，因为”.text“中有对printf函数的调用。</p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a><strong>字符串表</strong></h3><p>字符串长度不一致，用固定结构表示比较困难。可以把字符串集中起来存放到一个表，然后<strong>使用字符串在表中的偏移来引用字符串</strong>。</p><p><img src="https://gcdnb.pbrd.co/images/9Y2tf2cUR3qH.png?o=1" alt="字符串表"></p><p><img src="https://gcdnb.pbrd.co/images/GAaLAFYuZGML.png?o=1" alt="偏移量与对应字符串"></p><p>在ELF文件中引用字符串只须要一个数字下标即可，不用考虑字符串长度的问题。字符串表分别为字符串表 和 段表字符串表。字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串。</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>链接过程的本质就是要<strong>把多个不同的目标文件之间相互 “粘” 到一起</strong>。在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用。每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间混淆。在链接中，我们将<strong>函数和变量统称为符号，函数名和变量名就是符号名</strong>。</p><p>符号看作是链接中的粘合剂，整个连接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，<strong>每个目标文件都会一个相应的符号表</strong>，这个表里记录目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫符号值，对于变量和函数来说，符号值就是它们的地址。</p><ol><li><p><strong>符号类型</strong></p><ul><li>定义在本目标文件的<strong>全局符号</strong>，可以被其他目标文件引用</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这个叫做<strong>外部符号</strong></li><li><strong>段名</strong>，这种符号由编译器产生，它的值就是该段的起始地址</li><li><strong>局部符号</strong>，这类符号只在编译单元可见。调式器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们</li><li><strong>行号信息</strong>，即目标文件指令与源代码中代码行的对应关系</li></ul></li><li><p><strong>ELF符号表结构</strong></p><p>符号表是ELF文件的一个叫<strong>“.symtab”</strong>的段，本质是一个元素为<strong>Elf32_Sym结构体</strong>的<strong>数组</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">   Elf32_Word  st_name;</span><br><span class="line">   Elf32_Addr  st_value;</span><br><span class="line">   Elf32_Word  st_size;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> st_info;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">   Elf32_Half  st_shndx;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gcdnb.pbrd.co/images/9q5NWLqYneWp.png?o=1" alt="Elf32_Sym结构体成员"></p><ul><li><p><strong>符号类型和绑定信息（st_info)</strong></p><p>该成员低4位表示<strong>符号的类型</strong>，高28位表示<strong>符号绑定信息</strong>。</p><p><img src="https://gcdnb.pbrd.co/images/vSM9CMD1Vfo2.png?o=1" alt="低4位符号类型信息"></p><p><img src="https://gcdnb.pbrd.co/images/y2GTEPkUFMVL.png?o=1" alt="高28位符号绑定信息"></p></li><li><p><strong>符号所在段（st_shndx）</strong></p><p>如果符号定义在目录文件中，那么这个成员表示符号<strong>所在的段在段表的下标</strong>；</p><p>如果不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊，如表所示。</p><p><img src="https://gcdnb.pbrd.co/images/F2ajH7PemL3m.png?o=1" alt="符号所在段特殊值"></p></li><li><p><strong>符号值（st_value）</strong></p><p>每个符号都有一个对应的值，如果这个符号是一个函数或变量的定义，那么符号就是这个<strong>函数或变量的地址</strong>。</p><ul><li><p>在目标文件中，如果是符号的定义并且该符号<strong>不是未初始化的全局变量</strong>，st_value表示该符号在段中的偏移。即<strong>符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置</strong></p></li><li><p>在目标文件中，如果符号<strong>是未初始化的全局量</strong>，则<strong>st_value表示该符号的对齐属性</strong></p></li><li><p>在可执行文件中，<strong>st_value表示符号的虚拟地址</strong>，这个虚拟地址对于动态链接器来说十分有用</p></li></ul></li></ul></li><li><p><strong>特殊符号</strong></p><p>使用ld链接器来链接生产可执行文件，它会为我们定义很多特殊的符号，这些符号并没有在你的程序中定义，但是你可以直接声明并且引用它，称之为特殊符号，它们被定义在ld链接脚本中。链接器会在程序最终链接成可执行文件的时候将其解析成正确的值，<strong>只有使用ld链接生产最终可执行文件的时候这些符号才会存在</strong>。</p><ul><li>__executable_start：该符号为<strong>程序的起始地址</strong>，注意，不是入口地址，是程序的最开始的地址</li><li>__etext或_etext或etext：该符号为<strong>代码段结束地址</strong>，即代码段最末尾的地址</li><li>_edata或 edata，该符号为<strong>数据段结束地址</strong>，即数据段最末尾的地址</li><li>_end或end，该符号为<strong>程序结束地址</strong></li></ul></li><li><p><strong>符号修饰与函数签名</strong></p><p>函数签名包含了一个函数的信息，包括<strong>函数名、参数类型、所在的类和名称空间及其他信息</strong>。函数签名用于识别不同的函数，函数的名字只是函数签名的一部分。在编译器及链接器处理符号时，它们使用某种名称修饰的方法，使得<strong>每个函数签名对应一个修饰后名称</strong>。C++的源代码编译后的目标文件中所使用的<strong>符号名是相应的函数和变量修饰后名称</strong>。</p><p><img src="https://gcdnb.pbrd.co/images/B75aOGoUBVla.png?o=1" alt="函数签名及其对应GCC修饰名称"></p><ul><li>所有符号都以”_Z”开头</li><li>对于嵌套的名字（在名称空间或在类里面的），后紧跟”N”</li><li>然后是各个名称空间和类的名字，<strong>每个名字前是名字字符串的长度</strong></li><li>再以”E”结尾</li><li>对于一个函数来说它的<strong>参数列表紧跟在”E”后面</strong></li></ul><p>可以用<strong>c++filt</strong>工具解析被修饰过的名称：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2vcb7xboqe2qhv0easpqZ test]# c++filt _ZN2C12C23CX45functEfc</span><br><span class="line">C1::C2::CX4::funct(float, char)</span><br></pre></td></tr></tbody></table></figure><p>C++中全局变量和静态变量也有同样的机制。值得注意的是，<strong>变量的类型并没有被加入到修饰后的名称中</strong>，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。</p><p>名称修饰机制也被用来<strong>防止静态变量的名字冲突</strong>。比如main() 函数有一个静态变量叫foo，而func()函数里面也有一个静态变量叫foo。为了区分这两个变量，GCC会将它们的符号名分别修饰为_ZZ4mainE3foo  和  _ZZ4funcE3foo，这样就区分了这两个变量。</p></li><li><p><strong>extern“C”</strong></p><p>C++为了与C兼容，在符号管理上，C++有一个用来声明或定义一个C的符号的” extern  “C” “关键字用法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> var;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C++编译器会将extern “C”的大括号内部的代码当作C语言代码处理。所以以上代码中，C++的名称修饰机制将不会起作用。</p><p>当我们的C语言程序包含 string.h 的时候，并且用到了memset这个函数，编译器会将memset符号引用正确处理；但是在C++语言中，编译器会认为这个memset是一个C++函数，将memset的符号修饰成_Z6memsetPvii，这样链接器就无法与C语言库中的memset符号进行链接。所以对于C++来说<strong>使用条件宏来判断当前编译器单元是不是C++代码</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memset</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>弱符号与强符号</strong></p><p>编译器默认<strong>函数和初始化了的全局变量为强符号</strong>，<strong>未初始化的全局变量为弱符号</strong>。</p><p>可以通过GCC的**”_<em>attribute</em>_((weak))”**，来定义任何一个强符号为弱符号。</p><p>链接器按如下规则处理与选择被多次定义的全局符号：</p><ul><li>不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）</li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中<strong>占用空间最大的一个</strong></li></ul><p>对于外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为<strong>强引用</strong>。</p><p>在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未定义，则链接器对于该引用不报错。<strong>链接器默认其为0</strong>，或一个特殊的值，以便于程序代码能够识别。弱引用和弱符号主要用于库的链接过程。</p><p>弱符号和弱引用对库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号覆盖，从而执行自定义版本的库函数；或者对某些扩展功能模块的引用定义为弱引用，将扩展模块和程序链接在一起时，功能模块就能正常使用。</p><p><strong>通过弱引用来判断程序链接的是单线程库还是多线程库</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>*,<span class="type">const</span> <span class="type">pthread_attr_t</span>*,<span class="type">void</span>* (*)(<span class="type">void</span>*)</span></span></span><br><span class="line"><span class="params"><span class="function">{</span></span></span><br><span class="line"><span class="params"><span class="function">__attribute__((weak));</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> main()</span></span></span><br><span class="line"><span class="params"><span class="function">{</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">if</span> (pthread_create)</span></span></span><br><span class="line"><span class="params"><span class="function">{</span></span></span><br><span class="line"><span class="params"><span class="function">printf(<span class="string">"multi-thread!\n"</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">{</span></span></span><br><span class="line"><span class="params"><span class="function">printf(<span class="string">"single_thread!\n"</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br></pre></td></tr></tbody></table></figure><p>定义了一个pthread_create函数的弱引用，在程序运行时动态判断是否连接到pthread库从而决定执行多线程版本还是单线程版本。</p></li></ol><h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>目标文件中可能保存的是调试信息，比如目标代码中的地址对应源代码的哪一行、函数和变量类型、结构体定义、字符串。</p><p>ELF文件采用DWAF（Debug With Arbitrary Record Format）的标准的调试信息格式。</p><p>在Linux下可以用<strong>“strip”</strong>命令去除ELF文件中的调试信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第二章读书笔记</title>
      <link href="/2023/11/21/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-er-zhang-du-shu-bi-ji/"/>
      <url>/2023/11/21/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-er-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="可执行文件四步走"><a href="#可执行文件四步走" class="headerlink" title="可执行文件四步走"></a>可执行文件四步走</h2><p><img src="https://gcdnb.pbrd.co/images/al6l0zfKZtSf.png?o=1" alt="GCC编译过程分解"></p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br><span class="line">或者</span><br><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></tbody></table></figure><p>主要<strong>处理源代码中以“#”开始的预编译指令</strong>，如“#include”、“#define”“#ifdef”等。这个过程包括了：</p><ul><li>删除#define，展开宏定义</li><li>递归处理“#include”预编译指令</li><li>删除所有的注释”//,/**/“</li><li>添加行号和文件名标识（便于调试时输出相关信息或编译错误警告产生行号）</li><li>保留所有的#pragma编译器指令，因为编译器要使用</li></ul><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。<strong>当无法判断宏定义是否正确或头文件包含是否正确，可以查看预编译后的文件来定位问题。</strong></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -S hello.i -o hello.s</span></span><br></pre></td></tr></tbody></table></figure><p>将预处理完的文件进行一系列的<strong>词法分析、语法分析、语义分析及优化</strong>，然后生产出相应的<strong>汇编代码文件</strong>。现版本gcc把预编译和编译两个步骤合并成一个步骤，使用一个叫ccl的程序来完成这两个步骤：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/usr/lib/gcc/i486-linux-gnu/4.1/ccl helloc.c</span></span><br></pre></td></tr></tbody></table></figure><p>C++用cclplus，Objective-C用cclobj，fortran用f771，java用jcl。</p><p><strong>实际上gcc只是这些后台程序的包装，他会根据不同参数调用对应程序。</strong></p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c hello.s -o hello.o</span></span><br><span class="line">或者</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">as hello.s -o hello.o</span></span><br></pre></td></tr></tbody></table></figure><p>对照着汇编指令与机器指令的表，将汇编代码转变成机器可以执行的指令。汇编器输出的是目标文件.o（不是可执行文件）。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -static crt1.o crti.o crtbeginT.o hello.o -start-group -lgcc -lgcc_eh -lc-end-group crtend.o crtn.o</span><br></pre></td></tr></tbody></table></figure><p>详细见下文。</p><h2 id="编译器的作用"><a href="#编译器的作用" class="headerlink" title="编译器的作用"></a>编译器的作用</h2><p>编译器是<strong>将高级语言翻译成机器语言</strong>的工具。</p><p>高级语言让程序员可以更加关注程序本身，而很少考虑计算机本身限制（字长、内存大小、通信方式、存储方式等）。</p><p>编译过程可以分为6步：</p><p><strong>扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。</strong></p><p><img src="https://gcdnb.pbrd.co/images/0cF2jdW0ueS1.png?o=1" alt="编译过程"></p><p>以下述代码做分析：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index + <span class="number">4</span>) * (<span class="number">2</span> + <span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p><strong>扫描器（Scanner）做词法分析</strong>。分析产生的符号可以分为：关键字、标识符、字面量（数字、字符串等）、特殊符号（加号、等号等）。</p><p>识别的同时，扫描器将标识符放到符号表，将字面量放到文字表等。</p><p><strong>lex程序</strong>可以实现词法扫描，它可以按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p><strong>语法分析器（Grammar Parser）以表达式为节点生成语法树。</strong>仅仅完成了表达式语法层面的分析，并不了解语句是否真正有意义。</p><p><img src="https://gcdnb.pbrd.co/images/BPi0r036Y4jT.png?o=1" alt="例句语法树"></p><p>整个例句被视为<strong>赋值表达式</strong>，左边是一个<strong>数组表达式</strong>，右边是个<strong>乘法表达式</strong>；</p><p>数组表达式又由两个<strong>符号表达式</strong>组成。</p><p>数字和符合是最小的表达式，所以一般作为语法树的叶节点。</p><p><strong>yacc（Yet Another Compiler Compiler）程序</strong>可以根据用户给定的语法规则对输入的记号序列进行解析，形成于一棵语法树。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p><strong>语义分析器（Semantic Analyzer）</strong>会给语法树的表达式标识类型，如果存在隐式转换，语义分析程序会在语法树中插入相应的转换节点。</p><p><strong>静态语义：</strong>编译期间可以确定的语义，如声明和类型的匹配、类型的转换等；</p><p><strong>动态语义：</strong>运行期间才能确定的语义，如将0作为除数等。</p><p><img src="https://gcdnb.pbrd.co/images/nWxdNnPm1zIE.png?o=1"></p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>当一个系统特别复杂的时候，我们不得不将它分割成小的系统以达到各个突破的目的。我们将每个源代码模块独立地编译，然后按照须要将它们“组装”起来，这个组装的过程就是**链接(Linking)**。</p><p>链接的主要过程包括：<strong>地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）、重定位（Relocation）</strong>。</p><p><img src="https://gcdnb.pbrd.co/images/smdN9zVcPfBF.png?o=1" alt="链接过程"></p><p>每个模块的<strong>源代码文件（.c文件）</strong>经过编译器编译成<strong>目标文件（.o或.obj）</strong>，目标文件和<strong>库（Library）</strong>一起链接成最终可执行文件。</p><p>比如我们在程序模块main().c中使用另外一个模块func.c中的函数foo().我们在main().c模块的每一处调用foo的时候都必须确切知道foo这个函数的地址，所以它暂时将这些调用foo的指令的目标地址搁置，等待最后链接的时候由连接器去将这些指令的目标地址修正。</p><p>在链接的过程中，对其他定义在目标文件中的<strong>函数</strong>调用的指令须重新调整，对使用其他定义在其他目标文件的<strong>变量</strong>也同样如此。假设有个全局变量var，它在目标文件A中，在目标文件B中要访问这个全局变量。由于在编译目标文件B的时候，编译器并不知道变量var的目标地址，所以编译器在无法确定地址的情况下会将指令的目标地址置为0，等待链接器在将目标文件A和B链接起来的时候再将其修正。这个地址修正的过程也被叫做**重定位(Relocation)**。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养——链接、装载与库》第一章读书笔记</title>
      <link href="/2023/11/16/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-yi-zhang-du-shu-bi-ji/"/>
      <url>/2023/11/16/cheng-xu-yuan-de-zi-wo-xiu-yang-lian-jie-zhuang-zai-yu-ku-di-yi-zhang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>计算机硬件核心三部分：<strong>中央处理器CPU、内存、I/O控制芯片</strong>。<br>CPU频率：大体上理解是，CPU操作的最小时间单位叫时钟周期，它的倒数叫频率。意思就是一秒钟CPU能执行多少条指令。频率越高，单位时间内能执行的命令越多，也就越快。&nbsp;</p><h3 id="早期计算机"><a href="#早期计算机" class="headerlink" title="早期计算机"></a>早期计算机</h3><ol><li>CPU的频率和内存的频率一致，直接连接到同一个总线Bus。</li><li>为了协调I/O和总线的速度，每个I/O设备都有一个I/O控制器。</li></ol><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ol><li>CPU频率高于内存频率。采用 <strong>总线频率和内存频率一致，CPU倍频与总线通信</strong>的方式。</li><li>I/O速度无法满足图形化芯片的需求，设计<strong>北桥芯片</strong>进行通信。</li><li>为了减轻北桥芯片既要处理高速设备、又要处理低速设备的压力，设计<strong>南桥芯片</strong>。南桥主要处理低俗设备，汇总后连接到北桥。</li></ol><h3 id="SMP和多核"><a href="#SMP和多核" class="headerlink" title="SMP和多核"></a>SMP和多核</h3><ol><li>频率越高，机器相应的性能会好，但是CPU的制造工艺限制，频率卡在了<strong>4GHz</strong></li><li>提高CPU速度的另外的方式：<strong>增加CPU数量。</strong></li><li>对称多处理器（SMP，Symmetrical Multi-Processing），每个CPU完整，有cache等。</li><li>多核处理器（Multi-Processing）：共享昂贵的缓存设备，保留多个核心。</li><li>核的数量和速度提升不是线性正比，因为计算任务并不是完全相互独立。</li></ol><h2 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h2><ol><li><p>管理计算机本身的软件称为<strong>系统软件</strong>。分为<strong>平台型软件</strong>：操作系统内核、驱动程序、运行库、系统工具；<strong>程序开发型</strong>：编译器、汇编器、链接器、开发库。</p><p><img src="https://gcdnb.pbrd.co/images/gHQoxT7BUwOb.png?o=1"></p></li><li><p>计算机软件有着严格的层次结构，各层之间通过接口进行通信。<strong>接口实际上就是一个通信协议，由下层定义实现，由上层调用。</strong></p></li><li><p>层次结构的好处是，<strong>中间层都是对于下一层的封装和扩展</strong>，可以通过新加层提供其它功能。</p></li><li><p>虚拟机技术是<strong>在硬件和操作系统之间增加了一层虚拟层</strong>，使得一个计算机上可以同时运行多个操作系统。</p></li><li><p>应用程序使用<strong>运行库</strong>提供的<strong>应用程序接口</strong>（Application Programming Interface，API），比如Linux下的Glinbc库提供POSIX的API、Windows的运行库提供Windows API。</p></li><li><p>运行库使用<strong>操作系统</strong>提供的<strong>系统调用接口</strong>（System call Interface，SCI），往往以<strong>软件中断</strong>的方式提供，比如Linux使用0x80号终端作为系统调用接口、Windows使用0x2E号中断作为系统调用接口。</p></li><li><p>操作系统和驱动程序使用<strong>硬件</strong>提供的<strong>硬件规格</strong>。</p></li></ol><h2 id="操作系统和设备驱动"><a href="#操作系统和设备驱动" class="headerlink" title="操作系统和设备驱动"></a>操作系统和设备驱动</h2><ol><li><p>操作系统的功能：提供<strong>抽象的接口+管理硬件资源</strong>。操作系统不能让硬件资源闲置，要尽可能地挖掘其工作潜能。</p></li><li><p><strong>多道程序</strong>（Multiprogramming）：一个监控程序，当前程序没有使用CPU时，将另外等待CPU资源的程序启动。</p><p>缺点：调度策略太粗糙，没有轻重缓急，交互性不行。</p></li><li><p><strong>分时系统</strong>（Time-Sharing）：每个程序运行一段时间后<strong>主动</strong>让出CPU。</p><p>缺点：程序主动让出CPU时间，如果一个程序写了个死循环，整个系统就像死机了一样。</p></li><li><p><strong>多任务系统</strong>（Multi-tasking）：抢占式，操作系统接管所有硬件，其本身运行在一个受硬件保护的级别，其他应用程序以进程的形式运行在比系统权限低的级别，<strong>各进程独立地址空间，相互隔离</strong>。UNIX、Linux、Windows NT、Mac OS X都是这种。</p></li><li><p>设备驱动屏蔽了底层硬件实现和调用的细节问题，给上层运行库和应用程序一个调用接口。UNIX中硬件设备的访问形式和普通文件一样，Windows中图形硬件被抽象为GDI、声音和多媒体设备被抽象成DirectX对象、磁盘被抽象成普通文件系统。</p></li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol><li><p>硬盘的基本存储单位为扇区（Sector），每个扇区一般为512字节。</p></li><li><p>文件系统管理着磁盘中文件的存储方式。比如一个长8000字节的文件，文件系统将前4096字节存储在磁盘的1000-1007扇区，；4097-8000字节存储在磁盘的2000-2007扇区，浪费了192字节。</p><p><img src="https://gcdnb.pbrd.co/images/DoKvr36cwfsv.png?o=1"></p></li><li><p>硬盘结构：一个磁盘有两个盘面，每个盘面按同心圆划分成多个磁道。每个磁道划分成若干个扇区，每个扇区大约512字节。由于靠近圆心的磁道长度小于外层的磁道，如果每个磁道划分成相同的扇区，那么外层磁道的密度肯定比内层小。所以我们采用逻辑扇区号（Logical Block Address，LBA），逻辑扇区号从0开始编号，然后转换成盘片、盘面、磁道、扇区。</p></li><li><p>比如某个程序需要读取文件的前4096个字节，通过系统调用发送信息给设备驱动程序，设备驱动程序发送硬件命令给硬盘。</p></li></ol><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>假设当前有128M内存，程序A需要内存：10MB,程序B需要内存：100MB,程序C需要内存：20MB.</p><h3 id="未使用内存管理时"><a href="#未使用内存管理时" class="headerlink" title="未使用内存管理时"></a>未使用内存管理时</h3><p>0-9MB分配给A，10-109MB分配给B。缺点如下：</p><ul><li><strong>地址空间不是隔离的：</strong>每个程序都可以直接访问物理地址，某些程序可能有意或者无意地就修改其它程序。</li><li><strong>内存使用效率低下：</strong>如果要运行C，内存目前不够分配，所以要将某个进程写到磁盘，腾出空间给C，将A换出内存仍然不够，只能将B换出，然后将C读入，大量的数据换入换出效率低下。</li><li><strong>程序运行地址不确定：</strong>因为每次换入到内存中，地址是不确定的，这样导致重定位问题严重。</li></ul><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>上述问题解决思路：增加一个中间层，使用间接的地址访问，将程序给出的地址看作虚拟地址，将虚拟地址映射到物理地址。通过控制映射过程，保证任意程序访问的内存区域互不重叠，保证隔离性。</p><p><strong>地址空间：</strong>地址空间类似于一个数组，数组地每个元素占一个字节，数组的大小为地址空间的地址长度决定。32为的地址空间大小为2^32=4GB。</p><p>物理地址空间每台计算机唯一一个，相当于物理内存。比如32位机器，物理空间4GB，但是可能装的内存只用512MB。那物理地址有效部分是0x0000 0000~0x1FFF FFFF，其它的部分无效。</p><p>虚拟地址是虚拟出来的，每个进程不一样，每个进程只能访问自己的地址空间，从而进程隔离。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ol><li>对于程序A，虚拟地址空间0x0000 0000~0x00A0 0000。然后在内存中分配一个相同大小的物理地址，假设为0x0010 0000-0x00B0 0000</li><li>操作系统完成两个地址空间的一一映射，映射过程由软件来完成，实际的转换由硬件来完成。</li><li>分段解决了<strong>“地址空间不隔离”</strong>的问题：如果程序访问的虚拟空间地址越界，硬件就会判断非法访问，报告错误给操作系统。</li><li>分段解决了<strong>“程序运行地址不确定”</strong>的问题：每个程序不关心物理地址的变化，只需要按照虚拟地址空间来编写程序，放置变量。</li><li>分段没解决内存使用效率低下的问题：内存分配以程序为单位进行分配，还是有可能进行大量的磁盘-内存交换操作。</li><li>解决思路：程序在运行的一小个时间段内，不是使用了程序的所有数据，而是只使用到了一小部分数据。根据局部性原理减小内存分割、映射的粒度，提出<strong>“分页”</strong>的方法。</li></ol><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><ol><li><p>将地址空间人为分成固定大小的页，每页的大小由硬件决定。在同一时刻只能存在一种页的大小。目前几乎所有的PC上的OS都用的<strong>4KB大小的页</strong>。</p></li><li><p>在某个时刻，进程只将需要用到的页换到内存中，其它没有用到的页继续存放在磁盘中。当进程需要的某个不在内存中的页时，硬件捕获<strong>页错误</strong>（Page Fault）消息，操作系统接管进程，将虚拟页的数据从磁盘换入到内存中。</p><p><img src="https://gcdnb.pbrd.co/images/DNJhGkUs1Sj0.png?o=1"></p></li><li><p>CPU发出的都是虚拟地址，经过其内部集成的MMU（Memory Management Unit）转换成物理地址访问内存。</p><p><img src="https://gcdnb.pbrd.co/images/ebx4c1RsjETl.png?o=1"></p></li></ol><h2 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h2><ol><li><p>CPU频率现在无法提升，我们采取多核措施。软件并发执行的一个方法就是多线程。</p></li><li><p>线程，轻量级进程，程序执行流的最小单元。</p></li><li><p>进程与线程的关系：</p><p><img src="https://gcdnb.pbrd.co/images/eMHMzNggSByG.png?o=1"></p></li><li><p>线程的访问权限：</p><p><img src="https://gcdnb.pbrd.co/images/Qyj73TYzTOw9.png?o=1"></p></li><li><p>线程优先级与调度：</p><p>线程通常有三种状态：<strong>运行</strong>(Running)、<strong>就绪</strong>(Ready)、<strong>等待</strong>(Waiting)。</p><p><img src="https://gcdnb.pbrd.co/images/6AXOxzvy3SOk.png?o=1"></p><p>线程的调度遵循<strong>优先级</strong>（Priority）和<strong>时间片</strong>（Time Slice）。Linux下可以通过<strong>pthread库</strong>来手动给线程设置优先级，在Windows中通过以下API：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetThreadPriority</span><span class="params">(HANDLE hThread, <span class="type">int</span> nPriority)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>系统会给线程自动调整优先级，以使得线程调度更有效率。一般来说由于<strong>IO密集型线程</strong>等待状态较多，会主动放弃CPU时间，不容易造成其他线程饿死，所以其优先级较高，而<strong>计算密集型线程</strong>相反。</p><p>优先级改变的三种方式：</p><ul><li>用户指定</li><li>根据进入等待状态的频繁程度提升或降低</li><li>长时间得不到执行的线程提升优先级</li></ul></li><li><p>Linux多线程：</p><p>在Linux中，所有的执行实体，无论是进程还是线程都被称为<strong>任务</strong>(Task),相当于一个单线程的进程，具有内存空间，执行实体，文件资源等。</p><p>Linux下不同的任务之间可以<strong>选择</strong>共享内存空间，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就构成了进程的线程。</p></li></ol><p><img src="https://gcdnb.pbrd.co/images/wsr0SMfDDUpQ.png?o=1" alt="Linux创建新任务的方法"></p><ul><li><p>fork不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制</strong>（Copy on Write）的内存空间，所以产生新任务的速度很快。</p><p><em>写时复制：两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响其他任务使用。</em></p><p><img src="https://gcdnb.pbrd.co/images/3dduhnCFNYwE.png?o=1"></p></li><li><p>fork只能产生本任务的镜像，需要配合exec才能启动新任务，新任务可以调用exec执行新的可执行文件。</p></li><li><p>clone可以生成一个新的任务并从指定位置开始执行，并共享当前的内存空间和文件，等同于clone函数的原型：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span>*), <span class="type">void</span>* child_stack, <span class="type">int</span> flags, <span class="type">void</span>* arg)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="7"><li>线程安全：</li></ol><ul><li><p>竞争与原子操作：线程并发执行会对同一资源形成<strong>竞争姿态</strong>，<strong>单指令操作是原子的</strong>，不会被打断，Windows中有一套API专门进行一些原子操作，被称为Interlocked API：</p><p><img src="https://gcdnb.pbrd.co/images/32BvjdLItTlY.png?o=1"></p></li><li><p>同步与锁：</p><p><strong>同步</strong>：一个线程访问数据未结束时，其他线程不得对该数据进行访问，如此，数据的访问被<strong>原子化</strong>。</p><p><strong>锁</strong>：最常见的同步方法；</p><ul><li><strong>二元信号量</strong>（Binary Semaphore)：一种最简单的锁。它只有两种状态：占用/非占用，适合<strong>只能被唯一一个线程独占访问的资源</strong>。占用期间，其他线程无法访问。但是<strong>可以由不同的线程释放</strong>。</li><li><strong>信号量</strong>(Semaphore，或多元信号量)：允许多个线程并发访问资源，一个初始值为N的信号量允许N个线程并发访问。信号量在整个系统中可以被任意线程获取并释放，即：<strong>同一个信号量可以由系统中的一个线程获取后再由另外一个线程释放。</strong></li><li><strong>互斥量</strong>(Mutex)：类似二元信号量，仅同时允许一个线程访问。和信号量不同的是，互斥量要求哪<strong>个线程获取了互斥量，哪个线程就要负责释放这个锁。</strong></li><li><strong>临界区</strong>(Critical Section)：比互斥量更加严格的同步手段。互斥量和信号量在系统中的任何进程都是可见的，即：一个进程创建了一个互斥量或信号量，另外一个进程试图获取这个锁是合法的。但是<strong>临界区的作用仅限于本进程，其他进程无法获取该锁。</strong></li><li><strong>读写锁</strong>(Read-Write Lock)：适用于数据读取特别频繁，但是写入特别少的情况。读写锁有两种获取方式：<strong>共享的</strong>/<strong>独占的</strong>(Shared/Exclusive)，如果锁处于自由状态，可以以共享或独占方式获取；如果锁处于共享状态，其他线程只能以共享方式获取锁。</li><li><strong>条件变量</strong>（Condition Variable）：一个条件变量可以被多个线程等待，线程唤醒条件变量时，某个或多个等待的线程都会被唤醒，可以实现所有线程都恢复执行（notifyall）。</li></ul></li><li><p>可重入函数：</p><p>可重入函数需要具有以下特点：</p><ul><li>不使用任何局部静态或全局的非const变量；</li><li>不返回任何局部静态或全局的非const变量的指针；</li><li>仅依赖于调用方提供的参数；</li><li>不依赖任何单个资源的锁；</li><li>不掉用任何不可冲入函数。</li></ul></li><li><p>barrier：</p><p>编译器和CPU在执行指令的时候，可能会交换两条不相干的相邻指令。可以通过volatile阻止编译器将一个变量缓存到寄存器而不写回，还可阻止编译器调整指令顺序，但不能阻止CPU调整顺序。这个时候，就可以通过<strong>barrier指令来阻止CPU将该指令之前的指令交换到barrier之后</strong>，相当于一个拦水坝，如POWERRPC提供的lwsync。</p></li></ul><ol start="8"><li>用户与内核多线程的不同模型：</li></ol><ul><li><p>一对一：</p><p>一个用户使用的线程唯一对应一个内核使用的线程。（但反过来不一定，一个内核线程在用户态不一定由对应的线程存在）。<strong>一般直接使用API或者系统调用创建的线程均为一对一</strong>（如Linux中使用clone）。</p><p>优点：真正的并发，一个线程阻塞不会影响其他线程。</p><p>缺点：用户线程数量收到操作系统限制；内核线程调度上下文切换开销大，导致用户线程执行效率下降。</p></li><li><p>多对一：</p><p>将多个用户线程映射到一个内核线程。</p><p>优点：切换快；无限制的线程数量。</p><p>缺点：一个用户线程阻塞，所有线程无法执行。</p></li><li><p>多对多：</p><p>将多个用户线程映射到少数但不止一个内核线程。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 《程序员的自我修养——链接、装载与库》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程之美</title>
      <link href="/2023/11/15/ruan-jian-gong-cheng-zhi-mei/"/>
      <url>/2023/11/15/ruan-jian-gong-cheng-zhi-mei/</url>
      
        <content type="html"><![CDATA[<h2 id="怎样学好软件工程"><a href="#怎样学好软件工程" class="headerlink" title="怎样学好软件工程"></a><strong>怎样学好软件工程</strong></h2><h3 id="软件工程知识架构全景图"><a href="#软件工程知识架构全景图" class="headerlink" title="软件工程知识架构全景图"></a>软件工程知识架构全景图</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/5b3yy6642bace3928782e978de576fdc.jpg"></p><p><strong>质量焦点：聚焦于质量，构建和维护高质量的软件</strong>。可以说，聚焦于质量就是软件工程的基石。</p><p><strong>过程：</strong>在软件项目的生命周期内，也就是软件从诞生到结束这期间，在开发与构建系统时要遵循的步骤。</p><p><strong>方法：</strong>在整个过程中，如何构建系统的方法学。比如说，如何分析用户需求；如何对产品进行测试验收；如何进行系统架构设计等。</p><p><strong>工具：</strong>通过工具，可以把一些手动的工作自动化，比如自动化测试工具，自动构建部署工具；通过工具，可以帮助把一些流程规范起来，比如 Bug 跟踪、源代码管理；还可以通过工具，帮助提高编码效率，比如各种编辑器 IDE、各种高级语言。</p><p><strong>软件工程 = 工具 + 方法 + 过程。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9926b79ecc91a4e664933c587f630199.jpg"></p><h3 id="如何学习软件工程"><a href="#如何学习软件工程" class="headerlink" title="如何学习软件工程"></a>如何学习软件工程</h3><ol><li><p><strong>用器</strong></p><p>比如，原型设计工具可以帮助你确定需求，持续集成工具可以帮助你简化测试和部署的流程。对工具的学习是最为简单的，也是最基础的。</p></li><li><p><strong>学术</strong></p><p>学会方法，就能应用方法去完成一个任务，例如用需求分析的方法，去搞清楚用户想要什么，用 Scrum 去组织项目开发过程。</p></li><li><p><strong>悟道</strong></p><p>软件工程知识的核心思想和本质规律。就像敏捷开发，本身并不是一种方法，而是一套价值观和原则，领悟了这个道，就可以成为在处理项目过程中各种问题决策的依据。</p></li><li><p><strong>传道</strong></p><p>能把复杂的知识通过浅显易懂的方式传授给别人，那就说明对知识的领悟已经到了更高的境界。</p></li></ol><h2 id="把每件事都当作一个项目来推进"><a href="#把每件事都当作一个项目来推进" class="headerlink" title="把每件事都当作一个项目来推进"></a><strong>把每件事都当作一个项目来推进</strong></h2><h3 id="什么是工程方法"><a href="#什么是工程方法" class="headerlink" title="什么是工程方法"></a>什么是工程方法</h3><p><strong>有目的、有计划、有步骤地解决问题的方法就是工程方法。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/c45b734291f8a36d4c3d7ed87e384e4e.jpg"></p><h4 id="站在整体而非局部去看问题"><a href="#站在整体而非局部去看问题" class="headerlink" title="站在整体而非局部去看问题"></a>站在整体而非局部去看问题</h4><p>用工程方法去处理事情，有两点好处：</p><ol><li><strong>有一个被有效论证过的方法论指导你，可以帮助你提高成功概率，也可以提高效率。</strong></li><li><strong>当你用工程方法去思考的时候，你会更多的站在整体而非局部去思考，更有大局观。</strong></li></ol><p><strong>问题的核心并不在于是不是用工程方法，而是有没有把这件事当作一个项目，是不是能看到这件事的全貌，而不是只看到局部。</strong></p><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a><strong>瀑布模型</strong></h2><h3 id="瀑布模型的概念"><a href="#瀑布模型的概念" class="headerlink" title="瀑布模型的概念"></a>瀑布模型的概念</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/043ec1b87258d3b414b4fa2c5572f20f.jpg"></p><p>在 1970 年，Winston Royce 博士借鉴了其他工程领域的思想，比如建筑工程，提出了瀑布开发模型，指出软件开发应有完整之周期，并将软件开发过程分成了若干阶段。<strong>也是从那时开始，有了“软件生命周期”(Software Life Cycle,SLC) 的概念。</strong></p><h3 id="瀑布模型的优缺点"><a href="#瀑布模型的优缺点" class="headerlink" title="瀑布模型的优缺点"></a>瀑布模型的优缺点</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/881b21fa452df38da1604f5a6b55d65c.jpg"></p><h2 id="其他开发模型"><a href="#其他开发模型" class="headerlink" title="其他开发模型"></a>其他开发模型</h2><h3 id="快速开发快速改"><a href="#快速开发快速改" class="headerlink" title="快速开发快速改"></a>快速开发快速改</h3><p><strong>快速原型模型，就是为了要解决客户的需求不明确和需求多变的问题。</strong></p><p>先迅速建造一个可以运行的软件原型，然后收集用户反馈，再反复修改确认，使开发出的软件能真正反映用户需求，这种开发模型就叫快速原型模型，也叫原型模型。</p><p>重点是反映软件核心功能和交互，功能可以是不完整的，可靠性和性能要求不高，<strong>以牺牲质量为代价</strong>，但开发速度可以很快。</p><h3 id="大瀑布拆小瀑布"><a href="#大瀑布拆小瀑布" class="headerlink" title="大瀑布拆小瀑布"></a>大瀑布拆小瀑布</h3><p><strong>瀑布模型的很多问题，根源都是周期太长</strong>。如果能将周期变短，那么很多问题就迎刃而解了。</p><p>基于这种思路，产生了很多开发模型，比较典型的主要是：<strong>增量模型</strong> 和 <strong>迭代模型</strong>。</p><ul><li><p><strong>增量模型——按模块分批次交付</strong></p><p>增量模型是把待开发的软件系统模块化，然后在每个小模块的开发过程中，应用一个小瀑布模型，对这个模块进行需求分析、设计、编码和测试。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/20d7896e4a52e8043defff6eedb9869b.jpg"></p><p><strong>如果系统不能模块化，那么将很难采用增量模型的模式来开发。</strong></p><p>增量模型主要适用于：<strong>需求比较清楚，能模块化的软件系统，并且可以按模块分批次交付。</strong></p></li><li><p><strong>迭代模型——每次迭代都有一个可用的版本</strong></p><p>迭代模型每次只设计和实现产品的一部分，然后逐步完成更多功能。每次设计和实现一个阶段叫做一个迭代。</p><p>在一个迭代中都会包括需求分析、设计、实现和测试，类似于一个小瀑布模型。<strong>迭代结束时要完成一个可以运行的交付版本。迭代模型最难的部分，在于规划每次迭代的内容和要达到的目标。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9abe6230baeb7a92a95b65dd7c383d10.jpg"></p></li></ul><p><strong>增量模型是按照功能模块来拆分；而迭代模型则是按照时间来拆分，看单位时间内能完成多少功能。</strong></p><p>用盖房子来理解，增量模型则是先盖厨房，再是卧室，这样一个个模块来完成。而迭代模型则是先盖一个简单的茅草房，有简易的土灶和土床，然后再升级成小木屋，有更好的灶和更好的卧室，这样一步步迭代成最终的房子。</p><h3 id="怎么选择合适的模型"><a href="#怎么选择合适的模型" class="headerlink" title="怎么选择合适的模型"></a>怎么选择合适的模型</h3><p><strong>场景一：外包项目，需要阶段验收</strong></p><p><strong>V 模型，本质上还是瀑布模型，但更重视对每个阶段验收测试的过程模型。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/c015252d6ae984b667499ee5b8c76ab1.jpg" alt="V 模型"></p><p><strong>场景二：项目风险高，随时可能会中断</strong></p><p><strong>螺旋模型，在每次交付的时候，要同时做一个风险评估，如果风险过大就不继续后续开发了，及时止损。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/5c1f2444754f3ce5ce68e0a790da2bcc.png"></p><p><strong>场景三：山寨一款软件产品，希望能快速上线发布</strong></p><p>项目需求是明确的，不会有什么变化，这时候就可以选择增量模型，划分好模块，先实现核心模块，发布可运行版本，再增量发布其他模块。多模块可以同步开发。</p><p><strong>场景四：客户需求不明确</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/b0091341a7fa31cd26d8a02e7d63e2fc.png"></p><p><strong>场景五：产品已经上线，但是需要持续更新维护</strong></p><p>在这种情况下，<strong>迭代模型</strong>是比较合适的。固定时间周期，在固定的周期内选择适合的需求开发任务和 Bug 修复任务去完成，按时发布。</p><p>另外还可以尝试<strong>敏捷开发</strong>，也是基于迭代的开发模型，它也强调快速交付，每次交付系统的部分功能，来保证客户满意度。在敏捷开发中，系统交付的周期称之为冲刺（Sprint）。</p><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><h3 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/d5f757c6b60a51dfe3dab3bde8a736ea.png" alt="敏捷宣言"></p><p><strong>敏捷不是一种方法论，也不是一种软件开发的具体方法，更不是一个框架或过程，而是一套价值观和原则。</strong></p><h3 id="敏捷开发解决什么问题"><a href="#敏捷开发解决什么问题" class="headerlink" title="敏捷开发解决什么问题"></a>敏捷开发解决什么问题</h3><p>敏捷开发就是想解决瀑布模型这样的重型软件开发方法存在的问题，用一种<strong>轻量的、敏捷的</strong>方法来改善甚至是替代它。</p><p><strong>瀑布模型的典型问题就是周期长、发布烦、变更难，敏捷开发就是快速迭代、持续集成、拥抱变化。</strong></p><h3 id="敏捷开发和瀑布模型的差异"><a href="#敏捷开发和瀑布模型的差异" class="headerlink" title="敏捷开发和瀑布模型的差异"></a>敏捷开发和瀑布模型的差异</h3><p><strong>需求分析阶段：</strong></p><ul><li>瀑布模型：要有严谨的需求分析，产生详尽的需求分析文档</li><li>敏捷开发：一个个小的用户故事，通常是写在卡片上的一句话，在 Sprint 的开发中，再去确认需求的细节</li></ul><p><strong>架构设计阶段：</strong></p><ul><li>瀑布模型：在需求分析完了以后，就需要根据需求做架构设计</li><li>敏捷开发：不是基于完整的用户需求开发，每个 Sprint 只做一部分需求，是一种渐进式的架构设计</li></ul><p><strong>项目质量：</strong></p><ul><li>瀑布模型：在编码完成后，会有专门的阶段进行测试，以保证质量</li><li>敏捷开发：开发功能的同时，要编写单元测试和集成测试代码，用自动化的方式辅助完成测试</li></ul><p><strong>发布部署：</strong></p><ul><li>瀑布模型：在编码结束后，在测试阶段定期部署测试环境，测试验收通过后，发布部署到生产环境</li><li>敏捷开发：整个过程都是全自动化的，每次完成一个任务，提交代码后都可以触发一次构建部署操作，脚本会拿最新的代码做一次全新的构建，然后运行所有的单元测试和集成测试代码，测试通过后部署到测试环境</li></ul><h3 id="敏捷开发适应场景"><a href="#敏捷开发适应场景" class="headerlink" title="敏捷开发适应场景"></a>敏捷开发适应场景</h3><ul><li>团队要小，人数超过一定规模就要分拆；</li><li>团队成员之间要紧密协作，客户也要自始至终深度配合；</li><li>领导们的支持。敏捷需要扁平化的组织结构，更少的控制，更多的发挥项目组成员的主动性；</li><li>写代码时要有一定比例的自动化测试代码，要花时间搭建好源码管理和持续集成环境。</li></ul><h2 id="敏捷方法案例"><a href="#敏捷方法案例" class="headerlink" title="敏捷方法案例"></a>敏捷方法案例</h2><h3 id="基于Ticket的开发流程"><a href="#基于Ticket的开发流程" class="headerlink" title="基于Ticket的开发流程"></a>基于Ticket的开发流程</h3><p>看板：把白板分成几个栏，每一栏为一类，分别写着“To Do（待选取）”、“In Progress（进行中）”、“Done（完成）”等，再把工作任务变成一个个五颜六色的即时贴，根据状态贴在不同的栏下面。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/33752b50f5363233581263e882e19aa9.jpg" alt="看板开发流程"></p><p>慢慢的物理的看板变成了电子看板，通过各种项目管理软件来管理跟踪这些任务，即时贴也变成了 Ticket（也有叫 Issue 的）：</p><ul><li>报一个 Bug，提交一个 Ticket ；</li><li>提一条需求，提交一个 Ticket ；</li><li>要重构一下代码，提交一个 Ticket 。</li></ul><p>大家每天上班第一件事就是打开看板，看看当前 Sprint 还有哪些 Ticket 没有完成，哪些已经完成，哪些正在进行中，非常直观。作为项目成员来说，做完手头的事情也不用去问项目经理该干什么事情了，直接从 To Do 栏选一条 Ticket 做就是了；对于项目经理，看看 To Do 栏还有多少没有被选取，就知道还剩多少 Ticket 没完成，看看 In Progress 栏就知道哪些 Ticket 正在进行中。</p><h3 id="基于-Git-和-CI-的开发流程"><a href="#基于-Git-和-CI-的开发流程" class="headerlink" title="基于 Git 和 CI 的开发流程"></a>基于 Git 和 CI 的开发流程</h3><p><strong>Git</strong> 本来只是源代码管理工具，但是其强大的分支管理和灵活的权限控制，结合一定的开发流程，可以帮助很好的控制代码质量。</p><ul><li><p>假设现在 master 的代码是稳定的，那么怎么保证新加入的代码也稳定呢？</p><p>答案就是<strong>代码审查（Code Review）和自动化测试</strong>。如果代码有严格的审查，并且所有自动化测试代码都能测试通过，那么可以认为代码质量是可靠的。当然前提是自动化测试代码要有一定的覆盖比率。</p></li><li><p>如何在合并到 master 之前把代码审查和自动化测试做好呢？</p><p>每次要往 master 添加内容，不是直接提交代码到 master，而是先基于当前稳定的 master，克隆一个 branch（分支）出来，基于 branch 去开发，开发完成后提交一个 PR（Pull Request，合并请求）。</p></li></ul><p><strong>CI （持续集成）</strong>可以想象成一个机器人，每次提交一个 PR（严格来说是 Commit）到源代码服务器，这个机器人马上就知道了。它会创建一个干净的运行环境，把提交的代码下载下来，再下载安装所有依赖项，然后运行所有测试代码，运行完后，测试结果直观的反馈在 PR 上，绿色表示通过，红色表示不通过。</p><p>当一个 PR 代码审查通过，以及 CI 通过了所有自动化测试，就可以合并到 master 了。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/be26482df2715220b0dc2f90f034bd12.jpg"></p><h3 id="敏捷开发方法的基本开发流程"><a href="#敏捷开发方法的基本开发流程" class="headerlink" title="敏捷开发方法的基本开发流程"></a>敏捷开发方法的基本开发流程</h3><ul><li>把要开发的 Ticket 从“To Do”栏移动到“In Progress”栏；</li><li>从主干（master）创建一个分支（branch），基于分支去开发功能或修复 Bug；</li><li>编写实现代码和测试代码（单元测试和集成测试），是不是测试驱动不重要，看个人偏好或团队要求；</li><li>持续提交代码更新到分支，直到完成；</li><li>创建 PR（Pull Request，合并请求），邀请其他人帮忙 Review 代码，根据 Review 的结果，可能还需要更新几次；</li><li>CI 在每一次提交代码到代码库后都会自动运行，运行后主要做这些工作：<ul><li>检查代码格式是不是符合规范；</li><li>运行单元测试代码；</li><li>运行集成测试。</li></ul></li><li>最终这些检查都完成后，CI 会把执行结果显示在 PR 上。通常绿色表示通过，红色表示失败；</li><li>PR 能合并需要满足两个条件：CI 变绿 + 代码 Review 通过；</li><li>PR 合并后，CI 会自动构建 Docker Image，将 Image 部署到开发环境；</li><li>将相应的 Ticket 从看板上的“In Progress”栏移动到“Done”栏。</li></ul><h3 id="部署上线流程"><a href="#部署上线流程" class="headerlink" title="部署上线流程"></a>部署上线流程</h3><p>以前是运维人员按照文档部署，现在已经变成 <strong>DevOps 写自动化部署工具</strong>，然后开发人员自己去部署生产环境。</p><ul><li>首先，部署的不再是程序代码，而是 Docker 的 Image，每次代码合并后 CI 都会自动生成新的 Image，测试也是基于 Image 测试。</li><li>部署生产环境之前，先在内部的测试环境充分测试。</li><li>部署生产环境前，需要审批确认，有 Ticket 跟踪。</li><li>部署时，先部署一部分，监测正常后再全量部署。</li><li>整个过程都有监控报警，出现问题及时回滚。</li></ul><h2 id="软件质量与时间成本"><a href="#软件质量与时间成本" class="headerlink" title="软件质量与时间成本"></a><strong>软件质量与时间成本</strong></h2><h3 id="软件项目管理金三角"><a href="#软件项目管理金三角" class="headerlink" title="软件项目管理金三角"></a>软件项目管理金三角</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/7fa5c8351b4590a2bc8a482955c133f7.jpg"></p><p>软件质量（产品的质量，客户的满意度）与范围（需要实现多少功能）、时间（多久可以完成）、成本（花多少钱）四个要素之间的平衡。</p><p><strong>项目的质量是高于一切的。</strong>因此把“质量”放在三角形中间，然后在时间、成本、范围这三条边之间寻求平衡。</p><h3 id="瀑布模型和敏捷开发如何平衡时间成本范围的关系"><a href="#瀑布模型和敏捷开发如何平衡时间成本范围的关系" class="headerlink" title="瀑布模型和敏捷开发如何平衡时间成本范围的关系"></a>瀑布模型和敏捷开发如何平衡时间成本范围的关系</h3><p><strong>瀑布模型的范围是固定的，其他两条边时间和成本是变量。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/27e916733d013fa85b2964a2b1051ea0.jpg"></p><p><strong>在敏捷开发中，时间和成本两条边是固定，就只有范围这条边是变量。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/1yy45e28893d0b4652e780d47f0a2873.jpg"></p><h3 id="如何平衡好软件质量与时间成本范围的关系"><a href="#如何平衡好软件质量与时间成本范围的关系" class="headerlink" title="如何平衡好软件质量与时间成本范围的关系"></a>如何平衡好软件质量与时间成本范围的关系</h3><p><strong>最多选择两样，然后在另一边或者另两条边去寻找平衡。</strong></p><p>从时间、成本和范围这三条边中找出来固定的一条或者两条边，再去调整另一条边。</p><ul><li>淘宝网站第一个版本，直接买一个网站，再雇一堆牛人，所以淘宝网站仅用一个月上线。</li><li>极限编程中，一个Sprint 要做的内容是确定的，相当于成本和范围这两条边都固定了，时间这条边就成为变量了。要么通过加班延长工作时间，要么通过提升效率、减少浪费帮助我们提升时间利用率。</li><li>MVP（minimum viable product，最小化的可行性产品）模式，快速推出产品，并要求成本不用太高，那就意味着时间和成本这两条边是固定的，剩下范围这个变量。所以最简单有效的办法就是砍掉一些重要性不那么高的功能需求，只保留最核心的需求。</li></ul><h2 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a><strong>可行性分析</strong></h2><blockquote><p>“可行性研究主要从哪几个方面进行？”</p></blockquote><blockquote><p>对于软件项目的可行性研究，主要从以下几个方面入手：</p><p>经济可行性：从成本和收益角度分析，看投入产出比。不仅要分析短期利益，还要分析长期利益，看是不是值得做。</p><p>技术可行性：软件项目最终是需要人通过技术来实现的，所以要分析技术上是不是可行，如果有技术上解决不了的问题又能否规避。</p><p>社会可行性：社会可行性涉及法律、道德、社会影响等社会因素。比如，触犯国家法律的事情肯定不能做；产品如若不符合道德标准，可能带来较大的社会负面影响，那么也要慎重考虑。</p></blockquote><h3 id="为什么软件项目很少做可行性研究"><a href="#为什么软件项目很少做可行性研究" class="headerlink" title="为什么软件项目很少做可行性研究"></a>为什么软件项目很少做可行性研究</h3><p>可行性研究是基于问题和解决方案来分析的，先立项才能慢慢搞明白需求是什么，然后才能有解决方案；而只有搞明白需求是什么，以及解决方案是什么，才能去做可行性研究。</p><p>而软件项目很抽象，在立项之前对于问题的描述（需求）和解决方案（技术方案）通常都是模糊不清的，只有随着项目的推进，才能逐步搞清楚需求。</p><p>可能项目需求最开始是模糊不清的，还不具备可行性研究的条件，那么等到项目有了一定的进展，需求逐步明确后，要继续对可行性做研究。</p><p><strong>如果发现方案不具备可行性，也应及时调整方案或停止项目以止损。</strong></p><h3 id="如何做好可行性研究"><a href="#如何做好可行性研究" class="headerlink" title="如何做好可行性研究"></a>如何做好可行性研究</h3><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/ffcf64bafc95994c75db0b26e91179e9.png" alt="经济可行性"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/8ff84a8cd3c2ac358d7b64d51296425d.png" alt="技术可行性"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/c6c533c98fad3ba2f9b4dfa4691b5c75.png" alt="社会可行性"></p><h2 id="管理一个软件项目"><a href="#管理一个软件项目" class="headerlink" title="管理一个软件项目"></a>管理一个软件项目</h2><h3 id="怎样管好软件项目中的人"><a href="#怎样管好软件项目中的人" class="headerlink" title="怎样管好软件项目中的人"></a>怎样管好软件项目中的人</h3><p>软件项目管理的一个维度是管人。项目管理中的人，主要涉及两类：客户和项目成员。</p><ol><li><p><strong>管理好客户的预期</strong></p><p>想要满足客户预期，通常来说，就是你能在项目的质量、范围、时间和成本上达到要求。</p><ul><li>质量达标：交付产品是高质量的，满足客户需求的。</li><li>完整交付：按照约定的功能范围交付最终产品。</li><li>按时交付：项目按照客户认可的进度完成。</li><li>预算之内：在预算内完成项目。</li></ul></li><li><p><strong>用流程和规范让项目成员一起紧密协作</strong></p><p><strong>好的项目管理，不需要直接去管人，而是管理好流程规范；项目成员不需要按照项目经理的指令做事，而是遵循流程规范。</strong></p></li></ol><h3 id="怎样管好软件项目中的事"><a href="#怎样管好软件项目中的事" class="headerlink" title="怎样管好软件项目中的事"></a>怎样管好软件项目中的事</h3><ol><li><p><strong>选择适合项目的开发模式</strong></p><p>首先就是要根据项目特点选取合适的开发模式，是敏捷开发还是瀑布模型或者瀑布模型的衍生模型？是一步到位还是逐步迭代？开发模式选好了后，还需要配套的流程规范，以及合适的工具，以保障开发模式的执行。</p></li><li><p><strong>制定好项目计划</strong></p><p>选择好开发模式后，紧接着就是要做好项目计划，有了项目计划，才能有计划有目的地去推动项目进展，出现问题也能及时发现、及时调整。</p></li><li><p><strong>对计划进行跟踪和控制，同时做好风险管理</strong></p><p>实际执行难免会和计划有些出入，所以还需要对计划进行跟踪和控制。当项目的推进过程中，如果计划有出入时，需要分析原因，对计划做出调整。</p></li></ol><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/36e001d1d632d027f3ada5080c70dc5e.jpg"></p><h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><h3 id="如何制定计划"><a href="#如何制定计划" class="headerlink" title="如何制定计划"></a>如何制定计划</h3><p>三个基本步骤：</p><ul><li>第一步：任务分解；</li><li>第二步：估算时间；</li><li>第三步：排任务路径。</li></ul><p><strong>1.任务分解</strong></p><p><strong>工作分解结构（Work Breakdown Structure, WBS)：</strong></p><p><strong>就是把要做的事情，按照一个树形结构去组织，逐级分解，分割成小而具体的可交付结果，直到不能再拆分为止。</strong></p><p>在制定计划时，除了要拆分任务，还需要反复思考各种可能存在的问题。</p><p><strong>2.估算时间</strong></p><p>任务分解完之后，就需要对每一个任务估算时间。</p><p>要想估算准确，需要从两个方面入手：</p><ul><li>任务拆分的越细致，想的越清楚，就能估算的越准确。</li><li>要让负责这个任务的人员参与估算。</li></ul><p><strong>3.排路径</strong></p><p>项目中有些任务是可以并行做的，而有些任务之间则是有依赖关系的。</p><p><strong>排路径就是要根据任务之间的关系，资源的占用情况，排出合适的顺序。</strong></p><h3 id="设置里程碑"><a href="#设置里程碑" class="headerlink" title="设置里程碑"></a>设置里程碑</h3><p>里程碑的设置，并没有特别的规则，可以是项目生命周期的特定主要时间，也可以是一些关键的时间点。</p><p>在项目的推进过程中，根据里程碑完成的情况，你就可以很直观地知道项目的进展如何。如果发现不能如期完成里程碑，就需要进行适当的调整了，例如加班，或者砍掉一些功能需求。</p><h3 id="计划需要跟踪和调整"><a href="#计划需要跟踪和调整" class="headerlink" title="计划需要跟踪和调整"></a>计划需要跟踪和调整</h3><p>项目的跟踪是很必要的，可以了解计划的执行情况，了解成员的工作情况，是否能按时完成，需要什么样的帮助。</p><p>敏捷开发的两个实践：</p><p><strong>1.每日站立会议</strong></p><p>​在每天的站立会议上，每个项目成员都需要说一下自己昨天做了什么，明天计划做什么，有没有什么阻碍。通过这种方式，可以非常好的了解每个人的任务进展情况，同时对于成员遇到的困难，其他人也可以及时给予支持。</p><p><strong>2.看板</strong></p><p>​通过看板，可以非常直观的看到每个人在干什么，进展如何。</p><h2 id="流程和规范"><a href="#流程和规范" class="headerlink" title="流程和规范"></a><strong>流程和规范</strong></h2><h3 id="为什么要有流程规范"><a href="#为什么要有流程规范" class="headerlink" title="为什么要有流程规范"></a>为什么要有流程规范</h3><p><strong>1.提升团队效率：</strong></p><p>​从个体来看，因为流程规范的存在，确实可能存在效率降低的情况，但从团队的角度来看，好的流程规范反而是提升效率的。</p><p><strong>2.将好的实践标准化流程化，经验共享：</strong></p><p>​早些年的软件项目，就是个人英雄主义盛行的时代，项目的成败极其依赖于个别厉害的项目经理或者技术高手，而这种牛人，总是稀缺的存在。据此形成一套套的代码规范，其他水平一般的程序员，按照代码规范，也能写出不错的代码。</p><p><strong>3.借助流程规范，让项目管理从人治到“法治”</strong></p><p><strong>好的项目管理，不需要直接管人管事，而是管理好计划和流程规范；项目成员不需要按照项目经理的指令做事，而是遵循计划和流程规范。</strong></p><p><em><strong>流程规范，看起来是约束，实际上用的好的话，不仅可以提高团队效率，还可以将好的实践标准化流程化，让大家可以共享经验，还可以有效的管理项目。</strong></em></p><h3 id="如何制定好流程规范"><a href="#如何制定好流程规范" class="headerlink" title="如何制定好流程规范"></a>如何制定好流程规范</h3><p><strong>制定流程规范的四个步骤：</strong></p><p><strong>1. 明确要解决的问题</strong></p><p>要制定一个流程规范，第一步就是明确是要解决什么样的问题。项目中很多问题，都可以思考是不是能通过流程解决。</p><p><strong>2. 提出解决方案</strong></p><p>提出解决方案，制定开发流程时，可以参考借鉴软件工程中公认的好的实践：</p><ul><li><strong>敏捷开发的流程：</strong>看板、站立会议、持续集成。</li><li><strong>代码规范：</strong>例如说前端的有 Airbnb 的代码规范 <a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a>，Java 的有 <a href="http://google.github.io/styleguide/javaguide.html">Google Java Style Guide </a>，.Net 的有<a href="http://docs.microsoft.com/en-us/dotnet/standard/index">.NET Guide</a>，等等。</li><li><strong>源代码管理流程：</strong>现在的源代码主流是 git，而基于 Git 的代码管理已经有很多成熟的流程规范可以参考。例如阮一峰老师写过的<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a>，<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a>和<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a>，或者 Github 官方出品的<a href="https://guides.github.com/introduction/flow/index.html">Understanding the GitHub flow</a>，Gitlab 官方推荐的<a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html#introduction-to-gitlab-flow">Introduction to GitLab Flow</a>。</li><li><strong>部署流程：</strong>现在主流的部署流程为<strong>持续部署</strong>，每次代码合并到主分支都可以触发一次自动部署，这样一有问题，就能马上知道发生在哪个环节。</li></ul><p><strong>3. 达成共识，推广执行</strong></p><p><strong>4. 持续优化，不断改进</strong></p><p><strong>将流程规范工具化：</strong></p><ol><li>以前代码规范的执行，主要靠反复的教育宣传和代码审查中一个个去检查；现在，借助 VSCode 这种强大的 IDE，以及 ESLint 这种代码检查工具，可以方便的检测出不符合规范的代码，甚至于可以直接格式化成满足代码规范的格式。</li><li>保证代码质量的问题，早些年必须依赖测试人员大量手工的测试，而现在借助 CI（Continuous Integration，持续集成）、自动化测试和 Git，可以保证代码必须在通过测试以后，才会合并到主分支，从而很好的保证了代码的质量。</li></ol><h2 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a><strong>项目管理工具</strong></h2><p>一切管理问题，都应思考能否通过工具或技术解决，如果当前工具或技术无法解决，暂时由流程规范代替，同时不停止寻找工具和技术。</p><h3 id="项目管理工具软件发展史"><a href="#项目管理工具软件发展史" class="headerlink" title="项目管理工具软件发展史"></a>项目管理工具软件发展史</h3><ol><li><p>最初的项目管理软件：项目计划工具</p><p>早些年软件项目的开发以瀑布模型为主，瀑布模型的这种按阶段划分的开发模式，和 WBS （工作分解结构）这种将任务层层分解的理念不谋而合，<strong>MS Project</strong> 这种软件可以非常好的将所有任务分解、制订计划，按照计划跟踪执行。但其不方便跟踪任务进度，进度不直观。</p></li><li><p>基于 Ticket 的任务跟踪系统</p><p>一个 Ticket应该包含：</p><ul><li>标题：摘要性的描述 Ticket 内容；</li><li>类型：属于什么类型的 Ticket：Bug、需求、任务；</li><li>内容：Ticket 的详细内容，例如，如果是 Bug 的话，除了要写清楚 Bug 内容，还需要重现步骤。如果是需求的话，要有需求的描述，可能还需要额外的文档链接辅助说明；</li><li>创建人：谁创建的这条 Ticket；</li><li>优先级：这个 Ticket 的优先级高还是低；</li><li>状态：Ticket 的状态，例如：未开始、处理中、已解决、重新打开、关闭等；</li><li>指派给谁：这个 Ticket 被指派给谁了，谁来负责；</li><li>历史记录：整个 Ticket 改变的历史信息，用以跟踪；</li></ul></li><li><p>基于看板的可视化任务管理</p></li></ol><h3 id="有哪些项目管理软件"><a href="#有哪些项目管理软件" class="headerlink" title="有哪些项目管理软件"></a>有哪些项目管理软件</h3><p>项目计划工具，功能最好、最全的应该是微软的<a href="http://products.office.com/zh-CN/project/">MS Project</a>，但遗憾的是只能运行在 Window 上，不支持 Mac 平台。如果要在 Mac 上使用项目计划工具，可选的有<a href="http://www.omnigroup.com/omniplan">OmniPlan</a>和<a href="http://www.projectwizards.net/en">Merlin Project</a>。</p><p>基于 Ticket 的任务跟踪系统，最有名的应该是<a href="http://www.atlassian.com/">Atlassian</a>公司出品的<a href="https://www.atlassian.com/software/jira">Jira</a>软件，功能全面，体验很好。同类产品也很多，微软的<a href="http://visualstudio.microsoft.com/zh-hans/tfs/?rr=https://shimo.im/docs/5A0wCnmLwn0nCjE9">Azure DevOps</a> （以前叫 TFS, Team Foundation Server），和微软系的产品如 Visual Studio、Azure 可以很好的整合。</p><p>代码托管平台GitHub本身也集成了一套 Issue 跟踪管理系统，虽然没有 Jira 那么强大，但是对于普通项目来说，足够用了。尤其是对于开源项目，完全可以基于 GitHub 的 Issue 进行日常的项目管理。</p><p>国内同类的软件有：</p><ul><li>禅道：为数不多提供开源版本可以自己搭建的；</li><li>Worktile：集成了即时消息软件；</li><li>TAPD：腾讯出品，可以和腾讯的服务很好整合，例如企业微信和腾讯云；</li><li>云效：阿里巴巴出品，可以和阿里的服务很好整合，例如阿里云和钉钉；</li><li>DevCloud：华为出品，和华为云有很好的整合。</li></ul><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a><strong>风险管理</strong></h2><h3 id="什么是风险管理"><a href="#什么是风险管理" class="headerlink" title="什么是风险管理"></a>什么是风险管理</h3><p><strong>风险 = 损失 x 发生概率</strong></p><p>风险管理就是指在项目进行过程中，识别可能的风险，对风险进行评估，并加以监控，从而减少风险对项目的负面影响。</p><h3 id="如何做好风险管理"><a href="#如何做好风险管理" class="headerlink" title="如何做好风险管理"></a>如何做好风险管理</h3><ol><li><p><strong>培养风险意识</strong></p><p>项目中的任务，不能盲目乐观，都思考一下它最坏的结果是什么，如果最坏的结果不能接受，就说明要有个 B 计划，考虑风险管理了。</p></li><li><p><strong>管理风险</strong></p><ul><li><p><strong>风险识别，识别可能的风险</strong></p><p><strong>检查表法</strong>：把常见风险收集整理起来，分类列成清单，按照清单去检查对照。</p><p>软件项目的风险主要分成以下几类：</p><ul><li>项目风险：项目预算、进度、用户和需求等方面的问题；</li><li>人员风险：人员离职、人手不足等问题；</li><li>技术风险：采用的技术所可能带来的风险；</li><li>商业风险：与市场、产品策略等有关的商业风险。</li></ul></li><li><p><strong>风险量化，对风险进行评估量化</strong></p><p>对于概率大，后果严重的风险，需要高优先级重点考虑；对于概率不高但后果严重的问题也要考虑，不过优先级略低；对于概率高但后果不严重的风险事件，可以优先级很低或者不考虑；对于概率低后果不严重的，则可以不予考虑。</p></li><li><p><strong>应对计划，对风险制定应对策略</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/1f0834c11f675e1846779134746903d5.jpg"></p><ul><li><p><strong>回避风险——更改导致风险的方案</strong></p><p>对可能发生的风险，放弃或者修改导致风险的方案。这样就从根源上消除了风险，简单而彻底。不一定适合所有情况，例如拼多多“无门槛券”的风险，就无法采用这种方案。</p></li><li><p><strong>转移风险——将损失转嫁出去</strong></p><p>举例来说，如果团队对于服务器管理不是很在行，有可能会遇到服务器宕机或数据库丢失数据等风险，就可以考虑购买云服务，这样云服务商会帮你解决服务器宕机或数据库丢失的问题，而且万一宕机或丢数据了他们也会承担一定的责任。</p></li><li><p><strong>缓解风险——降低风险发生概率或减少可能造成的损失</strong></p><p>在风险发生前采取一定措施，降低风险发生的概率，或者减少风险可能造成的损失。</p></li><li><p><strong>接受风险——明知山有虎偏向虎山行</strong></p><p>有一些风险本身很难避免，或者去应对这个风险的成本超过风险发生后造成的损失，那么就没必要应对，直接选择承担风险后果就好了。</p></li></ul></li><li><p><strong>风险监控，对风险进行监控预警</strong></p><p>如果风险可以监控，可以预知风险即将发生，或者可以在风险发生后，第一时间知道，那么就可以马上对风险进行干预，避免变成更大的问题。</p><p>要做好监控，第一要能对监控的内容量化，第二要设置阈值，第三就是要有后续的报警和处理机制。</p><p>很多公司都已经建立了自己的监控系统，将关键数值量化，并设置阈值，超过阈值后自动触发报警机制。</p><p>一个简单的例子就是服务器宕机了，监控系统发现机器没响应了，自动通过邮件、短信、电话等方式通知正在值班的人员。</p></li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/11b6e81fd2baffcb0c025bb56c71e130.jpg"></p></li></ol><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a><strong>项目文档</strong></h2><h3 id="为什么要写文档"><a href="#为什么要写文档" class="headerlink" title="为什么要写文档"></a>为什么要写文档</h3><ul><li><p><strong>帮助写文档的人理清楚思路</strong></p><p><strong>先写文档，就会抛开代码细节，去站在全局思考。</strong>写的时候，各个模块之间的依赖关系、各种可能的安全隐患、各种可能需要其他人配合的地方，就都冒出来了，必须要去查资料，去找人讨论，反复缜密的思考后最终写出来。</p></li><li><p><strong>便于未来的维护和交接</strong></p><p>如果需要长期维护，就需要一定的文档，把设计、操作流程、环境配置等内容记录下来。</p></li><li><p><strong>便于团队更好的协作沟通</strong></p></li></ul><h3 id="如何写好文档"><a href="#如何写好文档" class="headerlink" title="如何写好文档"></a>如何写好文档</h3><ol><li><p><strong>从模仿开始</strong></p></li><li><p><strong>从小文档开始</strong></p></li><li><p><strong>从粗到细，迭代更新</strong></p></li><li><p><strong>基本的画图的技巧</strong></p><ul><li><p>线框图</p><p>用简单的方框代替功能、模块、服务等，再用箭头表示关系或者数据流向。主要是要理清楚有哪些模块，以及模块之间的关系是什么；用方框配上文字表示模块，方框之间的连线和箭头表示关系。</p></li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/1789cf7139c74de3a5667d50dd8406fb.png" alt="Twitter缓存方案"></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/d11279dd5d943264f190c22578b21e4e.png" alt="Netflix的账单系统架构图"></p><ul><li><p>流程图</p><p>表示各种不同条件下的逻辑路径。重点是要理清楚逻辑关系，各个关键节点在不同条件下的走向。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/c310f2fdef032b99c659deac5857d2fa.jpeg" alt="重置密码流程图"></p></li><li><p>时序图</p><p>表示不同对象之间发送消息的时间顺序，尤其在涉及网络通信的文档中特别常用。画好时序图，关键是要列清楚所有涉及的对象或者服务，以及消息发送的先后顺序。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/0234da35f3bc080864a99d5ea755e25f.png"></p></li><li><p>各种格式截图</p><p>把软件的 UI、交互设计的效果、数据趋势图、数据统计图等直接截图，必要的话配上一些箭头、文字，也可以很好的说明清楚问题。尤其是产品设计文档，经常用到。</p></li></ul></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h2><h3 id="什么是需求"><a href="#什么是需求" class="headerlink" title="什么是需求"></a>什么是需求</h3><p>用户需求是由用户提出来的，期望满足自身一定需要的要求；</p><p>产品需求就是在分析提炼用户真实需求后，提出的符合产品定位的解决方案。</p><h3 id="需求分析是要分析什么"><a href="#需求分析是要分析什么" class="headerlink" title="需求分析是要分析什么"></a>需求分析是要分析什么</h3><ol><li><p><strong>挖掘真实需求</strong></p><p>要分析用户的真实需求，可以从三个角度入手：</p><ol><li>目标用户：用户不同，诉求也不一样；</li><li>使用场景：使用场景不一样，解决方案也会有所不同；</li><li>想要解决的问题：用户背后想要解决的问题是什么。</li></ol></li><li><p><strong>提出解决方案</strong></p><p>知道了目标用户，其使用场景和想要解决的问题，就可以结合产品定位，提出相应的解决方案。</p></li><li><p><strong>筛选和验证方案</strong></p><p>在传统瀑布模型中，选定方案后，会写成产品设计文档，走相应的评审流程，评审完成后再进行设计、开发和测试，测试完成后会让客户再进行验收。而敏捷开发，在整个开发过程中，每个迭代或者关键的里程碑，也一样需要客户进行验收。</p></li></ol><h3 id="怎样做需求分析"><a href="#怎样做需求分析" class="headerlink" title="怎样做需求分析"></a>怎样做需求分析</h3><p>整个过程是迭代进行的，如下所示：</p><ul><li>收集需求：对用户需求进行收集整理；</li><li>分析需求：对需求进行分析，挖掘用户真实需求；</li><li>需求评估：筛选过滤掉不可行的需求；</li><li>需求设计：针对用户需求提出解决方案，设计成产品方案；</li><li>验证需求：验证方案是否可行。</li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/b4f5e9676ed215c1d80da73a15281776.jpg"></p><h2 id="原型设计"><a href="#原型设计" class="headerlink" title="原型设计"></a><strong>原型设计</strong></h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>快速原型模型就是，<strong>第一阶段确认界面布局和内容，第二阶段确认交互，第三阶段实现。</strong></p><ul><li><p>低保真原型设计</p><p>用线框图来代替第一阶段。线框图画起来简单，纸和笔就可以，展示效果不错，通过线框图可以直观地看到界面上有什么，布局是什么样的。</p><p>缺点也很明显，就是看起来不够真实，不方便反映界面之间的关系，另外也不能反映界面交互。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/6a121d4c74a1daffdf8d39833ef24bde.png"></p></li><li><p>中等保真原型设计</p><p> Axure 这样专业的原型设计软件产生，不仅可以反映界面上的布局和内容，还可以展示网站整体结构和交互，可以达到前面快速原型开发前两个阶段同等效果。</p><p>不能做到 100% 真实，因为它在界面的真实度、色彩上要比最终产品差一些，所以也被称之为中等保真原型。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/00f3aa9d97f1ab7171653bcb4bcc9419.png"></p></li><li><p>高保真原型设计</p><p>高保真原型的学习成本和制作成本都要高于低保真原型，所以变更成本更高，而且也很容易导致产品经理花大量时间在细节的调整上，影响整体的进度。所以通常高保真都会和低保真原型设计配合使用，先用低保真原型快速确认清楚需求，再用高保真原型确认最终的交互和 UI 设计。</p></li></ul><h3 id="怎么做好原型设计"><a href="#怎么做好原型设计" class="headerlink" title="怎么做好原型设计"></a>怎么做好原型设计</h3><ol><li><p><strong>分析</strong></p><p>要对用户的需求有个初步的了解，分析清楚原型设计的目标是什么。</p></li><li><p><strong>设计</strong></p><ul><li><p>画产品的信息结构图</p><p>想清楚产品有哪些功能模块，模块之间的关系如何，哪些模块是公共的，哪些模块是面向不同用户显示不同内容的。</p></li><li><p>画产品使用流程图</p><p><strong>用流程图把这些界面之间跳转的逻辑梳理清楚</strong>。不仅要考虑正常使用的流程，同时也要考虑清楚异常的情况。</p></li></ul></li><li><p><strong>实施</strong></p><p><strong>要优先考虑满足产品需求，然后是让界面好看好用</strong></p></li><li><p><strong>验证</strong></p><p>产品经理自己反复验证几遍，如果发现有流程上走不通或者使用不方便的地方先自己调整。调整好了交给其他人去体验，让他们提出反馈意见。</p></li></ol><h3 id="如何选择合适的原型设计工具"><a href="#如何选择合适的原型设计工具" class="headerlink" title="如何选择合适的原型设计工具"></a>如何选择合适的原型设计工具</h3><p><strong>Axure RP</strong>：Axure RP 曾一度是原型设计工具的代名词，历史悠久功能强大，可以制作网站、桌面软件、移动 App 的原型。 缺点是专业度较高，价格高。</p><p><strong>墨刀</strong>：墨刀 是一款优秀的国产原型设计工具，可以制作网站、桌面软件、移动 App 的原型。上手相对容易，价钱也较 Axure 便宜很多。</p><p><strong>Adobe XD</strong>：Adobe XD 是 Adebe 出的一款设计兼原型设计工具，可以制作出高保真原型，对于设计师尤其容易上手。</p><p><strong>ProtoPie</strong>：ProtoPie 是一款高保真原型设计工具，不需要编程基础，可以做出逼真强大的交互效果。</p><p><strong>Framer X</strong>：Framer X是一款高保真的原型设计工具，功能很强大，但是需要一定的编程基础，尤其适合程序员使用。</p><h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a><strong>需求变更</strong></h2><h3 id="如何解决需求变更"><a href="#如何解决需求变更" class="headerlink" title="如何解决需求变更"></a>如何解决需求变更</h3><ul><li><strong>提升需求确定性，把需求分析做好，减少需求变更；</strong></li><li><strong>提高需求变更的成本，让客户或者产品经理不能太容易就变更需求，这样就可以达到减少需求变更的目的。</strong></li><li><strong>降低响应需求变更的成本，可以方便快捷地响应需求变更。</strong></li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a><strong>架构设计</strong></h2><h3 id="为什么软件项目需要架构设计"><a href="#为什么软件项目需要架构设计" class="headerlink" title="为什么软件项目需要架构设计"></a>为什么软件项目需要架构设计</h3><p>复杂的软件项目，通常有两个特点：<strong>需求不确定和技术复杂</strong>。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9e7f7a98e8909ac6646c19a3ac632fc6.jpg"></p><ol><li><p><strong>架构设计可以降低满足需求和需求变化的开发成本</strong></p><p>架构设计通过对系统抽象和分解，把复杂系统拆分成若干简单的子系统。</p><p>比如淘宝这样复杂的网站，最终拆分成一个个小的微服务后，单个微服务开发的难度，其实和个人博客网站的难度已经差不太多了，普通程序员都可以完成，降低了人力成本。</p></li><li><p><strong>架构设计可以帮助组织人员一起高效协作</strong></p><p>通过对系统抽象，再拆分，可以把复杂的系统分拆。分拆后，开发人员可以各自独立完成功能模块，最后通过约定好的接口协议集成。</p><p>比如前后端分拆后，有的开发人员就负责前端 UI 相关的开发，有的开发人员就负责后端服务的开发。根据团队规模还可以进一步细分，比如说前端可以有的程序员负责 iOS，有的程序员负责网站，这样最终各个开发小组规模都不大，既能有效协作，又能各自保证战斗力。</p></li><li><p><strong>架构设计可以帮助组织好各种技术</strong></p><p>架构设计可以用合适的编程语言和协议，把框架、技术组件、数据库等技术或者工具有效的组织起来，一起实现需求目标。</p><p>比如经典的分层架构，UI 层通过选择合适的前端框架，例如 React/Vue 实现复杂的界面逻辑，服务层利用 Web 框架提供稳定的网络服务，数据访问层通过数据库接口读写数据库，数据库则负责记录数据结果。</p></li><li><p><strong>架构设计可以保障服务稳定运行</strong></p><p>比如说分布式的架构，可以把高访问量分摊到不同的服务器，这样即使流量很大，分流到单台服务器的压力并不大；还有像<a href="https://developer.aliyun.com/article/57715">异地多活</a>这样的架构方案可以保证即使一个机房宕机，还可以继续提供服务。</p></li></ol><h3 id="什么是架构设计"><a href="#什么是架构设计" class="headerlink" title="什么是架构设计"></a>什么是架构设计</h3><p>架构设计的目标：<strong>用最小的人力成本来满足需求的开发和响应需求的变化，用最小的运行成本来保障软件的运行。</strong></p><p><strong>组织人员和技术把系统和团队拆分，并安排好切分后的排列关系，让拆分后的部分能通过约定好的协议相互通信，共同实现最终的结果。</strong></p><h3 id="如何做好架构设计"><a href="#如何做好架构设计" class="headerlink" title="如何做好架构设计"></a>如何做好架构设计</h3><p>假设现在要设计第一版本极客时间服务端的架构，只有专栏课程一个核心功能，目标用户访问量是日 PV 上万，峰值每秒 10 个左右访问，对稳定性要求高。</p><ol><li><p><strong>分析需求</strong></p><p>一个常用的分析方法就是分析用例，也就是了解主要用户角色和其使用的场景。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/af6b79d303f126d9e2f547b1a604ef22.png"></p></li><li><p><strong>选择相似的成熟的架构设计方案</strong></p><p>在了解清楚需求后，就可以从业界成熟的架构设计模式中选取一个或几个。</p><p>本例是一个典型的网站架构，可以基于传统的分层架构来实现。分层架构按照<strong>水平方向</strong>将系统拆分成几个层，每层都有清晰的角色和分工，不需要关心其他层的细节。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/eb230b721a36aaed80afbfd7641abf88.png"></p></li><li><p><strong>自顶向下层层细化</strong></p><ul><li><p>部署架构</p><p>基于云服务设计部署架构，选购云数据库和文件存储，选购虚拟机作为网站服务器。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/35e9e957e0b6a304704bb15ec2b00696.png"></p><p>稳定性还不够高，万一数据库挂了或者网站服务器挂了，都可能会让服务中断一段时间。</p><p>可以增加一台异地网站服务器和一个异地云数据库实例作为备份，这样一旦网站宕机或者数据库有问题，可以切换到备机，马上恢复访问。所以调整后架构如下：</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/35f3abd053654cd23896c7259d5258c0.png"></p></li><li><p>分层和分模块</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/410b864fd8d6cc34cb20eef07e46acd6.png"></p></li><li><p>API 设计、数据库设计、模块的设计</p></li></ul></li><li><p><strong>验证和优化架构设计方案</strong></p><p>需要去验证方案是不是满足设计的目标，能否满足需求和未来需求的变化，能否保障软件有效地运行。</p></li></ol><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h2><h3 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h3><ul><li>受制于时间、范围和成本的约束</li><li>要分析可行性和风险</li><li>要考虑利益相关人</li><li>避免项目决策中常见的坑<ul><li>把听到的观点当事实</li><li>先入为主，有了结论再找证据</li></ul></li></ul><h3 id="如何做好技术选型"><a href="#如何做好技术选型" class="headerlink" title="如何做好技术选型"></a>如何做好技术选型</h3><p>可以分成：<strong>问题定义、调研、验证、决策</strong>这几个阶段。</p><ol><li><p>问题定义</p><p>很多时候为了解决问题引入一个新技术，然而真的需要吗？也许我们可以基于现有技术方案进行优化，根本就不需要引入一个新的技术或新的框架。</p></li><li><p>调研</p><p>看有哪些技术选型可以满足目标，包括开源的方案和商业的方案：</p><ul><li>满足技术选型目标吗？</li><li>满足范围、时间和成本的约束吗？</li><li>是不是可行？</li><li>有什么样的风险？风险是不是可控？</li><li>优缺点是什么？</li></ul></li><li><p>验证</p><p>过一个小型的快速原型项目，用候选的技术方案快速做一个原型出来，做的过程中才能知道，你选择的技术选型是不是真的能满足技术选型的目标。</p></li><li><p>决策</p><p>在调研和验证完成后，就可以召集所有利益相关人一起，就选择的方案有一个调研结果评审的会议，让大家提出自己的意见，做出最终的决策。</p></li></ol><h2 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h2><h3 id="如何提高开发效率"><a href="#如何提高开发效率" class="headerlink" title="如何提高开发效率"></a>如何提高开发效率</h3><ul><li><p>积极主动，行动起来改变自己</p><ul><li><p>想想再回应</p><p>每个人对于外界的刺激都会做出反应，本能的或者习惯性的，就像我前面举的例子，遇到事情会本能的觉得都是外部原因。如果一直这样，那就会进入恶性循环，变得更加消极麻木。但如果在回应之前，给自己一点时间想想，站在积极的方面理性思考一下，就可以去控制你的本能反应。</p></li><li><p>减少关注圈，扩大影响圈</p><p><strong>不要总盯着自己无法改变的部分，你需要要多花时间精力在影响圈上。接受不能改变的，改变能改变的，尽量扩大可改变项的范围。</strong></p></li></ul></li><li><p>以终为始，想清楚再开工</p><p><strong>目标、原则和计划。</strong></p><ul><li><p>经常停下来想想目标</p></li><li><p>制定原则</p><p>可以给自己定一些原则，比如：“先运行再优化 (Make it Work Make It Right Make It Fast)”，“不复制粘贴代码 (Don’t repeat yourself)”，“每个 Pull Request 要尽可能小”</p></li><li><p>公开自己的计划</p></li></ul></li><li><p>要事第一，把时间用在刀刃上</p><ul><li><strong>重要紧急的事情马上处理</strong>：生产环境出故障了，测试环境部署失败了</li><li><strong>重要不紧急的要事，要花最多的时间在上面</strong>：对代码重构、写自动化测试代码、确认清楚需求文档</li><li><strong>紧急不重要的事凑一起集中做</strong>：微信的消息通知，无关紧要的会议，请教一个不算很急的技术问题</li><li><strong>不重要不紧急的事情能不做就不做</strong></li></ul></li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a><strong>持续交付</strong></h2><h3 id="集成、部署和交付的发展史"><a href="#集成、部署和交付的发展史" class="headerlink" title="集成、部署和交付的发展史"></a>集成、部署和交付的发展史</h3><ul><li><p><strong>集成的发展</strong></p><p>在多人软件项目开发的时候，每个人都会负责一部分功能模块的开发，集成指的就是每个人把自己开发的分支代码，合并到主干上，以便测试打包。</p><ul><li><p><strong>集成的原始阶段</strong></p><p>早在瀑布开发的年代，在开发阶段，一般是不集成的。大家各自开发，等到开发阶段差不多快结束了，再一起提交代码到源代码管理工具，让代码集成在一起，再编译、部署发布到测试环境。由于长时间都是在各自的开发环境运行，每次集成都是很痛苦的过程，会遇到各种问题，比如说编译无法通过、hard code 了开发环境地址、类库版本不一致、API 格式不一致等，通常要持续几天甚至几周才能逐步有一个相对稳定的版本。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9ba564d561097d452d8ea46b6e4c5ec6.png"></p></li><li><p><strong>持续集成</strong></p><p>持续集成的做法，就是每次有代码合并入主干之前，都进行集成，持续的集成。<strong>代码集成到主干之前，必须通过自动化测试，只要有一个测试用例失败，就不能集成。</strong></p><p>优点：</p><ul><li>配合自动化测试，这样可以保证主干的代码是稳定的；</li><li>频繁集成可以让开发人员总能从主干及时获得最新的代码，不至于像类库、API 不一致等问题到最后测试的阶段才暴露出来。</li></ul></li></ul></li><li><p><strong>部署和交付的发展</strong></p><p>部署指的是将代码发布到各种环境，比如部署测试环境以供测试。</p><p>交付则指的是软件产品在测试验收通过后，具备发布到生产环境交付给客户使用的条件。</p><ul><li><p><strong>部署和交付的原始阶段</strong></p><p>早些年，部署是一件很麻烦的事情。需要手动获取最新源代码、编译、再需要针对环境修改很多配置。</p><p>随着分工的进一步细化，逐步发展成有专门的运维岗位，由运维人员负责部署。而开发人员上线前要写专门的部署文档和检查表，运维人员按照部署文档和检查表一步步部署生产环境。</p></li><li><p><strong>从手动部署到脚本自动化部署</strong></p><p>早期的自动化部署解决方案是每日构建（Daily Build），简单来说，就是大家在每天晚上下班后，每日构建程序自动从源代码管理器下载最新代码，编译、部署程序到测试环境。这样第二天测试人员就可以拿到最新的程序，对前一天修复的 Bug 进行测试。</p></li><li><p><strong>从脚本部署到持续交付</strong></p><p>持续交付，就是在持续集成的基础上，再进一步，在功能合并到主干后，不仅会进行自动化测试，还会打包，并部署到测试环境中。</p><p>持续交付本质上也是把部署和交付这件让人痛苦的事情，更加频繁地去做，从而让部署和发布变得不但不痛苦，反而越来越简单。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/a2e354c88a3bf0df871174980ef3a900.png"></p></li><li><p><strong>从持续交付到持续部署</strong></p><p>持续交付，对于生产环境的部署，依然需要有手动确认的环节。而持续部署，和持续交付唯一的不同，就是手动确认的环节都没有了，每次代码从分支合并到主干，在自动化测试通过后，会<strong>直接自动部署生产环境，不需要人工确认</strong>。</p></li></ul></li></ul><h3 id="持续交付的优势"><a href="#持续交付的优势" class="headerlink" title="持续交付的优势"></a>持续交付的优势</h3><ul><li><strong>尽快暴露问题</strong>：自动化测试，可以保证很多问题在合并到分支之前就能被发现；每次合并后就部署到测试环境，也能让测试人员尽早介入，及时发现问题。</li><li><strong>极大提升效率</strong>：持续交付让开发过程中从代码合并，一直到最终部署，都实现了自动化，能极大程度上提高效率。</li><li><strong>提升质量</strong>：每次合并之前都需要通过自动化测试，因此错误会少很多。</li><li><strong>降低项目成本</strong>：在最初搭建持续交付环境的时候，是要投入一定成本的，但是从长远看，开发效率提升了，代码质量提高了，反而是对降低项目的整体成本有帮助的。</li></ul><h3 id="如何搭建持续交付环境"><a href="#如何搭建持续交付环境" class="headerlink" title="如何搭建持续交付环境"></a>如何搭建持续交付环境</h3><ol><li><p><strong>准备工作</strong></p><ul><li>持续集成相对要求简单：<ul><li>需要有<strong>源代码管理工具</strong>，比如说 git、svn，因为持续集成工具需要从统一的源代码仓库获取代码；</li><li>需要写<strong>自动化测试代码</strong>，因为持续集成有一个很重要的条件，就是自动测试必须通过。</li></ul></li><li>持续交付相对比持续集成要求更高：<ul><li>对代码构建的过程可以<strong>反复进行</strong>，并且每次构建的结果是一致的、稳定的；</li><li>所有<strong>环境的配置都存在于源代码管理工具</strong>中，不仅仅是代码；</li><li>需要<strong>自动创建针对于不同环境</strong>的发布包；</li><li>所有环境的部署发布步骤都必须是<strong>自动化</strong>的。</li></ul></li></ul></li><li><p><strong>选择合适的持续集成工具</strong></p><p>主要的持续集成工具：</p><ul><li><p>Jenkins</p><p>Jenkins应该是目前最好的开源持续集成工具，可以自己搭建，插件非常丰富，可以满足绝大部分项目的需要。相对使用难度要高一些，需要花一点时间学习。</p></li><li><p>Go CD</p><p>Go CD是 ThoughtWorks 公司出品的持续集成工具，可以免费使用。</p></li><li><p>Travis CI</p><p>Travis CI是一个老牌的托管的商业 CI 系统，和 Github 集成的非常好，尤其是开源项目，可以免费使用。</p></li><li><p>GitLab CI</p><p>GitLab CI是 Gitlab 推出的持续集成工具，可以自己搭建也可以使用它的在线托管，价钱便宜。</p></li><li><p>Azure Pipelines</p><p>Azure Pipelines是微软的持续集成平台，可以自己搭建也可以使用它的在线托管，和微软的开发语言和服务集成很好。</p></li></ul></li><li><p><strong>根据选择的工具实施</strong></p></li></ol><h2 id="软件工程师的核心竞争力"><a href="#软件工程师的核心竞争力" class="headerlink" title="软件工程师的核心竞争力"></a><strong>软件工程师的核心竞争力</strong></h2><h3 id="如何提升学习能力"><a href="#如何提升学习能力" class="headerlink" title="如何提升学习能力"></a>如何提升学习能力</h3><ol><li><p><strong>首先需要在一个技术领域深耕</strong></p><p><strong>只有一个领域的知识你真正吃透，才能有效地共享到其他领域，构成一个知识领域的森林。</strong>要在某一个领域的技术达到一定深度，通常需要三年以上的时间。当熬过这个阶段，在一个技术领域取得了一定成就，不仅会收获知识树，还能收获技术上的自信，有信心在其他技术领域也同样取得成就。</p></li><li><p><strong>然后往相近的领域逐步横向拓展</strong></p><p>当在一个技术领域达到一定深度后，可以开始横向扩展。最好是往相近的领域扩展，因为这样之前的知识有很多是可以共享的，容易快速取得成绩。</p></li></ol><h3 id="如何提高解决问题的能力"><a href="#如何提高解决问题的能力" class="headerlink" title="如何提高解决问题的能力"></a>如何提高解决问题的能力</h3><ol><li><p>明确问题</p><p>透过现象看本质，去明确问题背后是不是还有其他问题。不能光看到功能需求，还需要看到安全上的需求；网络异常的问题，不能光想着应用程序错误，还要看看网络是不是有问题。</p></li><li><p>拆分和定位问题</p><p>一个复杂的问题，只有经过拆分，才好找到本质的问题。</p></li><li><p>提出解决方案并总结</p><p>总结要做的就是两点：</p><ul><li>下次有这种问题怎么解决，是不是可以做的更好？</li><li>这种问题是不是可以预防？如果可以，应该怎么做？</li></ul></li></ol><h3 id="如何提升影响力"><a href="#如何提升影响力" class="headerlink" title="如何提升影响力"></a>如何提升影响力</h3><ul><li><p><strong>在某个领域做出了足够牛的成绩</strong></p></li><li><p><strong>做事情超出预期</strong></p></li><li><p><strong>帮助其他人就是在帮助自己</strong></p></li><li><p><strong>分享就是学习和打造影响力</strong></p></li></ul><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a><strong>自动化测试</strong></h2><h3 id="自动化测试的重要性"><a href="#自动化测试的重要性" class="headerlink" title="自动化测试的重要性"></a>自动化测试的重要性</h3><p><strong>人工测试：</strong></p><p>根据需求写成测试用例，设计好输入值和期望的输出，然后按照测试用例一个个操作，输入一些内容，做一些操作，观察是不是和期望的结果一致，一致就通过，不一致就不通过。</p><p><strong>自动化测试：</strong></p><p>就是把这些操作，用程序脚本来完成的，本质上还是要输入和操作，要检查输出是不是和期望值一致。自动化测试有一个人工测试没有的优势，那就是<strong>可以直接绕过界面，对程序内部的类、函数进行直接测试。</strong></p><h3 id="自动化测试的类型"><a href="#自动化测试的类型" class="headerlink" title="自动化测试的类型"></a>自动化测试的类型</h3><p><strong>单元测试、集成测试、UI 测试、端到端测试、契约测试、组件测试。</strong></p><p>Google 将自动化测试分成了三大类：小型测试、中型测试和大型测试。</p><p>假设有一个网站，是基于三层架构（如下图所示），业务逻辑层的类叫 UserService 类，数据访问层的类叫 UserDA，以用户注册的功能来说明几种测试的区别 。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9b9fbf93cf03fa33b381ee144a26a92b.png"></p><ul><li><p><strong>小型测试</strong></p><p>小型测试是为了<strong>验证一个代码单元的功能</strong>，例如针对一个函数或者一个类的测试。<strong>单元测试</strong>就是一个典型的小型测试。</p><p>小型测试的运行，<strong>不需要依赖外部</strong>。如果有外部服务（比如文件操作、网络服务、数据库等），必须<strong>使用一个模拟的外部服务</strong>。比如上面例子中我们就使用了 FakeUserDA 这个模拟的数据库访问类，实际上它不会访问真实的数据库。这样可以保证小型测试在很短时间内就可以完成。</p></li><li><p><strong>中型测试</strong></p><p>中型测试是<strong>验证两个或多个模块应用之间的交互</strong>，通常也叫<strong>集成测试</strong>。</p><p>对于中型测试，<strong>可以使用外部服务</strong>（比如文件操作、网络服务、数据库等），可以模拟也可以使用真实的服务。如果说要对用户注册的功能写集成测试，那么就会同时测试业务逻辑层的 UserService 类和数据访问层的 UserDA 类。</p></li><li><p><strong>大型测试</strong></p><p>大型测试会<strong>验证系统的一个或者所有子系统</strong>，从前端一直到后端数据存储。大型测试也叫<strong>系统测试</strong>或者<strong>端对端测试</strong>。</p><p>对于大型测试，通常会<strong>直接使用外部服务</strong>（比如文件操作、网络服务、数据库等），而不会去模拟。比如上面这个例子，就是直接访问测试环境的地址，通过测试库提供的 API 操作浏览器界面，输入测试的用户名密码，点击注册按钮，最后检查输出的结果是不是符合预期。</p></li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/a72fcd3b3f358e4512fa5694ad526dbd.png" alt="Google测试类型划分"></p><ul><li>小型测试：没有外部服务的依赖，都是要模拟的；</li><li>中型测试：所有的测试几乎都不需要依赖其他服务器的资源，如果有涉及其他机器的服务，则本地模拟，这样本机就可以完成测试；</li><li>大型测试：几乎不模拟，直接访问相关的外部服务。</li></ul><p><strong>越是小型测试，执行速度越快，越是大型测试，执行速度越慢。</strong></p><h3 id="怎么写好自动化测试代码"><a href="#怎么写好自动化测试代码" class="headerlink" title="怎么写好自动化测试代码"></a>怎么写好自动化测试代码</h3><p><strong>四步：准备、执行、断言和清理。</strong></p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/02aa850792c8fbb3c6bc626b9c944161.png" alt="小型测试-测试用户注册功能"></p><ol><li>准备：创建实例，创建模拟对象</li><li>执行：执行要测试的方法，传入要测试的参数</li><li>断言：检查结果对不对，如果不对测试会失败</li><li>清理：对数据进行清理，不影响下一次测试</li></ol><p><strong>完整的自动化测试用例需要包含：</strong></p><ul><li><strong>验证功能是不是正确</strong>：例如说输入正确的用户名和密码，要能正常注册账号；</li><li><strong>覆盖边界条件</strong>： 比如说如果用户名或密码为空，应该不允许注册成功；</li><li><strong>异常和错误处理</strong>：比如说使用一个已经用过的用户名，应该提示用户名被使用。</li></ul><h3 id="如何为项目做好自动化测试"><a href="#如何为项目做好自动化测试" class="headerlink" title="如何为项目做好自动化测试"></a>如何为项目做好自动化测试</h3><ol><li><p>选择好自动化测试框架</p><p>例如 Web 前端</p><ul><li>Jest： Facebook 的前端测试框架；</li><li>Mocha：历史悠久的一个 JS 测试框架；</li><li>Nighwatch: 一个 API 很简单，但是功能很强大，可以直接操作浏览器的自动测试框架。</li></ul></li><li><p>在持续集成环境上跑自动化测试</p><p>自动测试配合持续集成的一个标准流程：</p><ul><li>在提交代码前，先<strong>本地跑一遍单元测试</strong>，这个过程很快，失败了需要继续修改；</li><li>单元测试成功后就可以<strong>提交到源代码管理中心</strong>，提交后<strong>持续集成服务会自动运行完整的自动化测试</strong>，不仅包括小型测试，还有中型测试；</li><li>通过所有的测试后，就可以<strong>合并到主分支</strong>，如果失败，需要本地修改后再次提交，直到通过所有的测试为止。</li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/7bbc58d82864974ff2f9ec31347fa538.png"></p></li><li><p>新项目和老项目采用不同策略</p><p>新项目，可以在一开始就保持一定的自动化测试代码的覆盖率，甚可以采用测试驱动（TDD）的开发模式，也就是<strong>先写测试代码，再写实现代码，保证测试通过，最后对代码进行重构。</strong></p><p>老项目，短期内要让自动化测试代码有覆盖是有难度的，可以<strong>先把主要的功能场景的中型测试写起来</strong>，这样可以保证这些主要功能不会轻易出问题。</p><p>在维护的过程中：</p><ul><li>增加新功能的时候，同步对新功能增加自动化测试代码；</li><li>修复 Bug 的时候，针对 Bug 补写自动化测试代码。</li></ul></li></ol><h2 id="源代码管理工具"><a href="#源代码管理工具" class="headerlink" title="源代码管理工具"></a><strong>源代码管理工具</strong></h2><h3 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h3><p>源代码管理工具也叫版本控制系统，是<strong>保存文件多个版本</strong>的一种机制。每一次有人提交了修改，这个修改历史都会被版本控制系统记录下来。每一次对内容的修改，都会形成一个当前项目完整内容的快照。</p><ul><li><p>没有源代码管理工具的时代</p><p>问题：</p><ul><li>很难知道做了哪些修改，可能需要挨个目录去查看文件修改时间；</li><li>对版本命名是一个很麻烦的事情，每次备份都得有一个名字；</li><li>很难知道两次备份之间，做了哪些修改。</li></ul></li><li><p>本地版本管理</p><p>最早的版本控制系统是 <strong>SCCS（Source Code Control System）</strong>，诞生于 1972 年，它实现了<strong>对单个文件保留多个版本</strong>，这就意味着你可以看到每一个文件的修改历史了。</p><p>后来又有了 <strong>RCS （Revision Control System）</strong>，它具有更好的文件比较算法，通过<strong>登录同一台中央大型机，可以实现每个人签出自己的拷贝</strong>。</p><p>但这个阶段<strong>只能本机使用</strong>，而且<strong>一次只能修改一个文件</strong>，无法满足好多人协作的问题。</p></li><li><p>集中式版本管理</p><p><strong>CVS（Concurrent Versions System）</strong>是第一个采用集中式的服务器来进行版本库的管理工作，所有文件和版本历史都放在服务端，每个用户通过客户端获取最新的代码，可以多个人编辑一个文件，并且能提交到服务器合并在一起。</p><p><strong>SVN（Subversion）</strong>则对 CVS 进行了很多优化，比如支持文件改名、移动、全局版本号等，这些优化很大部分程度上解决了 CVS 存在的一些缺陷，所以在 2000 年后逐步取代了 CVS 成为主流的源代码管理工具。</p><p>这类集中式源代码管理工具，<strong>过于依赖服务器</strong>，如果服务器出问题或者连不上，就没法用了，如果服务器损坏，所有的版本<strong>历史也会丢失</strong>。</p></li><li><p>分布式版本管理</p><p>分布式版本控制系统的<strong>整个代码库的副本都可以存储在用户的本地系统上</strong>，这样文件和版本控制操作变得非常容易，离线也可以操作，如果主存储库关闭或者删除，可以很容易从本地存储库恢复。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/603379637ba76d67ddcc21f1d515b202.png"></p></li></ul><h3 id="如何选择合适的源代码管理系统"><a href="#如何选择合适的源代码管理系统" class="headerlink" title="如何选择合适的源代码管理系统"></a>如何选择合适的源代码管理系统</h3><ul><li><p>自己搭建源代码管理系统</p><ul><li>Git</li></ul><p>Git 本身是开源免费的，所以每个人都可以搭建自己的 Git Server。《 服务器上的 Git - 在服务器上搭建 Git 》《搭建自己的 Git 服务器》</p><ul><li>GitLab</li></ul><p>Git 自带的 Server 默认是没有 Web 界面进行管理的，只能用命令行操作交互，这在操作上有很多不便利性，尤其是不方便做代码审查，所以可以安装GitLab 的社区版本，开源免费的，有 Web 操作界面，可以像 GitHub 一样提交 Pull Request，并且和 CI （持续集成）系统例如 GitLab CI、Jenkins 都有很好的集成。《在自己的服务器上部署 GitLab 社区版》《GitLab 的安装及使用教程》。</p><ul><li>Gerrit</li></ul><p>Gerrit是由 Google 开发的，用于管理 Google Android 项目源代码的一个系统。它支持 Git 和代码评审。《Gerrit 代码审核服务器搭建全过程》</p></li><li><p><strong>网上的代码托管平台</strong></p><ul><li>GitHub</li></ul><p>GitHub的 Web UI 非常强，尤其是代码浏览和审查，在网站上就可以提交 Pull Request 和进行代码审查。不过 <strong>GitHub 不提供 CI 服务</strong>，需要和第三方 CI 服务集成。</p><ul><li>GitLab</li></ul><p>GitLab的网上托管服务很多地方和 GitHub 都很类似，但是价格更便宜。例如免费用户可以支持无限的私有项目，也<strong>内置了 CI 的支持</strong>。</p><ul><li>Coding</li></ul><p>Coding是国内一个不错的代码托管平台，5 人以下的私有库免费，内置了 CI 支持，同时还有项目管理工具支持。</p><p>其他的服务还有像：码云、阿里云 Code、百度效率云、腾讯 Git 代码托管、华为云 CodeHub。</p></li></ul><h3 id="如何用好源代码管理工具"><a href="#如何用好源代码管理工具" class="headerlink" title="如何用好源代码管理工具"></a>如何用好源代码管理工具</h3><ul><li><p>要频繁的提交</p><p>频繁提交，意味着每次提交的代码变更是比较少的，便于 Code Review，同时如果出现问题，也可以迅速定位或者直接回滚。也让团队成员可以及时同步最新代码，不至于在最后合并时，产生有大量的合并冲突。</p></li><li><p>每次提交后要跑自动化测试</p><p>每次提交，必须要运行自动化测试代码，如果测试不通过就不能合并，要对问题进行甄别和修复，确保提交的代码质量是没问题的。</p></li><li><p>提交的代码要有人审查</p><p>通过代码审查，可以发现代码中潜在的问题。通过代码审查，也可以加强团队的技术交流，让水平高的开发人员 Review，可以帮助提升整体代码水平；Review 高水平的代码也是一种非常有效的学习方法。</p></li></ul><h3 id="该选择什么样的开发流程"><a href="#该选择什么样的开发流程" class="headerlink" title="该选择什么样的开发流程"></a>该选择什么样的开发流程</h3><p>现在基于源代码管理有三种主要的开发流程：</p><ul><li><a href="http://nvie.com/posts/a-successful-git-branching-model/">Git flow</a></li><li><a href="https://guides.github.com/introduction/flow/">GitHub flow</a></li><li><a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html#introduction-to-gitlab-flow">GitLab flow</a></li></ul><p><strong>GitHub 开发流程</strong></p><ul><li><p>GitHub 开发流程的关键在于两点：</p><ul><li>有一个稳定的分支，例如 master；</li><li>每次创建新功能或者修复 Bug，必须创建一个分支。最后通过代码审查和自动化测试后，才能合并回稳定分支。</li></ul></li><li><p>具体流程：</p></li></ul><ol><li><p><strong>创建一个分支</strong></p><p>master 分支是要一直保持稳定的，不能直接在 master 上开发。无论是要开发一个新功能还是修复一个 Bug，第一件事永远是从 master 创建一个分支出来。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/ce1be843617e669e47f5bd6f2c2b801a.png"></p></li><li><p><strong>提交更新</strong></p><p>基于分支开始工作，可以按照前面建议的原则，频繁的提交更新。每次提交的时候，要加上说明性的信息，如果开发过程中发现错误，还可以随时回滚之前的更改。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/6f54abdcfa102a13eda2bd5329e08707.png"></p></li><li><p><strong>创建一个 Pull Request</strong></p><p>创建 PR 时，通常要附上描述性的信息，关联上相应的 Ticket 连接，让其他人知道这个 PR 要完成什么任务。创建好 PR 后，其他人就可以直观的看到你所有的修改。PR 的主要目的就是为了方便大家做代码审查。当你的 PR 提交后，团队的其他人就可以对 PR 中的代码修改进行评论。比如说代码风格不符合规范、缺少单元测试、或者很好没有问题。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/1a665275ab20b3fd3a7711db357271d6.png"></p></li><li><p><strong>讨论和代码审查</strong></p><p>根据代码审查的结果，你可能要做一些修改，那么只要继续提交更新到这个分支就可以了，提交更新后，<strong>PR 就会自动更新</strong>，其他人可以基于你的更新进一步的讨论和审查，直到通过代码审查。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/9c324020e64e963c5d47b4b51ea1fb97.png"></p></li><li><p><strong>部署测试</strong></p><p>在合并前，还需要把分支的修改进行测试。理论上来说，需要将修改的内容部署到测试环境测试，但这样效率太低了，所以通常的做法是借<strong>助持续集成工具，在每次提交代码后，就运行自动化测试代码</strong>，自动化测试代码全部通过后，就可以认为质量是可靠的。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/13236779ae4780cf55ccb3d3cda5065f.png"></p></li><li><p><strong>合并</strong></p><p>当你的代码通过了代码审查和自动化测试，就可以将代码合并到 master 分支了。合并后，之前的分支就可以删除，但之前所有的提交记录在 master 都可以看到，所以完全不用担心丢失历史版本记录。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/0da9251ea9b5a791a8b4ff536fee3035.png"></p></li></ol><ul><li><p>常见问题：</p><ul><li><p><strong>怎么发布版本？</strong></p><p>要发布版本的话，从 master 上创建一个 Tag，例如 v1.0，然后将 Tag v1.0 上的内容部署到生产环境。</p></li><li><p><strong>怎么给线上版本打补丁？</strong></p><p>如果线上发布的版本（例如 v1.0）发现 Bug，需要修复，那么基于之前的 Tag 创建一个分支（例如 hotfix-v1.0-xxx）出去，在分支上修复，然后提交 PR，代码审查和自动化测试通过后，从分支上创建一个新的 Tag （例如 v1.0.1），将新的 Tag 发布部署到生产环境，最后再把修改合并回 master。</p></li><li><p><strong>如果经常需要打补丁，有没有比 Tag 更好的办法？</strong></p><p>每次发布后，可以创建一个发布版本的分支，例如 release-v1.0，每次打补丁，都直接从发布分支 release-v1.0 而不是 master 创建新的分支（例如 hotfix-release-v1.0-xxx），修复后提交 PR，代码审查和自动化测试通过后，合并回分支 release-v1.0，然后基于 release-v1.0 分支发布补丁。最后将合并的 PR，借助 git 的 cherry-pick 命令再同步合并回 master。</p></li></ul></li></ul><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a><strong>测试工具</strong></h2><h3 id="Bug-跟踪工具"><a href="#Bug-跟踪工具" class="headerlink" title="Bug 跟踪工具"></a>Bug 跟踪工具</h3><p>通过 QQ 等方式报告的 Bug，都是文字配合图片等信息，很难检索和分类，<strong>而 Bug 跟踪工具，采用结构化的数据来定义 Bug，每一个 Bug 都有一些关键的信息可以对 Bug 进行分类和检索。</strong></p><p>在 Bug 跟踪工具使用中，一个基本的 Bug 信息包括：</p><ul><li>标题；</li><li>描述（包括期望结果、实际结果和重现步骤等关键信息）；</li><li>优先级；</li><li>指派人；</li><li>状态（New、Open、 Rejected、Fixed 等）；</li></ul><p>对于开发人员来说，可以直观的看到自己有哪些 Bug 需要处理，Bug 的描述信息也可以帮助重现 Bug、快速定位到 Bug 的原因；</p><p>对于项目经理或者测试人员来说，可以直观的看到哪些 Bug 还没解决，及时了解项目进展。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/4f56bf4d43b652ab2b92318775a850dd.png" alt="Bug的状态流转"></p><p><strong>注意事项：</strong></p><ul><li>所有的 Bug 都应该通过 Bug 跟踪系统管理和跟踪，不应该再通过 QQ/ 微信 / 邮件的方式跟踪 Bug；</li><li>不能把多条 Bug 合并成一条，一个 Bug 创建一个独立的 Ticket；</li><li>描述清楚如何重现 Bug 非常重要；</li><li>不要把 Bug 跟踪系统当成讨论板用。</li></ul><p><strong>常用工具：</strong></p><ul><li><p><strong>Bugzilla</strong></p><p>Bugzilla 是由 Mazilla 公司提供的一款开源免费的 bug 跟踪系统。这是一款历史很悠久的产品。</p></li><li><p><strong>MantisBT</strong></p><p>MantisBT 是一个简单但功能强大的开源 bug 跟踪系统，可以通过各种插件来扩展其功能。</p></li><li><p><strong>Redmine</strong></p><p>Redmine 是一款开源的综合性的项目管理工具，不仅可以用于 Bug 跟踪，还可以用来跟踪项目进度。</p></li></ul><h3 id="自动化测试工具"><a href="#自动化测试工具" class="headerlink" title="自动化测试工具"></a>自动化测试工具</h3><ul><li><p><strong>Selenium</strong></p><p>Selenium 是一个 Web 端的自动化测试工具，直接运行在浏览器中，用来模拟用户操作。类似的还有WebDriverIO 和 Nightwatch.js ，支持 Javascript，API 更简单更方便。</p></li><li><p><strong>Appium</strong></p><p>Appium 是一个开源、跨平台的自动化测试工具，用于测试移动原生应用，支持 iOS, Android 系统。</p></li><li><p><strong>Macaca</strong></p><p>Macaca 是阿里巴巴开源的一款面向多端的自动化测试工具，支持桌面端、Web、移动端、真实设备和模拟器。</p></li></ul><h3 id="压力测试工具"><a href="#压力测试工具" class="headerlink" title="压力测试工具"></a>压力测试工具</h3><ul><li><p><strong>Apache JMeter</strong></p><p>JMeter 是一款开源的压力测试工具，纯 Java 应用程序。</p></li><li><p><strong>LoadRunner</strong></p><p>LoadRunner 是惠普旗下的一款商业自动负载测试工具，可以通过录制的方式制作测试脚本，上手容易功能强大，可以方便的监控和分析性能测试结果。</p></li><li><p><strong>阿里云性能测试 PTS</strong></p><p>阿里云性能测试 PTS 是基于云端的压力测试服务，可以模拟从全国各地域运营商网络发起的流量，真实地反映使用情况，生成有价值的性能测试报告。</p></li><li><p><strong>WebPageTest</strong></p><p>WebPageTest 是一个可以用来测试和分析网页性能的在线工具，支持不同浏览器，支持 API。可参考《WebPagetest H5 性能测试工具入门详解》。</p></li></ul><h3 id="安全测试工具"><a href="#安全测试工具" class="headerlink" title="安全测试工具"></a>安全测试工具</h3><ul><li><p><strong>HP Fortify On Demand</strong></p><p>Fortify On Demand 是惠普旗下的一款安全检测工具，可以通过分析源代码、二进制程序或者应用程序 URL 检测程序安全漏洞。</p></li><li><p><strong>Sqlmap</strong></p><p>Sqlmap是一款开源免费的检测 SQL 注入的工具。</p></li><li><p><strong>IBM Application Security APPScan</strong></p><p>APPScan 是 IBM 旗下的一款漏洞扫描工具，支持网站和移动 App。</p></li></ul><h3 id="浏览器兼容性测试工具"><a href="#浏览器兼容性测试工具" class="headerlink" title="浏览器兼容性测试工具"></a>浏览器兼容性测试工具</h3><ul><li><p><strong>Browsera</strong></p><p>Browsera 可以对不同浏览器下的布局提供报告，包括截图和 Javascript 错误。</p></li><li><p><strong>Browslering</strong></p><p>Browslering 可以针对不同浏览器进行测试，它在虚拟机中运行真实桌面浏览器，还可以人工进行交互。</p></li></ul><h3 id="测试用例管理工具"><a href="#测试用例管理工具" class="headerlink" title="测试用例管理工具"></a><strong>测试用例管理工具</strong></h3><ul><li><p><strong>TestRail</strong></p><p>TestRail 是 TestRail 是一个专注于管理测试用例的工具，可以用它来创建测试用例和用例集，跟踪测试用例的执行和生成报告。</p></li><li><p><strong>飞蛾</strong></p><p>飞蛾 是 Coding 旗下的测试管理工具，对中文支持好，界面美观。</p></li></ul><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="安全问题本质是技术风险"><a href="#安全问题本质是技术风险" class="headerlink" title="安全问题本质是技术风险"></a>安全问题本质是技术风险</h3><p>软件中的安全问题来源主要可以分为以下三大类：</p><ul><li><p><strong>恶意输入</strong></p><p>黑客通过恶意输入，然后绕过软件限制对系统进行攻击和破坏。</p><p>SQL 注入：黑客把 SQL 命令输入到软件的输入框或网页的 URL 查询参数，欺骗服务器，执行恶意的 SQL 命令。这样可以绕过密码验证，登录管理员账号，或者删除数据库数据，甚至控制服务器。</p><p>XSS 攻击：将恶意代码通过外部参数或者用户输入的方式植入网页中，获取用户的 Cookie 等敏感信息、盗用管理员权限，甚至非法转账。</p></li><li><p><strong>假冒身份</strong></p><p>如果对用户的身份不做严格的验证，很可能就会导致假冒身份的安全问题。应对策略就是要对用户的身份做验证，尤其是涉及敏感权限的操作，甚至要做两重验证。</p></li><li><p><strong>数据泄露</strong></p><p>一些软件会把服务器上的敏感信息打包在程序中，而程序可能会被反编译导致敏感数据泄露。<strong>我们不能假设数据存储是安全的，而是要考虑到数据是有泄露的可能，提前做好预防措施，对敏感数据进行加密。</strong></p></li></ul><h3 id="如何预防软件中的安全问题"><a href="#如何预防软件中的安全问题" class="headerlink" title="如何预防软件中的安全问题"></a>如何预防软件中的安全问题</h3><ol><li><p><strong>需求阶段</strong></p><p><strong>在确定需求，做产品设计的时候，不仅要考虑到功能上的需求，还要同时考虑到安全方面的要求。</strong></p><p>涉及用户输入的内容，需要考虑到可能的恶意输入，做出针对性预防措施；</p><p>涉及用户权限的，要求有身份的验证，一些对安全要求极高的，可以在需求上就要求做双重验证；</p><p>涉及敏感数据的，可以在需求上就要求对数据进行加密。</p><p><strong>比如说用户登录功能，需要考虑到哪些安全问题？</strong></p><ul><li>登录网页使用 <strong>Https</strong> 或者在<strong>传输密码时加密</strong>；</li><li><strong>增加图形校验码</strong>，避免恶意攻击；</li><li>密码失败次数过多，应该<strong>锁定</strong>用户一段时间；</li><li>记录用户登录 <strong>IP</strong>。</li></ul></li><li><p><strong>设计阶段</strong></p><ul><li><p><strong>攻击面最小化</strong></p><p>攻击面就是指程序被用户直接访问到的部分，比如 <strong>API、网站</strong>等，这些暴露给用户的地方也是最可能被黑客攻击的地方。</p><p>数据库应该关闭外网访问，避免黑客直接攻击数据库导致数据泄露；</p><p>复杂的多网站业务系统，实行单点认证，就可以让所有业务都在一个地方登录，可以在这一个地方做到足够安全，这样所有网站的登录都是相对安全的。</p></li><li><p><strong>权限最小化</strong></p><p>权限最小化的设计原则就是对于<strong>系统的用户、文件访问、进程运行</strong>等，都<strong>只给予其能拥有的最小权限</strong>，这样可以保证一个应用程序或者网站被攻击、破解，能将损害降到最低。</p></li><li><p><strong>纵深防御</strong></p><p>纵深防御的设计原则，指的是<strong>从不同的维度去实施安全保护措施</strong>，从而缓解被攻击的风险。</p></li></ul></li><li><p><strong>开发阶段</strong></p><ul><li>编码规范中加入安全相关内容</li><li>要有代码审查</li><li>增加安全相关的自动化测试</li></ul></li><li><p><strong>测试阶段</strong></p><p>借助一些安全测试工具来进行测试。</p></li></ol><h3 id="上线维护"><a href="#上线维护" class="headerlink" title="上线维护"></a><strong>上线维护</strong></h3><ul><li>上线部署时，<strong>不部署源代码，只对编译后程序部署</strong>；<strong>删除 Debug 文件</strong>。</li><li>对服务器进行安全设置，比如说<strong>严格限制端口，只保留必须的端口</strong>；</li><li>只对少数服务器开发外放服务；</li><li>开启操作日志；</li><li>对访问目录设置最小的权限。</li></ul><h3 id="安全问题发生后怎么善后"><a href="#安全问题发生后怎么善后" class="headerlink" title="安全问题发生后怎么善后"></a>安全问题发生后怎么善后</h3><ol><li><p>要<strong>设立应急的流程</strong>。当出现安全问题了，根据流程，知道该找谁，应该怎么去第一时间恢复生产，避免进一步损失。</p></li><li><p>要<strong>分析程序的漏洞在哪里</strong>。通过分析日志，找出漏洞在哪里，才能针对性去修补漏洞。</p></li><li><p>要<strong>总结原因</strong>。从错误中吸取教训，看问题是在哪个环节导致的，必要的话，就改进开发流程，避免类似的安全问题再次发生。</p></li></ol><h2 id="版本发布"><a href="#版本发布" class="headerlink" title="版本发布"></a><strong>版本发布</strong></h2><h3 id="软件版本标识"><a href="#软件版本标识" class="headerlink" title="软件版本标识"></a>软件版本标识</h3><p>目前业界在软件版本的命名上，通常会采用以下方式：</p><p><strong>主版本号 . 子版本号.[. 修正版本号.[构建版本号]]</strong></p><p>主版本号和子版本号用来标识功能变化，小的功能变化增加子版本号，大的功能变化增加主版本号。修正版本号则表示功能不变化的情况下修复 Bug，而构建版本号表示一次新的构建，这个通常由编译程序自动生成。</p><h3 id="版本发布前规划"><a href="#版本发布前规划" class="headerlink" title="版本发布前规划"></a>版本发布前规划</h3><p><strong>要在用户（或客户）的心理预期和你软件的实际情况之间，达到一种平衡，让软件的功能和质量，满足好用户的预期。</strong></p><ul><li><p><strong>规划好要发布的功能</strong></p><p>在发布前，搞清楚哪些是用户必须要有的功能，哪些是用户可以没有的功能。对于必须要有的功能，那么要保证软件中有这个功能才能发布，对于不是必需的功能，可以以后再逐步完善。</p></li><li><p><strong>设计好发布的策略</strong></p><p>让一部分用户使用 Beta 版也是一个好的发布策略，当用户知道你的软件还是 Beta 版的时候，要求会比较低一点，可以接受一些不那么严重的 Bug。 还有就是采用灰度测试的发布策略，让一小部分用户先用新功能，如果没发现什么问题，再继续扩大使用的用户规模，如果有问题，也只是影响少量用户。</p></li><li><p><strong>有一个综合性的版本发布计划</strong></p><p>这个发布计划，不只是项目内部成员，还需要和项目之外利益相关方，比如客户、市场运营人员，大家一起确定最终的发布计划。</p></li></ul><h3 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h3><ol><li><p><strong>在发布之前要做代码冻结</strong></p><p>在发布之前，对于要发布的版本，在源代码管理工具中，专门创建一个 release 分支，然后对于这个分支的代码，冻结功能的修改，不接受新功能的增加，甚至重要性不高的 Bug 都不修改，只修复重要的 Bug。</p></li><li><p><strong>对代码冻结后发现的 Bug 要分级</strong></p><p>原则就是尽可能减少代码的修改，避免引起不稳定。所以对于这些 Bug，要有一个简单的分级：是否在发布前修改，还是留在发布后再修改。</p></li><li><p><strong>每次修复 Bug 后，发布新的候选版本</strong></p><p>进入代码冻结后，开发人员还需要对一些 Bug 进行修复，每一次修复完 Bug 后，就要生成一个新的候选发布版本，比如说 1.1 RC1、1.1 RC2。</p></li><li><p><strong>每次部署新的候选发布版本后，要做回归测试</strong></p><p>在 Bug 修复完，对主要流程要重新测试一遍，同时还要对之前确认过的 Bug 再确认一遍，以确保 Bug 确实修复了，并且没有引入新的 Bug。</p></li><li><p><strong>申请上线发布</strong></p><p>在正式上线发布前，通常还需要有一个申请和审批的流程。审批的主要目的是要有人或者有部门统筹对所有的上线发布有一个全面的了解和控制，避免上线过于随意导致问题，避免和其他部门的上线冲突。</p></li><li><p><strong>部署发布</strong></p><p>如果还没有自动化部署发布，也需要事先将详细的操作步骤写下来，避免部署发布时发生纰漏，这样在实际部署发布时，按照事先写好的步骤操作就不容易出现错误。</p></li><li><p><strong>上线后的测试</strong></p><p>项目上线后，测试人员需要马上对已经上线的版本做一个主要功能的测试，以确保线上运行正常。如果做好了数据监控，还同时要对一些关键数据进行监控，例如服务器 CPU 利用率、内存占用率、服务出错率等数据。</p></li></ol><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><h3 id="传统的运维模式"><a href="#传统的运维模式" class="headerlink" title="传统的运维模式"></a>传统的运维模式</h3><p>在传统的瀑布模型开发中，当开发人员完成编码，测试人员测试验收通过后，到了要发布的时候，就会将程序交给运维人员部署发布到生产环境。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/2b3c01636b37728e5684d9bbc5e383e0.png" alt="传统运维模式"></p><p>传统运维工程师最重要的职责就是<strong>保障线上服务的稳定运行</strong>。对服务器 24 小时监控，有<strong>意外情况发生时需要及时处理和解决，日常的更新维护</strong>（比如说安装升级操作系统、安装更新应用软件，更新数据库、配置文件等）。</p><p><strong>存在的问题：</strong></p><ul><li>服务器规模快速增长和虚拟化技术的高速发展，以前的手动方式或者半自动的方式难以为继</li><li>高频的部署发布，意味着运维要有更高的自动化能力</li></ul><h3 id="什么是-DevOps"><a href="#什么是-DevOps" class="headerlink" title="什么是 DevOps"></a>什么是 DevOps</h3><p><strong>DevOps 可以理解为一种开发（Development）和运维（Operations）一起紧密协作的工作方式，从而可以更快更可靠的构建、测试和发布软件。</strong></p><p>对于运维来说，不再抵触开发的频繁更新部署，会帮助搭建自动化部署平台，提供自动化部署工具；</p><p>对于开发来说，不再认为运维的工作和开发没关系，开发人员会邀请运维人员参与架构设计，帮助运维实现自动化脚本开发。</p><p><strong>优势：</strong></p><ul><li><p><strong>整个软件的构建、测试和发布过程高度自动化</strong></p><p>应用自动化后，对于运维人员来说，自动化的交付流程，减少了繁重的手工操作，自动化测试可以有效对产品质量提供很好的保障。对于开发人员来说，可以方便高频率地进行部署。</p></li><li><p><strong>信息更加透明和易于测量</strong></p><p>当采用 DevOps 的工作方式，信息更加透明，通过日志和工具，数据也可以被更好测量。</p></li><li><p><strong>培养跨职能协作的文化</strong></p></li></ul><h3 id="DevOps具体工作"><a href="#DevOps具体工作" class="headerlink" title="DevOps具体工作"></a>DevOps具体工作</h3><ol><li><strong>DevOps 工程师要帮助团队建立基于持续集成和持续交付工作流程。</strong></li><li><strong>要构建基于云计算和虚拟化技术的基础设施。</strong></li><li><strong>形成 DevOps 的文化。</strong></li></ol><h2 id="线上故障"><a href="#线上故障" class="headerlink" title="线上故障"></a>线上故障</h2><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ul><li><p>第一步，评估影响范围；（定义问题）</p><p>先对故障进行评级，看对用户的影响范围，如果是核心业务，大面积影响用户，那么当务之急是恢复生产，然后再考虑如何去修复 Bug。</p></li><li><p>第二步，试图重现问题；（重现问题）</p><p>先重现 Bug或者分析错误日志，通过错误日志，可以马上定位到错误在哪里。像内存泄漏或者 CPU 高的问题，一般就可以通过分析内存 Dump 文件，分析当前是哪些线程占用资源多，线程运行的代码是什么；哪些变量占用资源多。从而可以缩小范围，快速发现问题在哪。</p></li><li><p>第三步，临时方案和终极方案；（解决问题）</p><p>仔细分析 Bug 产生的原因，从根本上解决，避免类似的故障再次发生。</p></li><li><p>第四步，风险评估及持续优化。（优化问题）</p><p>记录故障发生处理全过程，分析故障原因，提出后续改进方案。</p></li></ul><p><em>遇到线上故障，新手需要时刻牢记：恢复生产、降低损失是第一要务，修复 Bug 是其次的。</em></p><h3 id="大厂是怎么处理线上故障的"><a href="#大厂是怎么处理线上故障的" class="headerlink" title="大厂是怎么处理线上故障的"></a>大厂是怎么处理线上故障的</h3><ul><li>故障报警和轮值机制</li><li>实战演习</li><li>日志记录和分析工具</li></ul><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a><strong>日志管理</strong></h2><h3 id="如何快速发现和定位问题"><a href="#如何快速发现和定位问题" class="headerlink" title="如何快速发现和定位问题"></a>如何快速发现和定位问题</h3><ul><li><strong>日志集中式管理后，就可以方便地对所有日志进行统一的检索。</strong></li><li><strong>日志集中式管理后，可以通过图表直观的看到应用运行情况。</strong></li></ul><h3 id="大厂的日志管理系统的架构"><a href="#大厂的日志管理系统的架构" class="headerlink" title="大厂的日志管理系统的架构"></a>大厂的日志管理系统的架构</h3><p>很多大厂是基于 <strong>ELK</strong> 搭建自己的日志管理系统，而 ELK 的架构也是一套经典的日志管理的架构。</p><p><strong>ELK = Elasticsearch+Logstash+Kibana</strong></p><ul><li><strong>ElasticSearch</strong> 是一套搜索框架，提供了方便的接口，可以方便地做<strong>全文检索</strong>，可以用来对日志进行检索。</li><li><strong>Logstash</strong> 是一个数据收集工具，可以用来<strong>收集日志</strong>数据</li><li><strong>Kibana</strong> 是一套可以和 ElasticSearch 交互的界面，通过 Kibana 可以方便的检索 ElasticSearch 内的所有数据，还可以用<strong>图形化的方式展示数据结果</strong></li></ul><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/b9b53220894009769f5bcb031b7c0cf8.png" alt="基于 ELK 搭建的日志管理系统基本架构"></p><p>这套架构有几个重要的模块：<strong>日志采集和解析、存储和搜索、结果可视化、监控和报警。</strong></p><ul><li><p><strong>日志采集和解析</strong></p><p>如果日志文件只是一行行带时间戳的文本，那其实是无法有效检索的，必须将其解析成结构化的数据，才能方便地检索。一套系统可能由不同的应用类型组成，有的是 Java 写的，有的是 Go 写的，日志格式可能完全是不一样的，所以还有必要在对日志解析后，提取公共元素，比如时间、IP 地址、主机名、应用名称等。Logstash 不仅可以对日志数据进行收集，还能对日志数据进行过滤和解析，解析完成后再将解析好的数据发送给 ElasticSearch。</p></li><li><p><strong>存储和搜索</strong></p><p>ElasticSearch 就是一套专业的全文检索和数据存储系统，同时还有一套类似于 SQL 的查询语句，这样你就可以基于它，方便对收集好的日志数据进行检索了。</p></li><li><p><strong>结果可视化</strong></p><p>Kibana 就是一套专门针对 ElasticSearch 的图形化操作工具，可以方便对 ElasticSearch 数据进行检索，也可以对结果用图表的方式展现。</p></li><li><p><strong>监控和报警</strong></p><p>自动报警是一个非常典型的场景，可以基于已经存储和索引好的日志数据，制定相应的自动报警规则，当线上服务发生异常时，可以自动地触发报警，通知相关值班人员及时处理。</p><p>ELK 可以通过插件的方式，安装像 <a href="https://github.com/Yelp/elastalert">ElastAlert</a> 或<a href="http://www.elastic.co/guide/en/watcher/current/introduction.html">Watcher</a>这样的自动报警插件，实现自动报警功能。</p><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e4%b9%8b%e7%be%8e/assets/8d59a0962b445900d7668b266e0adf6f.png"></p></li></ul><h3 id="怎样搭建一套日志管理系统"><a href="#怎样搭建一套日志管理系统" class="headerlink" title="怎样搭建一套日志管理系统"></a>怎样搭建一套日志管理系统</h3><ul><li><p>Splunk</p><p>Splunk 是一套商业的日志管理系统，搜索功能非常强大，操作方便，就目前来说，要比 ELK 好用，但价钱很高。</p></li><li><p>Grafana</p><p>Grafana 是一套开源的数据监测和可视化工具，可以和 ELK 或 Splunk 配合使用，展示效果比 Kibana 要更好。同时可以支持自动报警功能。</p></li><li><p>Wavefront</p><p>Wavefront 是 VMware 旗下的一款商业的图形化监控和分析工具，可以从 ELK 或 Splunk 等数据源收集数据，在此基础上分析应用的性能瓶颈所在，排除故障。也支持自动报警。</p></li><li><p>PagerDuty</p><p>PagerDuty 是一套报警服务，不仅可以和手机、邮件、Slack 等方便地集成，还可以和企业的轮值安排结合，按照排班顺序呼叫当值人员。</p></li></ul><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a><strong>项目总结</strong></h2><h3 id="如何做好项目复盘"><a href="#如何做好项目复盘" class="headerlink" title="如何做好项目复盘"></a>如何做好项目复盘</h3><ol><li><p>回顾项目目标</p><p>要回顾最初的项目目标，方便对最终结果进行评估。<strong>只有做到准确和客观，在后续才能对目标的完成情况进行准确地评估。</strong></p></li><li><p>评估项目结果</p><p>在对项目的目标进行回顾后，就可以来看看项目的实际结果和当初的目标有多少差异了。这里需要列出两方面的差异：好的差异和坏的差异。</p></li><li><p>分析原因</p><p>分析的时候可以主要从两方面着手：是什么原因导致了好的差异，什么原因导致了坏的差异。<strong>只有分析清楚原因，才能总结出规律。</strong></p></li><li><p>总结规律，落实行动</p><ul><li>需求变更是导致项目延期的主要源头，需要在后续项目中控制好需求的变更；</li><li>自动化测试加上代码审查，再配合持续集成工具，可以有效提升产品质量；</li><li>任务跟踪系统可以方便地跟踪需求的执行情况，也能保证项目成员能及时同步需求的变更。</li></ul></li></ol><h2 id="小团队"><a href="#小团队" class="headerlink" title="小团队"></a><strong>小团队</strong></h2><h3 id="小团队在软件开发中存在的常见问题"><a href="#小团队在软件开发中存在的常见问题" class="headerlink" title="小团队在软件开发中存在的常见问题"></a>小团队在软件开发中存在的常见问题</h3><ul><li>成本敏感</li><li>人少活多</li><li>缺少流程规范</li></ul><h3 id="小团队如何应用软件工程"><a href="#小团队如何应用软件工程" class="headerlink" title="小团队如何应用软件工程"></a>小团队如何应用软件工程</h3><ul><li><p><strong>团队建设</strong></p><ul><li><p>培养人</p><p><strong>培养人主要还是要靠内部形成好的学习分享的机制；</strong></p><p>在工作过程中不断实践和总结，在这个过程中，及时准确的反馈很重要；</p><p>代码审查，可以帮助团队及时发现代码问题，也能促进团队相互学习，代码风格统一；</p><p>自动化测试，可以对代码结果马上有直观的反馈，有问题早发现修正；</p><p>持续集成也是通过频繁地集成频繁地给出有效反馈，及早发现代码问题。</p></li><li><p>管理人</p><p><strong>核心在于营造好的氛围，鼓励成员自我驱动去做事。</strong></p></li><li><p>开除人</p></li></ul></li><li><p><strong>流程建设</strong></p><ul><li>选择适合的软件开发模型</li><li>构建基于源代码管理工具的开发流程</li><li>建立外部提交需求和任务的流程</li></ul></li></ul><h2 id="业余项目"><a href="#业余项目" class="headerlink" title="业余项目"></a><strong>业余项目</strong></h2><h3 id="为什么程序员的业余项目大多都死了"><a href="#为什么程序员的业余项目大多都死了" class="headerlink" title="为什么程序员的业余项目大多都死了"></a>为什么程序员的业余项目大多都死了</h3><ul><li>想法大，时间少</li><li>过于追求技术，缺少约束</li><li>缺少产品能力和运营能力</li></ul><h3 id="怎样提升业余项目成功的概率"><a href="#怎样提升业余项目成功的概率" class="headerlink" title="怎样提升业余项目成功的概率"></a>怎样提升业余项目成功的概率</h3><ul><li>作为一个业余项目，你可以先实现最核心的功能。可以采用 MVP（minimum viable product，最小化的可行性产品）的模式，一开始只推出最核心的功能，满足用户最核心的需求，然后在用户的使用过程中收集反馈，进一步升级迭代。</li><li>做项目计划，去设置里程碑。还要敢于把计划和里程碑分享给你的家人和朋友们，公开的做出里程碑的承诺，让他们帮助监督你的计划执行。</li><li>从解决自己的需求，解决家人朋友的需求开始，设定一个小的产品目标，然后借鉴类似的产品，模仿它们的产品设计、交互设计，就能做出来一个基本可用的产品。</li></ul><h2 id="反面案例"><a href="#反面案例" class="headerlink" title="反面案例"></a><strong>反面案例</strong></h2><h3 id="失败的软件项目特征"><a href="#失败的软件项目特征" class="headerlink" title="失败的软件项目特征"></a>失败的软件项目特征</h3><p>成功的项目必须满足六个条件：</p><ol><li>按时交付。</li><li>成本在预算范围内。</li><li>能按照当初的设计正常运行。</li><li>有人使用。</li><li>满足项目最初的目标。</li><li>项目出资方对项目满意。</li></ol><p>相应的失败的项目存在：</p><ol><li>没能按时交付。</li><li>成本超出预算。</li><li>Bug 太多，无法按照当初的设计正常运行。</li><li>产品没有得到市场认可，没有人使用。</li><li>产品偏移了最初的目标。</li><li>项目出资方不满意。</li></ol><h3 id="失败软件项目的原因"><a href="#失败软件项目的原因" class="headerlink" title="失败软件项目的原因"></a>失败软件项目的原因</h3><ul><li><p><strong>外部环境</strong></p><p>对于商业软件项目，很多是由于缩减成本导致的。因为商业竞争的大环境，企业为了节约成本，总是希望用更少的人做更多的事情。</p></li><li><p><strong>技术管理</strong></p><p>比如说在项目中使用了不成熟或不熟悉的技术，最终导致技术不可控，或者浪费大量的时间在技术的学习上。项目的规模也会导致技术复杂度直线上升，项目规模越大，失败的概率也更大。</p></li><li><p><strong>项目管理</strong></p><p>一个软件项目中，项目经理掌握了资源的分配，还要制定项目的计划，对任务进行分配，组织分工协作，管理风险，项目成员的日常沟通等等。而这些决策通常很难量化，需要基于当时的情况进行权衡，一旦这些决策出现大的失误，就会导致项目的失败。</p></li><li><p><strong>组织文化</strong></p><p>在软件项目中，一个开放、平等、注重沟通协作的团队或组织更容易及早发现和解决问题。</p></li></ul><h3 id="失败的软件项目"><a href="#失败的软件项目" class="headerlink" title="失败的软件项目"></a>失败的软件项目</h3><ul><li><p>来自地狱的项目</p><p>来自法国政府，，原计划 2-3 年开发，结果干了十几年都没有完成，最终以项目负责人被以欺诈罪关进监狱而告终。详细内容可以查看中文版本：《<a href="https://zhuanlan.zhihu.com/p/39827365">开发 12 年 整整 6 百万行代码：史上最烂的开发项目长这样</a>》。</p><ul><li><strong>外部环境</strong>：法国政府官员腐败，对于项目进度并没有施加压力；</li><li><strong>技术管理</strong>：没有好的开发实践，完全 C++ 开发，600 万行代码，版本控制一团糟；</li><li><strong>项目管理</strong>：糟糕的项目管理，团队成员 55 人，35 名经理，20 名开发人员，管理人员比开发人员还多；不断开会，只是展示 PPT；</li><li><strong>组织文化</strong>：禁止超过 9 点打卡，禁止喝咖啡等奇葩要求。</li></ul></li><li><p>美国联邦调查局虚拟案件文档系统</p><p>初始目标是 3 年内将原有的 FBI 案件文档管理系统升级，但因为 911 恐怖袭击事件爆发，项目目标从升级变成了重写。最终 2005 年项目宣布废弃，而此时已经在这个项目上花费了 1.7 亿美元。有关项目的细节可以参考：《<a href="https://linux.cn/article-2307-1.html">著名豆腐渣软件项目：美国联邦调查局虚拟案件文档系统</a>》。</p><ul><li><strong>外部环境</strong>：FBI 没有真正懂技术的负责人领导和管控项目，对承包商缺少控制；</li><li><strong>技术管理</strong>：无法解决项目的复杂性，系统在设计上不完整，不充分，不到位，以至于在现实场景中完全无法使用，上线前没有测试；</li><li><strong>项目管理</strong>：开发方和客户之间沟通不畅；频繁需求变更，项目管理混乱，外行领导内行；</li><li><strong>组织文化</strong>：指出问题的雇员反而被调查和开除。</li></ul></li><li><p>微软 Vista 项目</p><p>开始与 2001 年 7 月，预计 2003 年发布。比尔盖茨为 Vista 提出了三大目标：1. 完全使用 C# 提升开发效率；2. 使用数据库作为新的文件系统 WinFS；3. 使用全新的显示技术 Avalon （后来改名为 WPF），打破桌面软件和网站的用户界面界限，提升微软竞争力。技术难度非常大，结果三年后也未能开发完成，不得不在 2004 年对目标进行调整：不用 C#、取消 WinFS、删改 Avalon ，一开始的三大目标就这样被完全否决，最终 2007 年才发布 Vista。参考文章：《<a href="https://blog.51cto.com/jiayu/22476">五年磨砺: 微软 Vista 开发过程全记录</a>》。</p><ul><li><strong>外部环境</strong>：在目标的设定上，主要不是为了满足用户需求，而是为了商业上的竞争需要；</li><li><strong>技术管理</strong>：技术上难度过大，超出团队控制范围，无法完成任务；</li><li><strong>项目管理</strong>：比尔盖茨对项目直接干预较多，项目周期太长；</li><li><strong>组织文化</strong>：盖茨制定目标后，核心团队明知困难，却不敢也没有反对，当看到任务无法完成时，他们不再努力工作，只想着如何推卸责任。</li></ul></li></ul><h2 id="VS-Code如何应用软件工程"><a href="#VS-Code如何应用软件工程" class="headerlink" title="VS Code如何应用软件工程"></a>VS Code如何应用软件工程</h2><h3 id="VS-Code-的开发迭代过程"><a href="#VS-Code-的开发迭代过程" class="headerlink" title="VS Code 的开发迭代过程"></a>VS Code 的开发迭代过程</h3><p>VS Code 采用的是快速迭代的开发模式，每四周一个迭代。</p><ol><li><p>第一周</p><p>一方面要准备新版本，一方面还要对上一个版本的工作进行收尾；</p><p>做一些偿还技术债务的事情，比如说重构代码，优化性能；</p><p>一起讨论下一个迭代要做的功能。</p></li><li><p>第二周和第三周</p><p>按照计划去开发，一部分是开发新功能，一部分是修复 Bug；</p><p>团队成员每天还要先检查一下分配给自己的 Issue，如果遇到线上版本紧急的 Bug，要优先修复。</p></li><li><p>第四周</p><p>测试所有新的 Feature 和验证已经修复的 Bug，确保被修复；</p><p>同时还要更新文档和写 Release Notes。</p></li></ol><h3 id="VS-Code-团队的角色和分工"><a href="#VS-Code-团队的角色和分工" class="headerlink" title="VS Code 团队的角色和分工"></a>VS Code 团队的角色和分工</h3><p>从角色上来说，除了开发，还有主要有两种角色：<a href="https://github.com/microsoft/vscode/wiki/Issue-Tracking#inbox-tracking">Inbox Tracker</a>和<a href="https://github.com/microsoft/vscode/wiki/Running-the-Endgame#duties-of-the-endgame-master">Endgame Master</a>。这两种角色在每个迭代的时候是轮值的，每个人都有机会去担任这两个角色。</p><ul><li><p><strong>Inbox Tracker</strong></p><p>Inbox Tracker 的主要任务就是收集、验证、跟踪 Bug。Inbox Tracker 要检查新提交的 Issue 是不是一个真正的 Bug，如果是提问，建议到 StackOverflow 去问，如果是 Bug，打上 Bug 的标签，并指派给相应模块的负责人。</p></li><li><p><strong>Endgame Master</strong></p><p>Endgame Master 在每个迭代测试之前，根据迭代的开发计划制定相应的测试计划，生成 Check List，确保每一个新的功能都有在 Check List 中列出来。因为 VS Code 团队没有专职测试，为了避免开发人员自己测试自己的代码会存在盲区，所以自己写的功能都是让其他人帮忙测试。Endgame Master 一个主要工作就是要将这些测试项分配给团队成员。</p></li></ul><h3 id="VS-Code-的各个阶段"><a href="#VS-Code-的各个阶段" class="headerlink" title="VS Code 的各个阶段"></a>VS Code 的各个阶段</h3><ol><li><p><strong>VS Code 的需求收集和版本计划</strong></p><p>VS Code 的需求，一部分是团队内部产生的；一部分是从社区收集的，比如 GitHub、Twitter、StackOverflow 的反馈。VS Code 每半年或一年会对下一个阶段做一个<a href="https://github.com/microsoft/vscode/wiki/Roadmap">Roadmap</a>，规划下一个半年或一年的计划。</p><p><strong>怎么将 Issue 和迭代关联起来呢？</strong></p><p>GitHub 的 Issue 管理有一个 Milestone 的功能，VS Code 有四个主要的 Milestone。</p><ul><li>当前迭代：当前正在开发中的 Milestone；</li><li>On Deck：下一个迭代对应的 Milestone；</li><li>Backlog：还没开始，表示未来要做的；</li><li>Recovery：已经完成的迭代，但是可能要打一些补丁。</li></ul></li><li><p><strong>VS Code 的设计和开发</strong></p><p>VS Code 的开发流程也是用的<a href="https://guides.github.com/introduction/flow/">GitHub Flow</a>，要开发一个新功能或者修复一个 Bug，都创建一个新的分支，开发完成之后提交 PR。PR 合并之前，必须要有核心成员的代码审查通过，并且要确保所有的自动化测试通过。VS Code 的<a href="http://dev.azure.com/vscode/VSCode">CI（持续集成）</a>用的是微软自己的 Azure DevOps，每一次提交代码到 GitHub，CI 都会运行单元测试和集成测试代码，对 Windows/Linux/macOS 三个操作系统分别运行测试。</p></li><li><p><strong>VS Code 的测试</strong></p><p>具体测试的时候，大家就是遵循 Endgame Master 制定好的测试计划，各自按照 Check List 逐一去检查验证，确保所有的新功能都通过了测试，标记为修复的 Bug 真的被修复了。对于验证通过的 Bug，在对应的 Issue 上打上 verified 的标签。</p></li><li><p><strong>VS Code 的发布流程</strong></p><p>在 Endgame 测试后，就要从 master 创建一个 release 分支出去，比如说 release/1.10 ，后面的预发布版本和正式版本包括补丁版本都将从这个 release 分支发布。如果在创建 release 分支后发现了新的 Bug，那么对 Bug 修复的代码，要同时合并到 master 和 release 分支。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程之美-极客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 菜鸟教程</title>
      <link href="/2023/11/14/html5-cai-niao-jiao-cheng/"/>
      <url>/2023/11/14/html5-cai-niao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5-简介"><a href="#HTML5-简介" class="headerlink" title="HTML5 简介"></a>HTML5 简介</h2><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li>新元素</li><li>新属性</li><li>完全支持 CSS3</li><li>Video 和 Audio</li><li>2D/3D 制图</li><li>本地存储</li><li>本地 SQL 数据</li><li>Web 应用</li></ul><h3 id="HTML5-多媒体"><a href="#HTML5-多媒体" class="headerlink" title="HTML5 多媒体"></a>HTML5 多媒体</h3><p>使用 HTML5 你可以简单的在网页中播放 视频(video)与音频 (audio) 。</p><ul><li>HTML5&lt;video&gt;</li><li>HTML5 &lt;audio&gt;</li></ul><h3 id="HTML5-应用"><a href="#HTML5-应用" class="headerlink" title="HTML5 应用"></a>HTML5 应用</h3><p>使用 HTML5 可以简单地开发应用</p><ul><li>本地数据存储</li><li>访问本地文件</li><li>本地 SQL 数据</li><li>缓存引用</li><li>Javascript 工作者</li><li>XHTMLHttpRequest 2</li></ul><h3 id="HTML5-图形"><a href="#HTML5-图形" class="headerlink" title="HTML5 图形"></a>HTML5 图形</h3><p>使用 HTML5 可以简单的绘制图形:</p><ul><li>使用 &lt;canvas&gt;元素。</li><li>使用内联 <a href="https://www.runoob.com/html/html5-svg.html">SVG</a>。</li><li>使用 <a href="https://www.runoob.com/css3/css3-2dtransforms.html">CSS3 2D 转换</a>、<a href="https://www.runoob.com/css3/css3-3dtransforms.html">CSS3 3D 转换</a>。</li></ul><h3 id="HTML5-使用-CSS3"><a href="#HTML5-使用-CSS3" class="headerlink" title="HTML5 使用 CSS3"></a>HTML5 使用 CSS3</h3><ul><li>新选择器</li><li>新属性</li><li>动画</li><li>2D/3D 转换</li><li>圆角</li><li>阴影效果</li><li>可下载的字体</li></ul><h3 id="HTML5-新语义元素"><a href="#HTML5-新语义元素" class="headerlink" title="HTML5 新语义元素"></a>HTML5 新语义元素</h3><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&lt;article&gt;</td><td align="center">定义页面独立的内容区域。</td></tr><tr><td align="center">&lt;aside&gt;</td><td align="center">定义页面的侧边栏内容。</td></tr><tr><td align="center">&lt;bdi&gt;</td><td align="center">允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td align="center">&lt;command&gt;</td><td align="center">定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td align="center">&lt;details&gt;</td><td align="center">用于描述文档或文档某个部分的细节</td></tr><tr><td align="center">&lt;dialog&gt;</td><td align="center">定义对话框，比如提示框</td></tr><tr><td align="center">&lt;summary&gt;</td><td align="center">标签包含 details 元素的标题</td></tr><tr><td align="center">&lt;figure&gt;</td><td align="center">规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td align="center">&lt;figcaption&gt;</td><td align="center">定义 &lt;figure&gt; 元素的标题</td></tr><tr><td align="center">&lt;footer&gt;</td><td align="center">定义 section 或 document 的页脚。</td></tr><tr><td align="center">&lt;header&gt;</td><td align="center">定义了文档的头部区域</td></tr><tr><td align="center">&lt;mark&gt;</td><td align="center">定义带有记号的文本。</td></tr><tr><td align="center">&lt;meter&gt;</td><td align="center">定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td align="center">&lt;nav&gt;</td><td align="center">定义导航链接的部分。</td></tr><tr><td align="center">&lt;progress&gt;</td><td align="center">定义任何类型的任务的进度。</td></tr><tr><td align="center">&lt;ruby&gt;</td><td align="center">定义 ruby 注释（中文注音或字符）。</td></tr><tr><td align="center">&lt;rt&gt;</td><td align="center">定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td align="center">&lt;rp&gt;</td><td align="center">在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。</td></tr><tr><td align="center">&lt;section&gt;</td><td align="center">定义文档中的节（section、区段）。</td></tr><tr><td align="center">&lt;time&gt;</td><td align="center">定义日期或时间。</td></tr><tr><td align="center">&lt;wbr&gt;</td><td align="center">规定在文本中的何处适合添加换行符。</td></tr></tbody></table><h2 id="HTML5-Canvas"><a href="#HTML5-Canvas" class="headerlink" title="HTML5 Canvas"></a>HTML5 Canvas</h2><h3 id="什么是-canvas"><a href="#什么是-canvas" class="headerlink" title="什么是 canvas"></a>什么是 canvas</h3><p>HTML5 &lt;canvas&gt; 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.</p><p>&lt;canvas&gt; 标签只是图形容器，必须使用脚本来绘制图形。</p><p>可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。</p><h3 id="创建一个画布（Canvas）"><a href="#创建一个画布（Canvas）" class="headerlink" title="创建一个画布（Canvas）"></a>创建一个画布（Canvas）</h3><p>一个画布在网页中是一个矩形框，通过 &lt;canvas&gt; 元素来绘制。</p><p><strong>注意:</strong> 默认情况下 &lt;canvas&gt; 元素<strong>没有边框和内容</strong>。</p><p>使用 style 属性来添加边框：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">"border:1px solid #000000;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用-JavaScript-来绘制图像"><a href="#使用-JavaScript-来绘制图像" class="headerlink" title="使用 JavaScript 来绘制图像"></a>使用 JavaScript 来绘制图像</h3><p>所有的绘制工作必须在 JavaScript 内部完成：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);<span class="comment">// 找到 &lt;canvas&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);<span class="comment">// 创建 context 对象</span></span><br><span class="line"><span class="comment">// 绘制一个红色的矩形</span></span><br><span class="line">ctx.<span class="property">fillStyle</span>=<span class="string">"#FF0000"</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);<span class="comment">// 设置fillStyle属性：可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Canvas-坐标"><a href="#Canvas-坐标" class="headerlink" title="Canvas 坐标"></a>Canvas 坐标</h3><p>canvas 是一个二维网格。</p><p>canvas 的左上角坐标为 (0,0)</p><p>上面的 fillRect 方法拥有参数 (0,0,150,75)。</p><p>意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。</p><h3 id="Canvas-路径"><a href="#Canvas-路径" class="headerlink" title="Canvas 路径"></a>Canvas 路径</h3><p>在Canvas上画线，使用以下两种方法：</p><ul><li><strong>moveTo(<em>x,y</em>)</strong> 定义线条开始坐标</li><li><strong>lineTo(<em>x,y</em>)</strong> 定义线条结束坐标</li></ul><p>绘制线条必须使用到 “ink” 的方法，就像stroke().</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></tbody></table></figure><p>在canvas中绘制圆形：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);</span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">95</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="Canvas-文本"><a href="#Canvas-文本" class="headerlink" title="Canvas 文本"></a>Canvas 文本</h3><p>使用 canvas 绘制文本，重要的属性和方法如下：</p><ul><li>font - 定义字体</li><li><strong>fillText(<em>text,x,y</em>)</strong> - 在 canvas 上绘制实心的文本</li><li><strong>strokeText(<em>text,x,y</em>)</strong> - 在 canvas 上绘制空心的文本</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);</span><br><span class="line">ctx.<span class="property">font</span>=<span class="string">"30px Arial"</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">"Hello World"</span>,<span class="number">10</span>,<span class="number">50</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="Canvas-渐变"><a href="#Canvas-渐变" class="headerlink" title="Canvas 渐变"></a>Canvas 渐变</h3><p>渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。</p><p>以下有两种不同的方式来设置Canvas渐变：</p><ul><li><strong>createLinearGradient(<em>x,y,x1,y1</em>)</strong> - 创建线条渐变</li><li><strong>createRadialGradient(<em>x,y,r,x1,y1,r1</em>)</strong> - 创建一个径向/圆渐变</li></ul><p>当我们使用渐变对象，必须使用<strong>两种或两种以上</strong>的停止颜色。</p><p>addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建渐变</span></span><br><span class="line"><span class="keyword">var</span> grd=ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">grd.<span class="title function_">addColorStop</span>(<span class="number">0</span>,<span class="string">"red"</span>);</span><br><span class="line">grd.<span class="title function_">addColorStop</span>(<span class="number">1</span>,<span class="string">"white"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 填充渐变</span></span><br><span class="line">ctx.<span class="property">fillStyle</span>=grd;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="Canvas-图像"><a href="#Canvas-图像" class="headerlink" title="Canvas 图像"></a>Canvas 图像</h3><p>把一幅图像放置到画布上, 使用以下方法:</p><ul><li><strong>drawImage(<em>image,x,y</em>)</strong></li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"myCanvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx=c.<span class="title function_">getContext</span>(<span class="string">"2d"</span>);</span><br><span class="line"><span class="keyword">var</span> img=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"scream"</span>);</span><br><span class="line">ctx.<span class="title function_">drawImage</span>(img,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-SVG"><a href="#HTML5-SVG" class="headerlink" title="HTML5 SVG"></a>HTML5 SVG</h2><h3 id="什么是SVG"><a href="#什么是SVG" class="headerlink" title="什么是SVG"></a>什么是SVG</h3><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 用于定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 是万维网联盟的标准</li></ul><h3 id="SVG优势"><a href="#SVG优势" class="headerlink" title="SVG优势"></a>SVG优势</h3><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul><h3 id="SVG-直接嵌入-HTML-页面"><a href="#SVG-直接嵌入-HTML-页面" class="headerlink" title="SVG 直接嵌入 HTML 页面"></a>SVG 直接嵌入 HTML 页面</h3><p>在 HTML5 中，能够将 SVG 元素直接嵌入 HTML 页面中。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"100"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"40"</span> <span class="attr">stroke</span>=<span class="string">"black"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h3><p><img src="https://gcdnb.pbrd.co/images/3Bgzg1MrzOZT.png?o=1"></p><h2 id="HTML5-MathML"><a href="#HTML5-MathML" class="headerlink" title="HTML5 MathML"></a>HTML5 MathML</h2><p>HTML5 可以在文档中使用 MathML 元素，对应的标签是 &lt;math&gt;…&lt;/math&gt; 。</p><p>MathML 是数学标记语言，是一种基于XML（标准通用标记语言的子集）的标准，用来在互联网上书写数学符号和公式的置标语言。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">math</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1998/Math/MathML"</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="tag">&lt;<span class="name">mrow</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">msup</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>a<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span><span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">mo</span>&gt;</span>+<span class="tag">&lt;/<span class="name">mo</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">msup</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>b<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span><span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">mo</span>&gt;</span>=<span class="tag">&lt;/<span class="name">mo</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="tag">&lt;<span class="name">msup</span>&gt;</span><span class="tag">&lt;<span class="name">mi</span>&gt;</span>c<span class="tag">&lt;/<span class="name">mi</span>&gt;</span><span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span><span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="tag">&lt;/<span class="name">mrow</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp; &nbsp; <span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><br><span class="line">&nbsp; &nbsp;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-拖放"><a href="#HTML5-拖放" class="headerlink" title="HTML5 拖放"></a>HTML5 拖放</h2><h3 id="设置元素为可拖放"><a href="#设置元素为可拖放" class="headerlink" title="设置元素为可拖放"></a>设置元素为可拖放</h3><p>首先，为了使元素可拖动，把 draggable 属性设置为 true ：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="拖动什么：ondragstart-和-setData"><a href="#拖动什么：ondragstart-和-setData" class="headerlink" title="拖动什么：ondragstart 和 setData()"></a>拖动什么：ondragstart 和 setData()</h3><p>规定当元素被拖动时，会发生什么。</p><p>ondragstart 属性可以调用函数来规定被拖动的数据。</p><p>dataTransfer.setData() 方法设置被拖数据的数据类型和值：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function drag(ev)</span><br><span class="line">{</span><br><span class="line">    ev.dataTransfer.setData("Text",ev.target.id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Text 是一个 DOMString 表示要添加到 drag object 的拖动数据的类型。值是可拖动元素的 id ("drag1")。</span><br></pre></td></tr></tbody></table></figure><h3 id="放到何处：ondragover"><a href="#放到何处：ondragover" class="headerlink" title="放到何处：ondragover"></a>放到何处：ondragover</h3><p>ondragover 事件规定<strong>在何处放置</strong>被拖动的数据。</p><p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。这要通过调用 ondragover 事件的 event.preventDefault() 方法：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()</span><br></pre></td></tr></tbody></table></figure><h3 id="进行放置：ondrop"><a href="#进行放置：ondrop" class="headerlink" title="进行放置：ondrop"></a>进行放置：ondrop</h3><p>当放置被拖数据时，会发生 drop 事件。</p><p>ondrop 属性可以调用函数drop(event)：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function drop(ev)</span><br><span class="line">{</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">    var data=ev.dataTransfer.getData("Text");</span><br><span class="line">    ev.target.appendChild(document.getElementById(data));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码解释：</p><ul><li>调用 preventDefault() 来<strong>避免浏览器对数据的默认处理</strong>（<strong>drop 事件的默认行为是以链接形式打开</strong>）</li><li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li><li>被拖数据是被拖元素的 id (“drag1”)</li><li>把被拖元素追加到放置元素（目标元素）中</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#div1</span> {<span class="attribute">width</span>:<span class="number">350px</span>;<span class="attribute">height</span>:<span class="number">70px</span>;<span class="attribute">padding</span>:<span class="number">10px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#aaaaaa</span>;}</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">allowDrop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="language-javascript">{</span></span><br><span class="line"><span class="language-javascript">    ev.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">}</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="language-javascript">{</span></span><br><span class="line"><span class="language-javascript">    ev.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">"Text"</span>,ev.<span class="property">target</span>.<span class="property">id</span>);</span></span><br><span class="line"><span class="language-javascript">}</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">drop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="language-javascript">{</span></span><br><span class="line"><span class="language-javascript">    ev.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> data=ev.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">"Text"</span>);</span></span><br><span class="line"><span class="language-javascript">    ev.<span class="property">target</span>.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(data));</span></span><br><span class="line"><span class="language-javascript">}</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>拖动 RUNOOB.COM 图片到矩形框中:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span> <span class="attr">ondrop</span>=<span class="string">"drop(event)"</span> <span class="attr">ondragover</span>=<span class="string">"allowDrop(event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"drag1"</span> <span class="attr">src</span>=<span class="string">"/images/logo.png"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"drag(event)"</span> <span class="attr">width</span>=<span class="string">"336"</span> <span class="attr">height</span>=<span class="string">"69"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-地理定位"><a href="#HTML5-地理定位" class="headerlink" title="HTML5 地理定位"></a>HTML5 地理定位</h2><h3 id="使用地理定位"><a href="#使用地理定位" class="headerlink" title="使用地理定位"></a>使用地理定位</h3><p>使用 <strong>getCurrentPosition()</strong> 方法来获得用户的位置。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x=document.getElementById("demo");</span><br><span class="line">function getLocation()</span><br><span class="line">{</span><br><span class="line">    if (navigator.geolocation)</span><br><span class="line">    {</span><br><span class="line">        navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        x.innerHTML="该浏览器不支持获取地理位置。";</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">function showPosition(position)</span><br><span class="line">{</span><br><span class="line">    x.innerHTML="纬度: " + position.coords.latitude + </span><br><span class="line">    "<span class="tag">&lt;<span class="name">br</span>&gt;</span>经度: " + position.coords.longitude;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>检测是否支持地理定位</li><li>如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。</li><li>如果 getCurrentPosition() 运行成功，则向参数showPosition中规定的函数返回一个 <strong>coordinates 对象</strong></li><li>showPosition() 函数获得并显示经度和纬度</li></ul><h3 id="处理错误和拒绝"><a href="#处理错误和拒绝" class="headerlink" title="处理错误和拒绝"></a>处理错误和拒绝</h3><p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showError</span>(<span class="params">error</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(error.<span class="property">code</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> error.<span class="property">PERMISSION_DENIED</span>:</span><br><span class="line">            x.<span class="property">innerHTML</span>=<span class="string">"用户拒绝对获取地理位置的请求。"</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> error.<span class="property">POSITION_UNAVAILABLE</span>:</span><br><span class="line">            x.<span class="property">innerHTML</span>=<span class="string">"位置信息是不可用的。"</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> error.<span class="property">TIMEOUT</span>:</span><br><span class="line">            x.<span class="property">innerHTML</span>=<span class="string">"请求用户地理位置超时。"</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> error.<span class="property">UNKNOWN_ERROR</span>:</span><br><span class="line">            x.<span class="property">innerHTML</span>=<span class="string">"未知错误。"</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>Permission denied - 用户不允许地理定位</li><li>Position unavailable - 无法获取当前位置</li><li>Timeout - 操作超时</li></ul><h3 id="在地图中显示结果"><a href="#在地图中显示结果" class="headerlink" title="在地图中显示结果"></a>在地图中显示结果</h3><p>如需在地图中显示结果，需要访问可使用经纬度的地图服务，如谷歌地图或百度地图：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showPosition</span>(<span class="params">position</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> latlon=position.<span class="property">coords</span>.<span class="property">latitude</span>+<span class="string">","</span>+position.<span class="property">coords</span>.<span class="property">longitude</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> img_url=<span class="string">"http://maps.googleapis.com/maps/api/staticmap?center="</span></span><br><span class="line">    +latlon+<span class="string">"&amp;zoom=14&amp;size=400x300&amp;sensor=false"</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"mapholder"</span>).<span class="property">innerHTML</span>=<span class="string">"&lt;img src='"</span>+img_url+<span class="string">"'&gt;"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="getCurrentPosition-返回的数据"><a href="#getCurrentPosition-返回的数据" class="headerlink" title="getCurrentPosition() 返回的数据"></a>getCurrentPosition() 返回的数据</h3><p>若成功，则 getCurrentPosition() 方法返回coordinates 对象。<strong>始终会返回 latitude、longitude 以及 accuracy 属性。</strong>如果可用，则会返回其他下面的属性。</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">coords.latitude</td><td align="center">十进制数的纬度</td></tr><tr><td align="center">coords.longitude</td><td align="center">十进制数的经度</td></tr><tr><td align="center">coords.accuracy</td><td align="center">位置精度</td></tr><tr><td align="center">coords.altitude</td><td align="center">海拔，海平面以上以米计</td></tr><tr><td align="center">coords.altitudeAccuracy</td><td align="center">位置的海拔精度</td></tr><tr><td align="center">coords.heading</td><td align="center">方向，从正北开始以度计</td></tr><tr><td align="center">coords.speed</td><td align="center">速度，以米/每秒计</td></tr><tr><td align="center">timestamp</td><td align="center">响应的日期/时间</td></tr></tbody></table><h3 id="Geolocation-对象其他方法"><a href="#Geolocation-对象其他方法" class="headerlink" title="Geolocation 对象其他方法"></a>Geolocation 对象其他方法</h3><p><strong>watchPosition()</strong> - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。</p><p><strong>clearWatch()</strong> - 停止 watchPosition() 方法</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"demo"</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLocation</span>(<span class="params"></span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (navigator.<span class="property">geolocation</span>)</span><br><span class="line">    {</span><br><span class="line">        navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(showPosition);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        x.<span class="property">innerHTML</span>=<span class="string">"该浏览器不支持获取地理位置。"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showPosition</span>(<span class="params">position</span>)</span><br><span class="line">{</span><br><span class="line">    x.<span class="property">innerHTML</span>=<span class="string">"纬度: "</span> + position.<span class="property">coords</span>.<span class="property">latitude</span> + </span><br><span class="line">    <span class="string">"&lt;br&gt;经度: "</span> + position.<span class="property">coords</span>.<span class="property">longitude</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-视频"><a href="#HTML5-视频" class="headerlink" title="HTML5 视频"></a>HTML5 视频</h2><h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line">您的浏览器不支持Video标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>&lt;video&gt; 元素提供了 播放、暂停和音量控件来控制视频。</p><p>同时 &lt;video&gt; 元素也提供了 width 和 height 属性控制视频的尺寸。如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。</p><p>&lt;video&gt; 与&lt;/video&gt; 标签之间插入的内容是<strong>提供给不支持 video 元素的浏览器显示的。</strong></p><p>&lt;video&gt; 元素支持多个 &lt;source&gt; 元素. &lt;source&gt; 元素可以链接不同的视频文件。<strong>浏览器将使用第一个可识别的格式。</strong></p><h3 id="浏览器的支持"><a href="#浏览器的支持" class="headerlink" title="浏览器的支持"></a>浏览器的支持</h3><p>&lt;video&gt; 元素支持三种视频格式： MP4, WebM, 和 Ogg:</p><table><thead><tr><th align="left">浏览器</th><th align="left">MP4</th><th align="left">WebM</th><th align="left">Ogg</th></tr></thead><tbody><tr><td align="left">Internet Explorer</td><td align="left">YES</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">Chrome</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left">Firefox</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left">Safari</td><td align="left">YES</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">Opera</td><td align="left">YES (从 Opera 25 起)</td><td align="left">YES</td><td align="left">YES</td></tr></tbody></table><ul><li>MP4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li><li>WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li><li>Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li></ul><h3 id="使用-DOM-进行控制"><a href="#使用-DOM-进行控制" class="headerlink" title="使用 DOM 进行控制"></a>使用 DOM 进行控制</h3><p>HTML5 &lt;video&gt; 和 &lt;audio&gt; 元素同样拥有方法、属性和事件。</p><p>&lt;video&gt; 和 &lt;audio&gt;元素的方法、属性和事件可以使用JavaScript进行控制.</p><p>其中的方法用于播放、暂停以及加载等。其中的属性（比如时长、音量等）可以被读取或设置。其中的 DOM 事件能够通知您，比方说，&lt;video&gt; 元素开始播放、已暂停，已停止，等等。</p><h2 id="HTML5-音频"><a href="#HTML5-音频" class="headerlink" title="HTML5 音频"></a>HTML5 音频</h2><h3 id="如何工作-1"><a href="#如何工作-1" class="headerlink" title="如何工作"></a>如何工作</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>control 属性供添加播放、暂停和音量控件。</p><p>在&lt;audio&gt; 与 &lt;/audio&gt; 之间需要插入<strong>浏览器不支持的&lt;audio&gt;元素的提示文本</strong> 。</p><p>&lt;audio&gt; 元素允许使用多个 &lt;source&gt; 元素。&lt;source&gt; 元素可以链接不同的音频文件，<strong>浏览器将使用第一个支持的音频文件。</strong></p><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>&lt;audio&gt;元素支持三种音频格式文件: MP3, Wav, 和 Ogg:</p><table><thead><tr><th align="left">浏览器</th><th align="left">MP3</th><th align="left">Wav</th><th align="left">Ogg</th></tr></thead><tbody><tr><td align="left">Internet Explorer 9+</td><td align="left">YES</td><td align="left">NO</td><td align="left">NO</td></tr><tr><td align="left">Chrome 6+</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left">Firefox 3.6+</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr><tr><td align="left">Safari 5+</td><td align="left">YES</td><td align="left">YES</td><td align="left">NO</td></tr><tr><td align="left">Opera 10+</td><td align="left">YES</td><td align="left">YES</td><td align="left">YES</td></tr></tbody></table><h2 id="HTML5-新的-Input-类型"><a href="#HTML5-新的-Input-类型" class="headerlink" title="HTML5 新的 Input 类型"></a>HTML5 新的 Input 类型</h2><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>color 类型用在input字段主要用于选取颜色：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择你喜欢的颜色: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span> <span class="attr">name</span>=<span class="string">"favcolor"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date 类型允许从一个日期选择器选择一个日期：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生日: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">name</span>=<span class="string">"bday"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p>datetime 类型允许选择一个日期（UTC 时间）：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生日 (日期和时间): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span> <span class="attr">name</span>=<span class="string">"bdaytime"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="datetime-local"><a href="#datetime-local" class="headerlink" title="datetime-local"></a>datetime-local</h3><p>datetime-local 类型允许你选择一个日期和时间 (无时区)：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生日 (日期和时间): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span> <span class="attr">name</span>=<span class="string">"bdaytime"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><p>email 类型用于应该包含 e-mail 地址的输入域：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="month"><a href="#month" class="headerlink" title="month"></a>month</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生日 (月和年): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"month"</span> <span class="attr">name</span>=<span class="string">"bdaymonth"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>number 类型用于应该包含数值的输入域。还能够设定对所接受的数字的限定：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数量 ( 1 到 5 之间 ): <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"quantity"</span> <span class="attr">min</span>=<span class="string">"1"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">max</span>=<span class="string">"5"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用下面的属性来规定对数字类型的限定：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">disabled</td><td align="left">规定输入字段是禁用的</td></tr><tr><td align="left">max</td><td align="left">规定允许的最大值</td></tr><tr><td align="left">maxlength</td><td align="left">规定输入字段的最大字符长度</td></tr><tr><td align="left">min</td><td align="left">规定允许的最小值</td></tr><tr><td align="left">pattern</td><td align="left">规定用于验证输入字段的模式</td></tr><tr><td align="left">readonly</td><td align="left">规定输入字段的值无法修改</td></tr><tr><td align="left">required</td><td align="left">规定输入字段的值是必需的</td></tr><tr><td align="left">size</td><td align="left">规定输入字段中的可见字符数</td></tr><tr><td align="left">step</td><td align="left">规定输入字段的合法数字间隔</td></tr><tr><td align="left">value</td><td align="left">规定输入字段的默认值</td></tr></tbody></table><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"10"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>使用下面的属性来规定对数字类型的限定：</p><ul><li>max - 规定允许的最大值</li><li>min - 规定允许的最小值</li><li>step - 规定合法的数字间隔</li><li>value - 规定默认值</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>search 类型用于搜索域，比如站点搜索或 Google 搜索。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Search Google: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">name</span>=<span class="string">"googlesearch"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="tel"><a href="#tel" class="headerlink" title="tel"></a>tel</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电话号码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span> <span class="attr">name</span>=<span class="string">"usrtel"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>time 类型允许选择一个时间：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择时间: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span> <span class="attr">name</span>=<span class="string">"usr_time"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加您的主页: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">name</span>=<span class="string">"homepage"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="week"><a href="#week" class="headerlink" title="week"></a>week</h3><p>week 类型允许选择周和年：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择周: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span> <span class="attr">name</span>=<span class="string">"week_year"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-表单元素"><a href="#HTML5-表单元素" class="headerlink" title="HTML5 表单元素"></a>HTML5 表单元素</h2><h3 id="元素"><a href="#元素" class="headerlink" title="<datalist> 元素"></a>&lt;datalist&gt; 元素</h3><p>&lt;datalist&gt; 元素规定<strong>输入域的选项列表</strong>。</p><p>&lt;datalist&gt; 属性规定 form 或 input 域应该拥有自动完成功能。</p><p>当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。</p><p>使用 &lt;input&gt; 元素的列表属性与 &lt;datalist&gt; 元素绑定:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Opera"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Safari"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-1"><a href="#元素-1" class="headerlink" title="<keygen> 元素"></a>&lt;keygen&gt; 元素</h3><p>&lt;keygen&gt; 元素的作用是提供一种<strong>验证用户</strong>的可靠方法。</p><p>&lt;keygen&gt;标签规定用于表单的<strong>密钥对生成器</strong>字段。</p><p>当提交表单时，会生成两个键，一个是私钥，一个公钥。</p><p><strong>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo_keygen.asp"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"usr_name"</span>&gt;</span></span><br><span class="line">加密: <span class="tag">&lt;<span class="name">keygen</span> <span class="attr">name</span>=<span class="string">"security"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-2"><a href="#元素-2" class="headerlink" title="<output> 元素"></a>&lt;output&gt; 元素</h3><p>&lt;output&gt; 元素用于不同类型的输出，比如计算或脚本输出：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span>0</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>100 +</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>=</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-表单属性"><a href="#HTML5-表单属性" class="headerlink" title="HTML5 表单属性"></a>HTML5 表单属性</h2><h3 id="autocomplete-属性"><a href="#autocomplete-属性" class="headerlink" title="<form> / <input> autocomplete 属性"></a>&lt;form&gt; / &lt;input&gt; autocomplete 属性</h3><p>autocomplete 属性规定 form 或 input 域应该拥有<strong>自动完成</strong>功能。</p><p>当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。</p><p><strong>提示:</strong> autocomplete 属性有可能在 form元素中是开启的，而在input元素中是关闭的。</p><p><strong>注意:</strong> autocomplete 适用于 &lt;form&gt; 标签，以及以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, datepickers, range 以及 color。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo-form.php"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span>&gt;</span></span><br><span class="line">  First name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="novalidate-属性"><a href="#novalidate-属性" class="headerlink" title="<form> novalidate 属性"></a>&lt;form&gt; novalidate 属性</h3><p>novalidate 属性是 HTML 表单元素的一个布尔属性，用于设置浏览器不<strong>对表单进行验证</strong>。</p><p>当该属性被添加到 &lt;form&gt; 元素上时，浏览器将<strong>不会执行默认的表单验证</strong>，<strong>不会检查输入字段是否符合指定的验证规则</strong>。</p><p>使用 novalidate 属性可以让开发者完全控制表单验证的逻辑，可以通过 JavaScript 或其他方式来自定义表单验证的行为。</p><h3 id="autofocus-属性"><a href="#autofocus-属性" class="headerlink" title="<input> autofocus 属性"></a>&lt;input&gt; autofocus 属性</h3><p>autofocus 属性是一个布尔属性。</p><p>autofocus 属性规定在页面加载时，<strong>域自动地获得焦点</strong>。</p><h3 id="form-属性"><a href="#form-属性" class="headerlink" title="<input> form 属性"></a>&lt;input&gt; form 属性</h3><p>form 属性规定<strong>输入域所属的一个或多个表单</strong>。</p><p>**提示:**如需引用一个以上的表单，请使用空格分隔的列表。</p><h3 id="formaction-属性"><a href="#formaction-属性" class="headerlink" title="<input> formaction 属性"></a>&lt;input&gt; formaction 属性</h3><p>The formaction 属性用于<strong>描述表单提交的URL地址</strong>。</p><p>The formaction 属性会覆盖&lt;form&gt; 元素中的action属性。</p><p><strong>注意:</strong> The formaction 属性用于 type=”submit” 和 type=”image”。</p><h3 id="formenctype-属性"><a href="#formenctype-属性" class="headerlink" title="<input> formenctype 属性"></a>&lt;input&gt; formenctype 属性</h3><p>formenctype 属性描述了<strong>表单提交到服务器的数据编码</strong> (只对form表单中 method=”post” 表单)</p><p>formenctype 属性覆盖 form 元素的 enctype 属性。</p><p><strong>主要:</strong> 该属性与 type=”submit” 和 type=”image” 配合使用。</p><h3 id="formmethod-属性"><a href="#formmethod-属性" class="headerlink" title="<input> formmethod 属性"></a>&lt;input&gt; formmethod 属性</h3><p>formmethod 属性定义了<strong>表单提交的方式</strong>。</p><p>formmethod 属性覆盖了 &lt;form&gt; 元素的 method 属性。</p><p><strong>注意:</strong> 该属性可以与 type=”submit” 和 type=”image” 配合使用。</p><h3 id="formnovalidate-属性"><a href="#formnovalidate-属性" class="headerlink" title="<input> formnovalidate 属性"></a>&lt;input&gt; formnovalidate 属性</h3><p>novalidate 属性是一个布尔属性。</p><p>novalidate属性描述了 &lt;input&gt; 元素在表单<strong>提交时无需被验证</strong>。</p><p>formnovalidate 属性会覆盖 &lt;form&gt; 元素的novalidate属性.</p><p><strong>注意:</strong> formnovalidate 属性与 <strong>type=”submit”</strong> 一起使用</p><h3 id="formtarget-属性"><a href="#formtarget-属性" class="headerlink" title="<input> formtarget 属性"></a>&lt;input&gt; formtarget 属性</h3><p>formtarget 属性指定一个名称或一个关键字来<strong>指明表单提交数据接收后的展示</strong>。</p><p>formtarget 属性覆盖 &lt;form&gt;元素的target属性.</p><p><strong>注意:</strong> formtarget 属性与 <strong>type=”submit”</strong> 和 <strong>type=”image”</strong> 配合使用。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo-form.php"</span>&gt;</span></span><br><span class="line">  First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"正常提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">formtarget</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"提交到一个新的页面上"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="height-和-width-属性"><a href="#height-和-width-属性" class="headerlink" title="<input> height 和 width 属性"></a>&lt;input&gt; height 和 width 属性</h3><p>height 和 width 属性规定用于 image 类型的 &lt;input&gt; 标签的<strong>图像高度和宽度</strong>。</p><p><strong>注意:</strong> height 和 width 属性只适用于 image 类型的&lt;input&gt; 标签。</p><h3 id="list-属性"><a href="#list-属性" class="headerlink" title="<input> list 属性"></a>&lt;input&gt; list 属性</h3><p>list 属性<strong>规定输入域的 datalist</strong>。datalist 是输入域的选项列表。</p><h3 id="min-和-max-属性"><a href="#min-和-max-属性" class="headerlink" title="<input> min 和 max 属性"></a>&lt;input&gt; min 和 max 属性</h3><p>min、max 和 step 属性用于<strong>为包含数字或日期的 input 类型规定限定（约束）</strong>。</p><p><strong>注意:</strong> min、max 和 step 属性适用于以下类型的 &lt;input&gt; 标签：date pickers、number 以及 range。</p><h3 id="multiple-属性"><a href="#multiple-属性" class="headerlink" title="<input> multiple 属性"></a>&lt;input&gt; multiple 属性</h3><p>multiple 属性是一个布尔属性.</p><p>multiple 属性规定&lt;input&gt; 元素中<strong>可选择多个值</strong>。</p><p><strong>注意:</strong> multiple 属性适用于以下类型的 &lt;input&gt; 标签：email 和 file。</p><h3 id="pattern-属性"><a href="#pattern-属性" class="headerlink" title="<input> pattern 属性"></a>&lt;input&gt; pattern 属性</h3><p>pattern 属性描述了<strong>一个正则表达式用于验证 &lt;input&gt; 元素的值</strong>。</p><p>**注意:**pattern 属性适用于以下类型的 &lt;input&gt; 标签: text, search, url, tel, email, 和 password。</p><p><strong>提示：</strong> 是用来全局 <a href="https://www.runoob.com/tags/tag-title.html">title</a> 属性来描述模式。</p><h3 id="placeholder-属性"><a href="#placeholder-属性" class="headerlink" title="<input> placeholder 属性"></a>&lt;input&gt; placeholder 属性</h3><p>placeholder 属性提供一种提示（hint），<strong>描述输入域所期待的值</strong>。</p><p>简短的提示在用户输入值前会显示在输入域上。</p><p><strong>注意:</strong> placeholder 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email 以及 password。</p><h3 id="required-属性"><a href="#required-属性" class="headerlink" title="<input> required 属性"></a>&lt;input&gt; required 属性</h3><p>required 属性是一个布尔属性.</p><p>required 属性规定必须<strong>在提交之前填写输入域（不能为空）</strong>。</p><p>**注意:**required 属性适用于以下类型的 &lt;input&gt; 标签：text, search, url, telephone, email, password, date pickers, number, checkbox, radio 以及 file。</p><h3 id="step-属性"><a href="#step-属性" class="headerlink" title="<input> step 属性"></a>&lt;input&gt; step 属性</h3><p>step 属性为<strong>输入域规定合法的数字间隔</strong>。</p><p>如果 step=”3”，则合法的数是 -3,0,3,6 等。</p><p><strong>提示：</strong>step 属性可以与 max 和 min 属性创建一个区域值。</p><p><strong>注意:</strong> step 属性与以下type类型一起使用: number, range, date, datetime, datetime-local, month, time 和 week。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"points"</span> <span class="attr">step</span>=<span class="string">"3"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-语义元素"><a href="#HTML5-语义元素" class="headerlink" title="HTML5 语义元素"></a>HTML5 语义元素</h2><h3 id="什么是语义元素"><a href="#什么是语义元素" class="headerlink" title="什么是语义元素"></a>什么是语义元素</h3><p>一个语义元素能够清楚的描述其意义给浏览器和开发者。</p><p><strong>无语义</strong>元素实例: &lt;div&gt; 和 &lt;span&gt; - 无需考虑内容。</p><p><strong>语义</strong>元素实例: &lt;form&gt;, &lt;table&gt;, and &lt;img&gt; - 清楚的定义了它的内容。</p><h3 id="元素-3"><a href="#元素-3" class="headerlink" title="<section> 元素"></a>&lt;section&gt; 元素</h3><p>&lt;section&gt; 标签定义文档中的节（section、区段）。比如<strong>章节、页眉、页脚或文档中的其他部分。</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WWF<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The World Wide Fund for Nature (WWF) is....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-4"><a href="#元素-4" class="headerlink" title="<article> 元素"></a>&lt;article&gt; 元素</h3><p>&lt;article&gt; 标签定义<strong>独立的内容</strong>。.</p><p>&lt;article&gt; 元素使用实例:</p><ul><li>Forum post</li><li>Blog post</li><li>News story</li><li>Comment</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Internet Explorer 9<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Windows Internet Explorer 9(缩写为 IE9 )在2011年3月14日21:00 发布。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-5"><a href="#元素-5" class="headerlink" title="<nav> 元素"></a>&lt;nav&gt; 元素</h3><p>&lt;nav&gt; 标签定义<strong>导航链</strong>接的部分。</p><p>&lt;nav&gt; 元素用于定义页面的导航链接部分区域，但是，不是所有的链接都需要包含在 &lt;nav&gt; 元素中。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/html/"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/css/"</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/js/"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/jquery/"</span>&gt;</span>jQuery<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-6"><a href="#元素-6" class="headerlink" title="<aside> 元素"></a>&lt;aside&gt; 元素</h3><p>&lt;aside&gt; 标签定义<strong>页面主区域内容之外的内容（比如侧边栏）</strong>。</p><p>aside 标签的内容应与主区域的内容相关。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My family and I visited The Epcot center this summer.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Epcot Center<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The Epcot Center is a theme park in Disney World, Florida.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-7"><a href="#元素-7" class="headerlink" title="<header> 元素"></a>&lt;header&gt; 元素</h3><p>&lt;header&gt;元素描述了<strong>文档的头部区域</strong>。&lt;header&gt;元素主要用于定义内容的介绍展示区域。</p><p>在页面中可以使用多个&lt;header&gt; 元素。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Internet Explorer 9<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">time</span> <span class="attr">pubdate</span> <span class="attr">datetime</span>=<span class="string">"2011-03-15"</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Windows Internet Explorer 9(缩写为 IE9 )是在2011年3月14日21:00发布的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-8"><a href="#元素-8" class="headerlink" title="<footer> 元素"></a>&lt;footer&gt; 元素</h3><p>&lt;footer&gt; 元素描述了<strong>文档的底部区域</strong>。</p><p>&lt;footer&gt; 元素应该包含它的包含元素。</p><p>一个页脚通常包含<strong>文档的作者，著作权信息，链接的使用条款，联系信息</strong>等</p><p>文档中可以使用多个 &lt;footer&gt;元素。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Posted by: Hege Refsnes<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">time</span> <span class="attr">pubdate</span> <span class="attr">datetime</span>=<span class="string">"2012-03-01"</span>&gt;</span><span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="和-元素"><a href="#和-元素" class="headerlink" title="<figure> 和 <figcaption> 元素"></a>&lt;figure&gt; 和 &lt;figcaption&gt; 元素</h3><p>&lt;figure&gt;标签规定<strong>独立的流内容（图像、图表、照片、代码等等）</strong>。</p><p>&lt;figure&gt; 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。</p><p>&lt;figcaption&gt; 标签定义 &lt;figure&gt; 元素的标题。</p><p>&lt;figcaption&gt;元素应该被置于 “figure” 元素的<strong>第一个或最后一个子元素的位置</strong>。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img_pulpit.jpg"</span> <span class="attr">alt</span>=<span class="string">"The Pulpit Rock"</span> <span class="attr">width</span>=<span class="string">"304"</span> <span class="attr">height</span>=<span class="string">"228"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Fig1. - The Pulpit Pock, Norway.<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-Web-存储"><a href="#HTML5-Web-存储" class="headerlink" title="HTML5 Web 存储"></a>HTML5 Web 存储</h2><h3 id="什么是-HTML5-Web-存储"><a href="#什么是-HTML5-Web-存储" class="headerlink" title="什么是 HTML5 Web 存储"></a>什么是 HTML5 Web 存储</h3><p>使用HTML5可以<strong>在本地存储用户的浏览数据</strong>。</p><p>早些时候，本地存储使用的是 cookie。但是Web 存储需要<strong>更加的安全与快速</strong>。 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上。它也可以存储大量的数据，而不影响网站的性能。</p><p>数据以 <strong>键/值 对</strong>存在, web网页的数据只允许该网页访问使用。</p><h3 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h3><p>客户端存储数据的两个对象为：</p><ul><li><p>localStorage - 用于<strong>长久保存</strong>整个网站的数据，保存的数据<strong>没有过期时间</strong>，直到手动去除。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">"sitename"</span>, <span class="string">"菜鸟教程"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span> = <span class="string">"网站名："</span> +  <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">"sitename"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">"sitename"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>使用 <strong>key=”sitename”</strong> 和 <strong>value=”菜鸟教程”</strong> 创建一个 localStorage 键/值对。</li><li>检索键值为 “sitename” 的值然后将数据插入 <strong>id=”result”</strong> 的元素中。</li><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul></li><li><p>sessionStorage - 用于<strong>临时保存</strong>同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">sessionStorage</span>.<span class="property">clickcount</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="property">clickcount</span>=<span class="title class_">Number</span>(<span class="variable language_">sessionStorage</span>.<span class="property">clickcount</span>)+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="property">clickcount</span>=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span>=<span class="string">"在这个会话中你已经点击了该按钮 "</span> + <span class="variable language_">sessionStorage</span>.<span class="property">clickcount</span> + <span class="string">" 次 "</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="Web-Storage-开发一个简单的网站列表程序"><a href="#Web-Storage-开发一个简单的网站列表程序" class="headerlink" title="Web Storage 开发一个简单的网站列表程序"></a>Web Storage 开发一个简单的网站列表程序</h3><p>实现以下功能：</p><ul><li>可以输入网站名，网址，以网站名作为key存入localStorage；</li><li>根据网站名，查找网址；</li><li>列出当前已保存的所有网站；</li></ul><p><strong>保存与查找数据</strong>：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存数据  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">save</span>(<span class="params"></span>){  </span><br><span class="line">    <span class="keyword">var</span> siteurl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"siteurl"</span>).<span class="property">value</span>;  </span><br><span class="line">    <span class="keyword">var</span> sitename = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"sitename"</span>).<span class="property">value</span>;  </span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(sitename, siteurl);</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">"添加成功"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//查找数据  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params"></span>){  </span><br><span class="line">    <span class="keyword">var</span> search_site = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"search_site"</span>).<span class="property">value</span>;  </span><br><span class="line">    <span class="keyword">var</span> sitename = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(search_site);  </span><br><span class="line">    <span class="keyword">var</span> find_result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"find_result"</span>);  </span><br><span class="line">    find_result.<span class="property">innerHTML</span> = search_site + <span class="string">"的网址是："</span> + sitename;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>实例</strong>：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"border: 2px dashed #ccc;width:320px;text-align:center;"</span>&gt;     </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sitename"</span>&gt;</span>网站名(key)：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"sitename"</span> <span class="attr">name</span>=<span class="string">"sitename"</span> <span class="attr">class</span>=<span class="string">"text"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"siteurl"</span>&gt;</span>网 址(value)：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"siteurl"</span> <span class="attr">name</span>=<span class="string">"siteurl"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"save()"</span> <span class="attr">value</span>=<span class="string">"新增记录"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"search_site"</span>&gt;</span>输入网站名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"search_site"</span> <span class="attr">name</span>=<span class="string">"search_site"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"find()"</span> <span class="attr">value</span>=<span class="string">"查找网站"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"find_result"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>使用 <a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify</a> 来存储对象数据，<a href="https://www.runoob.com/js/javascript-json-stringify.html">JSON.stringify</a> 可以将对象转换为字符串:</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> site = <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(site); <span class="comment">// 将对象转换为字符串</span></span><br></pre></td></tr></tbody></table></figure><p><strong>使用 <a href="https://www.runoob.com/js/javascript-json-parse.html">JSON.parse</a> 方法将字符串转换为 JSON 对象：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> site = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br></pre></td></tr></tbody></table></figure><p><strong>JavaScript 实现代码：</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存数据  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">save</span>(<span class="params"></span>){  </span><br><span class="line">    <span class="keyword">var</span> site = <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br><span class="line">    site.<span class="property">keyname</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"keyname"</span>).<span class="property">value</span>;</span><br><span class="line">    site.<span class="property">sitename</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"sitename"</span>).<span class="property">value</span>;  </span><br><span class="line">    site.<span class="property">siteurl</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"siteurl"</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(site); <span class="comment">// 将对象转换为字符串</span></span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(site.<span class="property">keyname</span>,str);  </span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">"保存成功"</span>);</span><br><span class="line">}  </span><br><span class="line"><span class="comment">//查找数据  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">find</span>(<span class="params"></span>){  </span><br><span class="line">    <span class="keyword">var</span> search_site = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"search_site"</span>).<span class="property">value</span>;  </span><br><span class="line">    <span class="keyword">var</span> str = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(search_site);  </span><br><span class="line">    <span class="keyword">var</span> find_result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"find_result"</span>);</span><br><span class="line">    <span class="keyword">var</span> site = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);  </span><br><span class="line">    find_result.<span class="property">innerHTML</span> = search_site + <span class="string">"的网站名是："</span> + site.<span class="property">sitename</span> + <span class="string">"，网址是："</span> + site.<span class="property">siteurl</span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>完整实例如下</strong>：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"border: 2px dashed #ccc;width:320px;text-align:center;"</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"keyname"</span>&gt;</span>别名(key):<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"keyname"</span> <span class="attr">name</span>=<span class="string">"keyname"</span> <span class="attr">class</span>=<span class="string">"text"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sitename"</span>&gt;</span>网站名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"sitename"</span> <span class="attr">name</span>=<span class="string">"sitename"</span> <span class="attr">class</span>=<span class="string">"text"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"siteurl"</span>&gt;</span>网 址：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"siteurl"</span> <span class="attr">name</span>=<span class="string">"siteurl"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"save()"</span> <span class="attr">value</span>=<span class="string">"新增记录"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"search_site"</span>&gt;</span>输入别名(key)：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"search_site"</span> <span class="attr">name</span>=<span class="string">"search_site"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"find()"</span> <span class="attr">value</span>=<span class="string">"查找网站"</span>/&gt;</span></span>  </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"find_result"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-Web-SQL"><a href="#HTML5-Web-SQL" class="headerlink" title="HTML5 Web SQL"></a>HTML5 Web SQL</h2><p>Web SQL 数据库 API 并不是 HTML5 规范的一部分，但是它是一个独立的规范，引入了一组使用 SQL 操作客户端数据库的 APIs。</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>以下是规范中定义的三个核心方法：</p><ol><li><strong>openDatabase</strong>：这个方法使用现有的数据库或者新建的数据库<strong>创建一个数据库对象</strong>。</li><li><strong>transaction</strong>：这个方法让我们能够<strong>控制一个事务</strong>，以及基于这种情况执行提交或者回滚。</li><li><strong>executeSql</strong>：这个方法用于<strong>执行实际的 SQL 查询</strong>。</li></ol><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>我们可以使用 <strong>openDatabase()</strong> 方法来打开已存在的数据库，如果数据库不存在，则会创建一个新的数据库，使用代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="title function_">openDatabase</span>(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br></pre></td></tr></tbody></table></figure><p>openDatabase() 方法对应的五个参数说明：</p><ol><li>数据库名称</li><li>版本号</li><li>描述文本</li><li>数据库大小</li><li>创建回调</li></ol><p>第五个参数，创建回调会在创建数据库后被调用。</p><h3 id="执行查询操作"><a href="#执行查询操作" class="headerlink" title="执行查询操作"></a>执行查询操作</h3><p>执行操作使用 <strong>database.transaction()</strong> 函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="title function_">openDatabase</span>(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span> (<span class="params">tx</span>) {  </span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>上面的语句执行后会在 ‘mydb’ 数据库中创建一个名为 LOGS 的表。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>在执行上面的创建表语句后，可以插入一些数据：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="title function_">openDatabase</span>(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span> (<span class="params">tx</span>) {</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'INSERT INTO LOGS (id, log) VALUES (1, "菜鸟教程")'</span>);</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'INSERT INTO LOGS (id, log) VALUES (2, "www.runoob.com")'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>使用动态值来插入数据：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="title function_">openDatabase</span>(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>); db.<span class="title function_">transaction</span>(<span class="keyword">function</span> (<span class="params">tx</span>) {     </span><br><span class="line">tx.<span class="title function_">executeSql</span>(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);   tx.<span class="title function_">executeSql</span>(<span class="string">'INSERT INTO LOGS (id,log) VALUES (?, ?)'</span>, [e_id, e_log]); </span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>实例中的 e_id 和 e_log 是外部变量，executeSql 会映射数组参数中的每个条目给 “?”。</p><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><p>读取数据库中已经存在的数据：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="title function_">openDatabase</span>(<span class="string">'mydb'</span>, <span class="string">'1.0'</span>, <span class="string">'Test DB'</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span> (<span class="params">tx</span>) {</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'</span>);</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'INSERT INTO LOGS (id, log) VALUES (1, "菜鸟教程")'</span>);</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'INSERT INTO LOGS (id, log) VALUES (2, "www.runoob.com")'</span>);</span><br><span class="line">});</span><br><span class="line"> </span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span> (<span class="params">tx</span>) {</span><br><span class="line">   tx.<span class="title function_">executeSql</span>(<span class="string">'SELECT * FROM LOGS'</span>, [], <span class="keyword">function</span> (<span class="params">tx, results</span>) {</span><br><span class="line">      <span class="keyword">var</span> len = results.<span class="property">rows</span>.<span class="property">length</span>, i;</span><br><span class="line">      msg = <span class="string">"&lt;p&gt;查询记录条数: "</span> + len + <span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">'#status'</span>).<span class="property">innerHTML</span> +=  msg;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++){</span><br><span class="line">         <span class="title function_">alert</span>(results.<span class="property">rows</span>.<span class="title function_">item</span>(i).<span class="property">log</span> );</span><br><span class="line">      }</span><br><span class="line">    </span><br><span class="line">   }, <span class="literal">null</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-应用程序缓存"><a href="#HTML5-应用程序缓存" class="headerlink" title="HTML5 应用程序缓存"></a>HTML5 应用程序缓存</h2><p>通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。</p><h3 id="什么是应用程序缓存（Application-Cache）"><a href="#什么是应用程序缓存（Application-Cache）" class="headerlink" title="什么是应用程序缓存（Application Cache）"></a>什么是应用程序缓存（Application Cache）</h3><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><ol><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ol><h3 id="Cache-Manifest-基础"><a href="#Cache-Manifest-基础" class="headerlink" title="Cache Manifest 基础"></a>Cache Manifest 基础</h3><p>如需启用应用程序缓存，需要在文档的&lt;html&gt; 标签中包含 manifest 属性：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo.appcache"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存。manifest 文件的建议的文件扩展名是：”.appcache”。</p><h3 id="Manifest-文件"><a href="#Manifest-文件" class="headerlink" title="Manifest 文件"></a>Manifest 文件</h3><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p><p>manifest 文件可分为三个部分：</p><ul><li><p><em>CACHE MANIFEST</em> - 在此标题下列出的文件将<strong>在首次下载后进行缓存</strong>，是必需的。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br></pre></td></tr></tbody></table></figure><p>当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。</p></li><li><p><em>NETWORK</em> - 在此标题下列出的文件需要与服务器的连接，且<strong>不会被缓存</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// "login.php" 永远不会被缓存，且离线时是不可用的</span><br><span class="line">NETWORK:</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line">// 使用星号来指示所有其他资源/文件都需要因特网连接</span><br><span class="line">NETWORK:</span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure></li><li><p><em>FALLBACK</em> - 在此标题下列出的文件规定<strong>当页面无法访问时的回退页面</strong>（比如 404 页面）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 规定如果无法建立因特网连接，则用 "offline.html" 替代 /html5/ 目录中的所有文件</span><br><span class="line">FALLBACK:</span><br><span class="line">/html/ /offline.html</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>一旦应用被缓存，它就会保持缓存直到发生下列情况：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改</li><li>由程序来更新应用缓存</li></ul><h2 id="HTML5-Web-Workers"><a href="#HTML5-Web-Workers" class="headerlink" title="HTML5 Web Workers"></a>HTML5 Web Workers</h2><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，<strong>不会影响页面的性能</strong>。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p><h3 id="创建-web-worker-文件"><a href="#创建-web-worker-文件" class="headerlink" title="创建 web worker 文件"></a>创建 web worker 文件</h3><p>在一个外部 JavaScript 中创建 web worker：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timedCount</span>(<span class="params"></span>)</span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; i=i+<span class="number">1</span>;</span><br><span class="line">&nbsp; &nbsp; <span class="title function_">postMessage</span>(i);<span class="comment">// 向HTML页面传回一段消息</span></span><br><span class="line">&nbsp; &nbsp; <span class="built_in">setTimeout</span>(<span class="string">"timedCount()"</span>,<span class="number">500</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">timedCount</span>();</span><br></pre></td></tr></tbody></table></figure><h3 id="创建-Web-Worker-对象"><a href="#创建-Web-Worker-对象" class="headerlink" title="创建 Web Worker 对象"></a>创建 Web Worker 对象</h3><p>已经有了 web worker 文件，现在需要从 HTML 页面调用它。</p><p>检测是否存在 worker，如果不存在，创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_">typeof</span>(w)==<span class="string">"undefined"</span>)</span><br><span class="line">{</span><br><span class="line">    w=<span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">"demo_workers.js"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后就可以从 web worker 发送和接收消息了。向 web worker 添加一个 “onmessage” 事件监听器：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">event</span>){</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span>=event.<span class="property">data</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="终止-Web-Worker"><a href="#终止-Web-Worker" class="headerlink" title="终止 Web Worker"></a>终止 Web Worker</h3><p>创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。</p><p>如需终止 web worker，并释放浏览器/计算机资源，使用 <strong>w.terminate()</strong> 方法。</p><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>&nbsp;</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&nbsp;<span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>&nbsp;</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span>&nbsp;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>计数： <span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始工作<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>停止工作<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Internet Explorer 9 及更早 IE 版本浏览器不支持 Web Workers.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> w;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">startWorker</span>(<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(<span class="title function_">typeof</span>(<span class="title class_">Worker</span>) !== <span class="string">"undefined"</span>) {</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="title function_">typeof</span>(w) == <span class="string">"undefined"</span>) {</span></span><br><span class="line"><span class="language-javascript">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">"demo_workers.js"</span>);</span></span><br><span class="line"><span class="language-javascript">        }</span></span><br><span class="line"><span class="language-javascript">        w.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) {</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span> = event.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">        };</span></span><br><span class="line"><span class="language-javascript">    } <span class="keyword">else</span> {</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span> = <span class="string">"抱歉，你的浏览器不支持 Web Workers..."</span>;</span></span><br><span class="line"><span class="language-javascript">    }</span></span><br><span class="line"><span class="language-javascript">}</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">stopWorker</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="language-javascript">{ </span></span><br><span class="line"><span class="language-javascript">    w.<span class="title function_">terminate</span>();</span></span><br><span class="line"><span class="language-javascript">    w = <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="language-javascript">}</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-服务器发送事件"><a href="#HTML5-服务器发送事件" class="headerlink" title="HTML5 服务器发送事件"></a>HTML5 服务器发送事件</h2><h3 id="ServerSent-事件：单向消息传递"><a href="#ServerSent-事件：单向消息传递" class="headerlink" title="ServerSent 事件：单向消息传递"></a>ServerSent 事件：单向消息传递</h3><p>Server-Sent 事件指的是<strong>网页自动获取来自服务器的更新。</strong></p><p>以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。</p><p>例子：Facebook/Twitter 更新、股价更新、新的博文、赛事结果等。</p><h3 id="接收-Server-Sent-事件通知"><a href="#接收-Server-Sent-事件通知" class="headerlink" title="接收 Server-Sent 事件通知"></a>接收 Server-Sent 事件通知</h3><p><strong>EventSource</strong> 对象用于接收服务器发送事件通知：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 "demo_sse.php"）</span></span><br><span class="line"><span class="keyword">var</span> source=<span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">"demo_sse.php"</span>);</span><br><span class="line"><span class="comment">// 每接收到一次更新，就会发生 onmessage 事件</span></span><br><span class="line">source.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">event</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 当 onmessage 事件发生时，把已接收的数据推入 id 为 "result" 的元素中</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"result"</span>).<span class="property">innerHTML</span>+=event.<span class="property">data</span> + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="服务器端代码实例"><a href="#服务器端代码实例" class="headerlink" title="服务器端代码实例"></a>服务器端代码实例</h3><p>服务器端事件流的语法是非常简单的，把 <strong>“Content-Type”</strong> 报头设置为 **”text/event-stream”**，就可以开始发送事件流了。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">'Content-Type:&nbsp;text/event-stream'</span>);<span class="comment">// 把报头 "Content-Type" 设置为 "text/event-stream"</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">'Cache-Control:&nbsp;no-cache'</span>);<span class="comment">// 把报头 "Content-Type" 设置为 "text/event-stream"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$time&nbsp;</span>=&nbsp;<span class="title function_ invoke__">date</span>(<span class="string">'r'</span>);<span class="comment">// 输出发送日期（始终以 "data: " 开头）</span></span><br><span class="line"><span class="keyword">echo</span>&nbsp;<span class="string">"data:&nbsp;The&nbsp;server&nbsp;time&nbsp;is:&nbsp;<span class="subst">{$time}</span>\n\n"</span>;</span><br><span class="line"><span class="title function_ invoke__">flush</span>();<span class="comment">// 向网页刷新输出数据</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML5-WebSocket"><a href="#HTML5-WebSocket" class="headerlink" title="HTML5 WebSocket"></a>HTML5 WebSocket</h2><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的<strong>协议</strong>。</p><p>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p><img src="https://www.runoob.com/wp-content/uploads/2016/03/ws.png"></p><h3 id="创建-WebSocket-对象"><a href="#创建-WebSocket-对象" class="headerlink" title="创建 WebSocket 对象"></a>创建 WebSocket 对象</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Socket</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></tbody></table></figure><p>第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><h3 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Socket.readyState</td><td align="left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td></tr><tr><td align="left">Socket.bufferedAmount</td><td align="left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td></tr></tbody></table><h3 id="WebSocket-事件"><a href="#WebSocket-事件" class="headerlink" title="WebSocket 事件"></a>WebSocket 事件</h3><table><thead><tr><th align="left">事件</th><th align="left">事件处理程序</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">open</td><td align="left">Socket.onopen</td><td align="left">连接建立时触发</td></tr><tr><td align="left">message</td><td align="left">Socket.onmessage</td><td align="left">客户端接收服务端数据时触发</td></tr><tr><td align="left">error</td><td align="left">Socket.onerror</td><td align="left">通信发生错误时触发</td></tr><tr><td align="left">close</td><td align="left">Socket.onclose</td><td align="left">连接关闭时触发</td></tr></tbody></table><h3 id="WebSocket-方法"><a href="#WebSocket-方法" class="headerlink" title="WebSocket 方法"></a>WebSocket 方法</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Socket.send()</td><td align="left">使用连接发送数据</td></tr><tr><td align="left">Socket.close()</td><td align="left">关闭连接</td></tr></tbody></table><h3 id="WebSocket-实例"><a href="#WebSocket-实例" class="headerlink" title="WebSocket 实例"></a>WebSocket 实例</h3><p>WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">function</span> <span class="title function_">WebSocketTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">         {</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (<span class="string">"WebSocket"</span> <span class="keyword">in</span> <span class="variable language_">window</span>)</span></span><br><span class="line"><span class="language-javascript">            {</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">"您的浏览器支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="language-javascript">               </span></span><br><span class="line"><span class="language-javascript">               <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="language-javascript">               <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">"ws://localhost:9998/echo"</span>);</span></span><br><span class="line"><span class="language-javascript">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><br><span class="line"><span class="language-javascript">               ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">               {</span></span><br><span class="line"><span class="language-javascript">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="language-javascript">                  ws.<span class="title function_">send</span>(<span class="string">"发送数据"</span>);</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">"数据发送中..."</span>);</span></span><br><span class="line"><span class="language-javascript">               };</span></span><br><span class="line"><span class="language-javascript">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><br><span class="line"><span class="language-javascript">               ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">evt</span>) </span></span><br><span class="line"><span class="language-javascript">               { </span></span><br><span class="line"><span class="language-javascript">                  <span class="keyword">var</span> received_msg = evt.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line"><span class="language-javascript">               };</span></span><br><span class="line"><span class="language-javascript">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span><br><span class="line"><span class="language-javascript">               ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">               { </span></span><br><span class="line"><span class="language-javascript">                  <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(<span class="string">"连接已关闭..."</span>); </span></span><br><span class="line"><span class="language-javascript">               };</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">            {</span></span><br><span class="line"><span class="language-javascript">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">"您的浏览器不支持 WebSocket!"</span>);</span></span><br><span class="line"><span class="language-javascript">            }</span></span><br><span class="line"><span class="language-javascript">         }</span></span><br><span class="line"><span class="language-javascript">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sse"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:WebSocketTest()"</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML菜鸟教程</title>
      <link href="/2023/11/12/html-cai-niao-jiao-cheng/"/>
      <url>/2023/11/12/html-cai-niao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p>HTML 是用来描述网页的一种语言。</p><ul><li>HTML 指的是超文本标记语言: <strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage</li><li>HTML 不是一种编程语言，而是一种<strong>标记</strong>语言</li><li>HTML 使用标记标签来<strong>描述</strong>网页</li><li>HTML 文档包含了HTML <strong>标签</strong>及<strong>文本</strong>内容</li><li>HTML文档也叫做 <strong>web 页面</strong></li></ul><h3 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h3><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由<em>尖括号</em>包围的关键词，比如 &lt;html&gt;</li><li>HTML 标签通常是<em>成对出现</em>的，比如 &lt;b&gt; 和 &lt;/b&gt;</li><li>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></li><li>开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></li></ul><h3 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h3><p>“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.</p><p>但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签</p><h3 id="HTML-网页结构"><a href="#HTML-网页结构" class="headerlink" title="HTML 网页结构"></a>HTML 网页结构</h3><p><img src="https://gcdnb.pbrd.co/images/XLJyDurifZ8M.jpg?o=1"></p><p>只有 &lt;body&gt; 区域 (白色部分) 才会在浏览器中显示。</p><h3 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h3><p><img src="https://gcdnb.pbrd.co/images/YjFcyM1uGNJw.png?o=1"></p><p><strong>各版本通用声明：</strong></p><p><strong>HTML5</strong></p><p>&lt;!DOCTYPE html&gt;</p><p><strong>HTML 4.01</strong></p><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”<br>“<a href="http://www.w3.org/TR/html4/loose.dtd%22%3E">http://www.w3.org/TR/html4/loose.dtd"&gt;</a></p><p><strong>XHTML 1.0</strong></p><p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”<br>“<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd%22%3E">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</a></p><h3 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h3><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，需要在头部将字符声明为 UTF-8 或 GBK。</p><h3 id="实例解析"><a href="#实例解析" class="headerlink" title="实例解析"></a>实例解析</h3><p><img src="https://www.runoob.com/wp-content/uploads/2013/06/02A7DD95-22B4-4FB9-B994-DDB5393F7F03.jpg"></p><h2 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h2><h3 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h3><p>HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h3><p>HTML 段落是通过标签 &lt;p&gt; 来定义的。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另外一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-链接"><a href="#HTML-链接" class="headerlink" title="HTML 链接"></a>HTML 链接</h3><p>HTML 链接是通过标签&lt;a&gt; 来定义的。<strong>在 href 属性中指定链接的地址。</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.runoob.com"</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h3><p>HTML 图像是通过标签 &lt;img&gt; 来定义的。<strong>图像的名称和尺寸是以属性的形式提供的。</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">decoding</span>=<span class="string">"async"</span> <span class="attr">src</span>=<span class="string">"/images/logo.png"</span> <span class="attr">width</span>=<span class="string">"258"</span> <span class="attr">height</span>=<span class="string">"39"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<strong>属性</strong></li></ul><h3 id="嵌套的-HTML-元素"><a href="#嵌套的-HTML-元素" class="headerlink" title="嵌套的 HTML 元素"></a>嵌套的 HTML 元素</h3><p>大多数 HTML 元素可以嵌套（HTML 元素可以包含其他 HTML 元素）。</p><p>HTML 文档由相互嵌套的 HTML 元素构成。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">以上实例包含了三个 HTML 元素。</span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-空元素"><a href="#HTML-空元素" class="headerlink" title="HTML 空元素"></a>HTML 空元素</h3><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。</p><p>&lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。</p><p>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。</p><p>在开始标签中添加斜杠，比如&lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。</p><p>即使 &lt;br&gt; 在所有浏览器中都是有效的，但使用 &lt;br /&gt; 其实是更长远的保障。</p><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><h3 id="什么是属性"><a href="#什么是属性" class="headerlink" title="什么是属性"></a>什么是属性</h3><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称/值对的形式出现，<strong>比如：name=”value”</strong></li></ul><h3 id="HTML-属性常用引用属性值"><a href="#HTML-属性常用引用属性值" class="headerlink" title="HTML 属性常用引用属性值"></a>HTML 属性常用引用属性值</h3><p>属性值应该始终被包括在引号内。</p><p>双引号是最常用的，使用单引号也没有问题。</p><p><strong>在某些个别的情况下，比如属性值本身就含有双引号，那么必须使用单引号</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name='John "ShotGun" Nelson'</span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-属性参考手册"><a href="#HTML-属性参考手册" class="headerlink" title="HTML 属性参考手册"></a>HTML 属性参考手册</h3><p><img src="https://gcdnb.pbrd.co/images/EHXLa8ieQwoo.png?o=1"></p><h2 id="HTML标题"><a href="#HTML标题" class="headerlink" title="HTML标题"></a>HTML标题</h2><h3 id="HTML-标题-1"><a href="#HTML-标题-1" class="headerlink" title="HTML 标题"></a>HTML 标题</h3><p>标题（Heading）是通过 &lt;h1&gt; - &lt;h6&gt; 标签进行定义的。</p><p>&lt;h1&gt; 定义最大的标题。 &lt;h6&gt; 定义最小的标题。</p><p><strong>浏览器会自动地在标题的前后添加空行。</strong></p><h3 id="HTML-水平线"><a href="#HTML-水平线" class="headerlink" title="HTML 水平线"></a>HTML 水平线</h3><p>&lt;hr&gt; 标签在 HTML 页面中创建水平线。</p><p>hr 元素可用于分隔内容。</p><h3 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h3><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>开始括号之后（左边的括号）需要紧跟一个叹号 <strong>!</strong> (英文标点符号)，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个注释 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-如何查看源代码"><a href="#HTML-如何查看源代码" class="headerlink" title="HTML 如何查看源代码"></a>HTML 如何查看源代码</h3><p>如果您想找到其中的奥秘，只需要单击右键，然后选择**”查看源文件”（IE）或”查看页面源代码”（Firefox）**，其他浏览器的做法也是类似的。这么做会打开一个包含页面 HTML 代码的窗口。</p><h3 id="HTML-标签参考手册"><a href="#HTML-标签参考手册" class="headerlink" title="HTML 标签参考手册"></a>HTML 标签参考手册</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1699602115349.png"></p><h2 id="HTML段落"><a href="#HTML段落" class="headerlink" title="HTML段落"></a>HTML段落</h2><h3 id="HTML-段落-1"><a href="#HTML-段落-1" class="headerlink" title="HTML 段落"></a>HTML 段落</h3><p>段落是通过 &lt;p&gt; 标签定义的。HTML 可以将文档分割为若干段落。</p><h3 id="HTML-折行"><a href="#HTML-折行" class="headerlink" title="HTML 折行"></a>HTML 折行</h3><p>如果您希望在不产生一个新段落的情况下进行换行（新行），使用 <strong>&lt;br&gt;</strong> 标签.</p><h3 id="HTML-输出"><a href="#HTML-输出" class="headerlink" title="HTML 输出"></a>HTML 输出</h3><p>我们无法确定 HTML 被显示的确切效果。屏幕的大小，以及对窗口的调整都可能导致不同的结果。</p><p>对于 HTML，无法通过在 HTML 代码中添加额外的空格或换行来改变输出的效果。</p><p>浏览器会移除源代码中多余的空格和空行。<strong>所有连续的空格或空行都会被算作一个空格。</strong>需要注意的是，HTML 代码中的<strong>所有连续的空行（换行）也被显示为一个空格</strong>。</p><h2 id="HTML文本格式化"><a href="#HTML文本格式化" class="headerlink" title="HTML文本格式化"></a>HTML文本格式化</h2><h3 id="HTML-格式化标签"><a href="#HTML-格式化标签" class="headerlink" title="HTML 格式化标签"></a>HTML 格式化标签</h3><p>HTML 使用标签 &lt;b&gt;(“bold”) 与 &lt;i&gt;(“italic”) 对输出的文本进行格式, 如：<strong>粗体</strong> or <em>斜体</em></p><p>这些HTML标签被称为格式化标签。</p><p>  <strong>通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用, &lt;em&gt; 替换 &lt;i&gt;标签使用。</strong></p><p>然而，这些标签的含义是不同的：</p><p>&lt;b&gt; 与&lt;i&gt; 定义粗体或斜体文本。</p><p>&lt;strong&gt; 或者 &lt;em&gt;意味着你要呈现的文本是重要的，所以要突出显示。</p><h3 id="HTML-文本格式化标签"><a href="#HTML-文本格式化标签" class="headerlink" title="HTML 文本格式化标签"></a>HTML 文本格式化标签</h3><p><img src="https://gcdnb.pbrd.co/images/YWN195dP4rte.png?o=1"></p><h3 id="HTML-“计算机输出”-标签"><a href="#HTML-“计算机输出”-标签" class="headerlink" title="HTML “计算机输出” 标签"></a>HTML “计算机输出” 标签</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1699604154758.png"></p><h3 id="HTML-引文-引用-及标签定义"><a href="#HTML-引文-引用-及标签定义" class="headerlink" title="HTML 引文, 引用, 及标签定义"></a>HTML 引文, 引用, 及标签定义</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1699604191209.png"></p><h2 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a>HTML链接</h2><h3 id="HTML-超链接"><a href="#HTML-超链接" class="headerlink" title="HTML 超链接"></a>HTML 超链接</h3><p>HTML使用标签 <strong>&lt;a&gt;</strong> 来设置超文本链接。</p><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p><p>在标签 <strong><a></a></strong><a> 中使用了 <strong>href</strong> 属性来描述链接的地址。默认情况下，链接将以以下形式出现在浏览器中：</a></p><a><ul><li>一个未访问过的链接显示为蓝色字体并带有下划线。</li><li>访问过的链接显示为紫色并带有下划线。</li><li>点击链接时，链接显示为红色并带有下划线。</li><li>如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。</li></ul></a><h3 id="HTML-链接语法"><a></a><a href="#HTML-链接语法" class="headerlink" title="HTML 链接语法"></a>HTML 链接语法</h3><p>&lt;a&gt;元素具有以下属性：</p><ul><li><code>href</code>：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。</li><li><code>target</code>（可选）：指定链接如何在浏览器中打开。常见的值包括 <code>_blank</code>（在新标签或窗口中打开链接）和 <code>_self</code>（在当前标签或窗口中打开链接）。</li><li><code>title</code>（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。</li><li><code>rel</code>（可选）：指定与链接目标的关系，如 nofollow、noopener 等。</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>“链接文本”不必一定是文本。图片或其他 HTML 元素都可以成为链接。</p><p><strong>文本链接：</strong>最常见的链接类型是文本链接，它使用 &lt;a&gt; 元素将一段文本转化为可点击的链接，例如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.example.com"</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>图像链接：</strong>还可以使用图像作为链接。在这种情况下，&lt;a&gt; 元素包围着 &lt;img&gt; 元素。例如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.example.com"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.jpg"</span> <span class="attr">alt</span>=<span class="string">"示例图片"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>锚点链接：</strong>除了链接到其他网页外，还可以在同一页面内创建内部链接，这称为锚点链接。要创建锚点链接，需要在目标位置使用 &lt;a&gt; 元素定义一个标记，并使用#符号引用该标记。例如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#section2"</span>&gt;</span>跳转到第二部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在页面中的某个位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"section2"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>下载链接：</strong>如果您希望链接用于下载文件而不是导航到另一个网页，可以使用 download 属性。例如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"document.pdf"</span> <span class="attr">download</span>&gt;</span>下载文档<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="基本的注意事项"><a href="#基本的注意事项" class="headerlink" title="基本的注意事项"></a>基本的注意事项</h3><p><strong>注释：</strong> <strong>将正斜杠添加到子文件夹。</strong></p><p>假如这样书写链接：href=”<a href="https://www.runoob.com/html%22%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A7%E7%94%9F%E4%B8%A4%E6%AC%A1">https://www.runoob.com/html"，就会向服务器产生两次</a> HTTP 请求。因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=”<a href="https://www.runoob.com/html/%22%E3%80%82">https://www.runoob.com/html/"。</a></p><h2 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h2><h3 id="HTML-元素-1"><a href="#HTML-元素-1" class="headerlink" title="HTML <head> 元素"></a>HTML &lt;head&gt; 元素</h3><p>&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。</p><p>可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;。</p><h3 id="HTML-元素-2"><a href="#HTML-元素-2" class="headerlink" title="HTML <title> 元素"></a>HTML &lt;title&gt; 元素</h3><p>&lt;title&gt; 标签定义了不同文档的标题。</p><p>&lt;title&gt; 在 HTML/XHTML 文档中是必需的。</p><p>&lt;title&gt; 元素:</p><ul><li>定义浏览器工具栏的标题</li><li>显示网页在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><h3 id="HTML-元素-3"><a href="#HTML-元素-3" class="headerlink" title="HTML <base> 元素"></a>HTML &lt;base&gt; 元素</h3><p>&lt;base&gt; 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://www.runoob.com/images/"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-元素-4"><a href="#HTML-元素-4" class="headerlink" title="HTML <link> 元素"></a>HTML &lt;link&gt; 元素</h3><p>&lt;link&gt; 标签定义文档与外部资源之间的关系。</p><p>&lt;link&gt; 标签通常用于链接到样式表:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-元素-5"><a href="#HTML-元素-5" class="headerlink" title="HTML <style> 元素"></a>HTML &lt;style&gt; 元素</h3><p>&lt;style&gt; 标签定义了HTML文档的样式文件引用地址。</p><p>在&lt;style&gt; 元素中你也可以直接添加样式来渲染 HTML 文档:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>:yellow;</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> {</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:blue</span></span><br><span class="line"><span class="language-css">}</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-元素-6"><a href="#HTML-元素-6" class="headerlink" title="HTML <meta> 元素"></a>HTML &lt;meta&gt; 元素</h3><p>meta标签描述了一些基本的元数据。</p><p>&lt;meta&gt; 标签提供了元数据，元数据不显示在页面上，但会被浏览器解析。</p><p>META 元素通常用于指定网页的<strong>描述，关键词，文件的最后修改时间，作者，和其他元数据</strong>。</p><p>元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。</p><p>&lt;meta&gt; 一般放置于 &lt;head&gt; 区域</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">为搜索引擎定义关键词:</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"HTML, CSS, XML, XHTML, JavaScript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">为网页定义描述内容:</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"免费 Web &amp; 编程 教程"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">定义网页作者:</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"Runoob"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">每30秒钟刷新当前页面:</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"30"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-元素-7"><a href="#HTML-元素-7" class="headerlink" title="HTML <script> 元素"></a>HTML &lt;script&gt; 元素</h3><p>&lt;script&gt;标签用于加载脚本文件，如： JavaScript。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gcdnb.pbrd.co/images/WwaqEwAAJlXG.png?o=1"></p><h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML CSS"></a>HTML CSS</h2><h3 id="如何使用CSS"><a href="#如何使用CSS" class="headerlink" title="如何使用CSS"></a>如何使用CSS</h3><p>CSS 可以通过以下方式添加到HTML中:</p><ul><li><p>内联样式- 在HTML元素中使用”style” <strong>属性</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue;margin-left:20px;"</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt; <strong>元素</strong> 来包含CSS</p></li><li><p>外部引用 - 使用外部 CSS <strong>文件</strong></p></li></ul><p><strong>最好的方式是通过外部引用CSS文件。</strong></p><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><p><strong>背景颜色</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color:yellow;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">"background-color:red;"</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"background-color:green;"</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>字体，字体颜色 ，字体大小</strong></p><p>可以使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义字体的样式:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"font-family:verdana;"</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-family:arial;color:red;font-size:20px;"</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>文本对齐方式</strong></p><p>使用 text-align（文字对齐）属性指定文本的水平与垂直对齐方式：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span>居中对齐的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>当单个文件需要特别样式时，就可以使用内部样式表。可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> {<span class="attribute">background-color</span>:yellow;}</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> {<span class="attribute">color</span>:blue;}</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，可以通过更改一个文件来改变整个站点的外观。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML图像"><a href="#HTML图像" class="headerlink" title="HTML图像"></a>HTML图像</h2><h3 id="图像标签（）和源属性（Src）"><a href="#图像标签（）和源属性（Src）" class="headerlink" title="图像标签（<img>）和源属性（Src）"></a>图像标签（&lt;img&gt;）和源属性（Src）</h3><p>在 HTML 中，图像由&lt;img&gt; 标签定义。</p><p>&lt;img&gt; 是空标签，它只包含属性，并且没有闭合标签。</p><p>要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。</p><p><strong>定义图像的语法是：</strong>&lt;img src=”url” alt=”some_text”&gt;</p><h3 id="Alt属性"><a href="#Alt属性" class="headerlink" title="Alt属性"></a>Alt属性</h3><p>alt 属性用来为图像定义一串预备的可替换的文本。</p><p>替换文本属性的值是用户定义的。</p><p>在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。</p><h3 id="设置图像的高度与宽度"><a href="#设置图像的高度与宽度" class="headerlink" title="设置图像的高度与宽度"></a>设置图像的高度与宽度</h3><p>height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。</p><p>属性值默认单位为像素:&lt;img src=”pulpit.jpg” alt=”Pulpit rock” width=”304” height=”228”&gt;</p><h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><p><img src="https://gcdnb.pbrd.co/images/f0DOIOgu7JjT.png?o=1" alt="HTML图像标签"></p><h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML 表格"></a>HTML 表格</h2><p>HTML 表格由 <strong>&lt;table&gt;</strong> 标签来定义。</p><p>每个表格均有若干行（由 <strong>&lt;tr&gt;</strong> 标签定义），每行被分割为若干单元格（由 <strong>&lt;td&gt;</strong> 标签定义），表格可以包含标题行（**&lt;th&gt;**）用于定义列的标题。</p><ul><li><strong>tr</strong>：tr 是 table row 的缩写，表示表格的一行。</li><li><strong>td</strong>：td 是 table data 的缩写，表示表格的数据单元格。</li><li><strong>th</strong>：th 是 table header的缩写，表示表格的表头单元格。</li></ul><p>数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p><h3 id="HTML-表格和边框属性"><a href="#HTML-表格和边框属性" class="headerlink" title="HTML 表格和边框属性"></a>HTML 表格和边框属性</h3><p>如果不定义边框属性，表格将不显示边框。</p><p>使用边框属性来显示一个带有边框的表格：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML-表格表头"><a href="#HTML-表格表头" class="headerlink" title="HTML 表格表头"></a>HTML 表格表头</h3><p>表格的表头使用  标签进行定义。</p><p>大多数浏览器会把表头显示为粗体居中的文本。</p><h3 id="HTML表格标签"><a href="#HTML表格标签" class="headerlink" title="HTML表格标签"></a>HTML表格标签</h3><p><img src="https://gcdnb.pbrd.co/images/3OrHMk7GFU5Q.png?o=1"></p><h2 id="HTML区块"><a href="#HTML区块" class="headerlink" title="HTML区块"></a>HTML区块</h2><p>HTML 可以通过 &lt;div&gt; 和 &lt;span&gt;将元素组合起来。</p><h3 id="区块元素"><a href="#区块元素" class="headerlink" title="区块元素"></a>区块元素</h3><p>大多数 HTML 元素被定义为<strong>块级元素</strong>或<strong>内联元素</strong>。</p><p>块级元素在浏览器显示时，通常会以新行来开始（和结束）。</p><p>实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;</p><h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p>内联元素在显示时通常不会以新行开始。</p><p>实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</p><h3 id="元素"><a href="#元素" class="headerlink" title="<div> 元素"></a>&lt;div&gt; 元素</h3><p>HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。</p><p>&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。</p><p>如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。</p><p>&lt;div&gt; 元素的另一个常见的用途是文档布局。</p><h3 id="元素-1"><a href="#元素-1" class="headerlink" title="<span> 元素"></a>&lt;span&gt; 元素</h3><p>HTML &lt;span&gt; 元素是内联元素，可用作文本的容器</p><p>&lt;span&gt; 元素也没有特定的含义。</p><p>当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。</p><h2 id="HTML-表单和输入"><a href="#HTML-表单和输入" class="headerlink" title="HTML 表单和输入"></a>HTML 表单和输入</h2><p>HTML 表单用于收集用户的输入信息。</p><p>HTML 表单表示文档中的一个区域，此区域包含交互控件，将用户收集到的信息发送到 Web 服务器。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单是一个包含表单元素的区域。</p><p>表单元素是允许用户在表单中输入内容，比如：文本域（textarea）、下拉列表（select）、单选框（radio-buttons）、复选框（checkbox） 等等。</p><p>可以使用 <strong>&lt;form&gt;</strong> 标签来创建表单</p><p>多数情况下被用到的表单标签是输入标签 **<input>**。</p><p>输入类型是由 <strong>type</strong> 属性定义。</p><p><strong>文本域（Text Fields）</strong></p><p>文本域通过 <strong>&lt;input type=”text”&gt;</strong> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。默认宽度是 20 个字符。</p><p><strong>密码字段</strong></p><p>密码字段通过标签 <strong>&lt;input type=”password”&gt;</strong> 来定义，不会明文显示，而是以星号 <strong>*</strong> 或圆点 <strong>.</strong> 替代。</p><p><strong>单选按钮（Radio Buttons）</strong></p><p><strong>&lt;input type=”radio”&gt;</strong> 标签定义了表单的单选框选项。</p><p><strong>复选框（Checkboxes）</strong></p><p><strong>&lt;input type=”checkbox”&gt;</strong> 定义了复选框。</p><p><strong>提交按钮(Submit)</strong></p><p><strong>&lt;input type=”submit”&gt;</strong> 定义了提交按钮。</p><p>当用户单击确认按钮时，表单的内容会被传送到服务器。表单的动作属性 <strong>action</strong> 定义了服务端的文件名。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"input"</span> <span class="attr">action</span>=<span class="string">"html_form_action.php"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p> method 属性，它用于定义表单数据的提交方式，可以是以下值：</p><ul><li><strong>post</strong>：指的是 HTTP POST 方法，表单数据会包含在表单体内然后发送给服务器，用于提交敏感数据，如用户名与密码等。</li><li><strong>get</strong>：默认值，指的是 HTTP GET 方法，表单数据会附加在 <strong>action</strong> 属性的 URL 中，并以 **?**作为分隔符，一般用于不敏感信息，如分页等。例如：<a href="https://www.runoob.com/?page=1%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84">https://www.runoob.com/?page=1，这里的</a> page=1 就是 get 方法提交的数据。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"firstname"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lastname"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span>男<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"Bike"</span>&gt;</span>我喜欢自行车<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"vehicle"</span> <span class="attr">value</span>=<span class="string">"Car"</span>&gt;</span>我喜欢小汽车</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"input"</span> <span class="attr">action</span>=<span class="string">"html_form_action.php"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下表单使用 GET 请求发送数据到当前的 URL，method 默认位 GET。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:</span><br><span class="line">&nbsp; &nbsp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"submitted-name"</span> <span class="attr">autocomplete</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">button</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下表单使用 POST 请求发送数据到当前的 URL。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:</span><br><span class="line">&nbsp; &nbsp; <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"submitted-name"</span> <span class="attr">autocomplete</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">button</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 表单使用 fieldset, legend, 和 label 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">&nbsp; &nbsp; <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span>&gt;</span> Select me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><img src="https://gcdnb.pbrd.co/images/pMyMuNP21dmg.png?o=1"></p><h2 id="HTML-框架"><a href="#HTML-框架" class="headerlink" title="HTML 框架"></a>HTML 框架</h2><p>通过使用框架，可以在同一个浏览器窗口中显示不止一个页面。</p><p><strong>iframe语法:</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"URL"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>该URL指向不同的网页。</p><h3 id="设置高度与宽度"><a href="#设置高度与宽度" class="headerlink" title="设置高度与宽度"></a>设置高度与宽度</h3><p>height 和 width 属性用来定义iframe标签的高度与宽度。</p><p>属性默认以像素为单位, 但是你可以指定其按比例显示 (如：”80%”)。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"demo_iframe.htm"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="移除边框"><a href="#移除边框" class="headerlink" title="移除边框"></a>移除边框</h3><p>frameborder 属性用于定义iframe表示是否显示边框。</p><p>设置属性值为 “0” 移除iframe的边框。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"demo_iframe.htm"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="使用-iframe-来显示目标链接页面"><a href="#使用-iframe-来显示目标链接页面" class="headerlink" title="使用 iframe 来显示目标链接页面"></a>使用 iframe 来显示目标链接页面</h3><p>iframe 可以显示一个目标链接的页面，目标链接的属性必须使用 iframe 的属性。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"demo_iframe.htm"</span> <span class="attr">name</span>=<span class="string">"iframe_a"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.runoob.com"</span> <span class="attr">target</span>=<span class="string">"iframe_a"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span>&gt;</span>RUNOOB.COM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML颜色"><a href="#HTML颜色" class="headerlink" title="HTML颜色"></a>HTML颜色</h2><p>HTML 颜色由红色、绿色、蓝色混合而成。</p><h3 id="颜色值"><a href="#颜色值" class="headerlink" title="颜色值"></a>颜色值</h3><p>HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。</p><p>每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。</p><p><img src="https://gcdnb.pbrd.co/images/byE54zHiugDn.png?o=1"></p><p>三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。</p><h3 id="Web安全色"><a href="#Web安全色" class="headerlink" title="Web安全色"></a>Web安全色</h3><p>数年以前，当大多数计算机仅支持 256 种颜色的时候，一系列 <strong>216 种 Web 安全色</strong>作为 Web 标准被建议使用。其中的原因是，微软和 Mac 操作系统使用了 40 种不同的保留的固定系统颜色（双方大约各使用 20 种）。</p><p>最初，216 跨平台 web 安全色被用来确保：当计算机使用 256 色调色板时，所有的计算机能够正确地显示所有的颜色。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1700192194533.png"></p><h2 id="HTML-脚本"><a href="#HTML-脚本" class="headerlink" title="HTML 脚本"></a>HTML 脚本</h2><h3 id="标签"><a href="#标签" class="headerlink" title="<script> 标签"></a>&lt;script&gt; 标签</h3><p>&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。</p><p>&lt;script&gt; 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。</p><p>JavaScript 最常用于图片操作、表单验证以及内容动态更新。</p><p>下面的脚本会向浏览器输出”Hello World!”：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">"Hello World!"</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="标签-1"><a href="#标签-1" class="headerlink" title="<noscript> 标签"></a>&lt;noscript&gt; 标签</h3><p>&lt;noscript&gt; 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。</p><p>&lt;noscript&gt;元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。</p><p>只有在浏览器不支持脚本或者禁用脚本时，才会显示 &lt;noscript&gt; 元素中的内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">"Hello World!"</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>抱歉，你的浏览器不支持 JavaScript!<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-字符实体"><a href="#HTML-字符实体" class="headerlink" title="HTML 字符实体"></a>HTML 字符实体</h2><p>HTML 中的预留字符必须被替换为字符实体。</p><p>一些在键盘上找不到的字符也可以使用字符实体来替换。</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>在 HTML 中，某些字符是预留的。</p><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;entity_name;</span><br><span class="line">或</span><br><span class="line">&amp;#entity_number;</span><br></pre></td></tr></tbody></table></figure><p>如需显示小于号，必须这样写：<strong>&amp;lt;</strong> 或 <strong>&amp;#60;</strong> 或 <strong>&amp;#060;</strong></p><h3 id="不间断空格-Non-breaking-Space"><a href="#不间断空格-Non-breaking-Space" class="headerlink" title="不间断空格(Non-breaking Space)"></a>不间断空格(Non-breaking Space)</h3><p>HTML 中的常用字符实体是不间断空格(&nbsp;)。</p><p>浏览器总是会截短 HTML 页面中的空格。如果在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，需要使用&amp;nbsp; 字符实体。</p><h3 id="结合音标符"><a href="#结合音标符" class="headerlink" title="结合音标符"></a>结合音标符</h3><p>发音符号是加到字母上的一个”glyph(字形)”。</p><p>一些变音符号, 如 尖音符 (  ̀) 和 抑音符 (  ́) 。</p><p>变音符号可以出现字母的上面和下面，或者字母里面，或者两个字母间。</p><p>变音符号可以与字母、数字字符的组合来使用。</p><p><img src="https://gcdnb.pbrd.co/images/HIYbJi1xLlBg.png?o=1"></p><h3 id="常见字符实体"><a href="#常见字符实体" class="headerlink" title="常见字符实体"></a>常见字符实体</h3><p><img src="https://gcdnb.pbrd.co/images/gGnFPQniCaXS.png?o=1"></p><h2 id="HTML-URL"><a href="#HTML-URL" class="headerlink" title="HTML URL"></a>HTML URL</h2><p>统一资源定位器(Uniform Resource Locators)是一个网页地址。</p><p>URL可以由字母组成，如”runoob.com”，或互联网协议（IP）地址： 192.68.20.50。</p><h3 id="URL-统一资源定位器"><a href="#URL-统一资源定位器" class="headerlink" title="URL - 统一资源定位器"></a>URL - 统一资源定位器</h3><p>Web浏览器通过URL从Web服务器请求页面。</p><p>当您点击 HTML 页面中的某个链接时，对应的 <a> 标签指向万维网上的一个地址。</a></p><a><p>一个统一资源定位器(URL) 用于定位万维网上的文档。</p></a><p><a>一个网页地址实例: </a><a href="http://www.runoob.com/html/html-tutorial.html">http://www.runoob.com/html/html-tutorial.html</a> 语法规则:</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://host.domain:port/path/filename</span><br></pre></td></tr></tbody></table></figure><ul><li>scheme - 定义因特网服务的类型。最常见的类型是 http</li><li>host - 定义域主机（http 的默认主机是 www）</li><li>domain - 定义因特网域名，比如 runoob.com</li><li>:port - 定义主机上的端口号（http 的默认端口号是 80）</li><li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li>filename - 定义文档/资源的名称</li></ul><h3 id="常见的-URL-Scheme"><a href="#常见的-URL-Scheme" class="headerlink" title="常见的 URL Scheme"></a>常见的 URL Scheme</h3><p><img src="https://gcdnb.pbrd.co/images/DLL1NE0qPKVk.png?o=1"></p><h3 id="URL-字符编码"><a href="#URL-字符编码" class="headerlink" title="URL 字符编码"></a>URL 字符编码</h3><p>URL 只能使用 <a href="https://www.runoob.com/tags/html-ascii.html">ASCII 字符集</a>.</p><p>来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</p><p>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</p><p>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</p><h3 id="HTML-标签简写及全称"><a href="#HTML-标签简写及全称" class="headerlink" title="HTML 标签简写及全称"></a>HTML 标签简写及全称</h3><table class="reference"><tbody><tr><th>  标签</th>    <th>   英文全称</th>    <th>   中文说明</th>    </tr><tr><td>   a</td>    <td>   Anchor</td>    <td>   锚</td>    </tr><tr><td>   abbr</td>    <td>   Abbreviation</td>    <td>   缩写词</td>    </tr><tr><td>   acronym</td>    <td>   Acronym</td>    <td>   取首字母的缩写词</td>    </tr><tr><td>   address </td>    <td>   Address</td>    <td>   地址</td>    </tr><tr><td>   alt</td>    <td>   alter</td>    <td>   替用(一般是图片显示不出的提示)</td>    </tr><tr><td>   b</td>    <td>   Bold</td>    <td>   粗体（文本）</td>    </tr><tr><td>   bdo</td>    <td>  Bi-Directional Override</td>    <td>   文本显示方向</td>    </tr><tr><td>   big</td>    <td>   Big</td>    <td>   变大（文本）</td>    </tr><tr><td>   blockquote</td>    <td>   Block Quotation</td>    <td>   区块引用语</td>    </tr><tr><td>   br</td>    <td>   Break</td>    <td>   换行</td>    </tr><tr><td>   cell</td>    <td>   cell</td>    <td>   巢</td>    </tr><tr><td>   cellpadding</td>    <td>   cellpadding</td>    <td>   巢补白</td>    </tr><tr><td>   cellspacing</td>    <td>   cellspacing</td>    <td>   巢空间</td>    </tr><tr><td>   center</td>    <td>   Centered</td>    <td>   居中（文本）</td>    </tr><tr><td>   cite</td>    <td>   Citation</td>    <td>   引用</td>    </tr><tr><td>   code</td>    <td>   Code</td>    <td>   源代码（文本）</td>    </tr><tr><td>   dd</td>    <td>   Definition Description</td>    <td>   定义描述</td>    </tr><tr><td>   del</td>    <td>   Deleted</td>    <td>   删除（的文本）</td>    </tr><tr><td>   dfn</td>    <td>   Defines a Definition Term</td>    <td>   定义定义条目</td>    </tr><tr><td>   div</td>    <td>   Division</td>    <td>   分隔</td>    </tr><tr><td>   dl</td>    <td>   Definition List</td>    <td>   定义列表</td>    </tr><tr><td>   dt</td>    <td>   Definition Term</td>    <td>   定义术语</td>    </tr><tr><td>   em</td>    <td>   Emphasized</td>    <td>   加重（文本）</td>    </tr><tr><td>   font</td>    <td>   Font</td>    <td>   字体</td>    </tr><tr><td>   h1~h6</td>    <td>   Header 1 to Header 6</td>    <td>   标题1到标题6</td>    </tr><tr><td>   hr</td>    <td>   Horizontal Rule</td>    <td>   水平尺</td>    </tr><tr><td>   href</td>    <td>   hypertext reference</td>    <td>   超文本引用</td>    </tr><tr><td>   i</td>    <td>   Italic</td>    <td>   斜体（文本）</td>    </tr><tr><td>   iframe</td>    <td>   Inline frame</td>    <td>   定义内联框架</td>    </tr><tr><td>   ins</td>    <td>   Inserted</td>    <td>   插入（的文本）</td>    </tr><tr><td>   kbd</td>    <td>   Keyboard</td>    <td>   键盘（文本）</td>    </tr><tr><td>   li</td>    <td>   List Item</td>    <td>   列表项目</td>    </tr><tr><td>   nl</td>    <td>   navigation lists</td>    <td>   导航列表</td>    </tr><tr><td>   ol</td>    <td>   Ordered List</td>    <td>   排序列表</td>    </tr><tr><td>   optgroup</td>    <td>   Option group</td>    <td>   定义选项组</td>    </tr><tr><td>   p</td>    <td>   Paragraph</td>    <td>   段落</td>    </tr><tr><td>   pre</td>    <td>   Preformatted</td>    <td>   预定义格式（文本 ）</td>    </tr><tr><td>   q</td>    <td>   Quotation</td>    <td>   引用语</td>    </tr><tr><td>   rel</td>    <td>   Reload</td>    <td>   加载</td>    </tr><tr><td>   s/ strike</td>    <td>   Strikethrough</td>    <td>   删除线</td>    </tr><tr><td>   samp</td>    <td>   Sample</td>    <td>   示例（文本</td>    </tr><tr><td>   small</td>    <td>   Small</td>    <td>   变小（文本）</td>    </tr><tr><td>   span</td>    <td>   Span</td>    <td>   范围</td>    </tr><tr><td>   src</td>    <td>   Source</td>    <td>   源文件链接</td>    </tr><tr><td>   strong</td>    <td>   Strong</td>    <td>   加重（文本）</td>    </tr><tr><td>   sub</td>    <td>   Subscripted</td>    <td>   下标（文本）</td>    </tr><tr><td>   sup</td>    <td>   Superscripted</td>    <td>   上标（文本）</td>    </tr><tr><td>   td</td>    <td>   table data cell</td>    <td>   表格中的一个单元格</td>    </tr><tr><td>   th</td>    <td>   table header cell</td>    <td>   表格中的表头</td>    </tr><tr><td>   tr</td>    <td>   table row</td>    <td>   表格中的一行</td>    </tr><tr><td>   tt</td>    <td>   Teletype</td>    <td>   打印机（文本）</td>    </tr><tr><td>   u</td>    <td>   Underlined</td>    <td>   下划线（文本）</td>    </tr><tr><td>   ul</td>    <td>   Unordered List</td>    <td>   不排序列表</td>    </tr><tr><td>   var</td>    <td>   Variable</td>    <td>   变量（文本）<br><br></td>    </tr></tbody></table><h2 id="HTML-多媒体"><a href="#HTML-多媒体" class="headerlink" title="HTML 多媒体"></a>HTML 多媒体</h2><h3 id="什么是多媒体"><a href="#什么是多媒体" class="headerlink" title="什么是多媒体"></a>什么是多媒体</h3><p>可以是文字、图片、音乐、音效、录音、电影、动画等等。在因特网上，嵌入网页中的多媒体元素多见，现代浏览器已支持多种多媒体格式。</p><h3 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h3><table><thead><tr><th align="left">式</th><th align="left">文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">AVI</td><td align="left">.avi</td><td align="left">AVI (Audio Video Interleave) 格式是由微软开发的。所有运行 Windows 的计算机都支持 AVI 格式。它是因特网上很常见的格式，但非 Windows 计算机并不总是能够播放。</td></tr><tr><td align="left">WMV</td><td align="left">.wmv</td><td align="left">Windows Media 格式是由微软开发的。Windows Media 在因特网上很常见，但是如果未安装额外的（免费）组件，就无法播放 Windows Media 电影。一些后期的 Windows Media 电影在所有非 Windows 计算机上都无法播放，因为没有合适的播放器。</td></tr><tr><td align="left">MPEG</td><td align="left">.mpg.mpeg</td><td align="left">MPEG (Moving Pictures Expert Group) 格式是因特网上最流行的格式。它是跨平台的，得到了所有最流行的浏览器的支持。</td></tr><tr><td align="left">QuickTime</td><td align="left">.mov</td><td align="left">QuickTime 格式是由苹果公司开发的。QuickTime 是因特网上常见的格式，但是 QuickTime 电影不能在没有安装额外的（免费）组件的 Windows 计算机上播放。</td></tr><tr><td align="left">RealVideo</td><td align="left">.rm.ram</td><td align="left">RealVideo 格式是由 Real Media 针对因特网开发的。该格式允许低带宽条件下（在线视频、网络电视）的视频流。由于是低带宽优先的，质量常会降低。</td></tr><tr><td align="left">Flash</td><td align="left">.swf.flv</td><td align="left">Flash (Shockwave) 格式是由 Macromedia 开发的。Shockwave 格式需要额外的组件来播放。但是该组件会预装到 Firefox 或 IE 之类的浏览器上。</td></tr><tr><td align="left">Mpeg-4</td><td align="left">.mp4</td><td align="left">Mpeg-4 (with H.264 video compression) 是一种针对因特网的新格式。事实上，YouTube 推荐使用 MP4。YouTube 接收多种格式，然后全部转换为 .flv 或 .mp4 以供分发。越来越多的视频发布者转到 MP4，将其作为 Flash 播放器和 HTML5 的因特网共享格式。</td></tr></tbody></table><h3 id="音频格式"><a href="#音频格式" class="headerlink" title="音频格式"></a>音频格式</h3><table><thead><tr><th align="left">格式</th><th align="left">文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">MIDI</td><td align="left">.mid.midi</td><td align="left">MIDI (Musical Instrument Digital Interface) 是一种针对电子音乐设备（比如合成器和声卡）的格式。MIDI 文件不含有声音，但包含可被电子产品（比如声卡）播放的数字音乐指令。<a href="https://www.runoob.com/try/demo_source/beatles.mid">点击这里播放 The Beatles</a>。因为 MIDI 格式仅包含指令，所以 MIDI 文件极其小巧。上面的例子只有 23k 的大小，但却能播放将近 5 分钟。MIDI 得到了广泛的平台上的大量软件的支持。大多数流行的网络浏览器都支持 MIDI。</td></tr><tr><td align="left">RealAudio</td><td align="left">.rm.ram</td><td align="left">RealAudio 格式是由 Real Media 针对因特网开发的。该格式也支持视频。该格式允许低带宽条件下的音频流（在线音乐、网络音乐）。由于是低带宽优先的，质量常会降低。</td></tr><tr><td align="left">Wave</td><td align="left">.wav</td><td align="left">Wave (waveform) 格式是由 IBM 和微软开发的。所有运行 Windows 的计算机和所有网络浏览器（除了 Google Chrome）都支持它。</td></tr><tr><td align="left">WMA</td><td align="left">.wma</td><td align="left">WMA 格式 (Windows Media Audio)，质量优于 MP3，兼容大多数播放器，除了 iPod。WMA 文件可作为连续的数据流来传输，这使它对于网络电台或在线音乐很实用。</td></tr><tr><td align="left">MP3</td><td align="left">.mp3.mpga</td><td align="left">MP3 文件实际上是 MPEG 文件的声音部分。MPEG 格式最初是由运动图像专家组开发的。MP3 是其中最受欢迎的针对音乐</td></tr></tbody></table><h2 id="HTML-插件"><a href="#HTML-插件" class="headerlink" title="HTML 插件"></a>HTML 插件</h2><h3 id="什么是插件"><a href="#什么是插件" class="headerlink" title="什么是插件"></a>什么是插件</h3><p>辅助应用程序（helper application）是可由浏览器启动的程序。辅助应用程序也称为插件。</p><p>辅助程序可用于<strong>播放音频和视频</strong>（以及其他）。辅助程序是使用 &lt;object&gt; 标签来加载的。</p><p>使用辅助程序播放视频和音频的一个优势是，您能够允许用户来控制部分或全部播放设置。</p><p>插件可以通过 &lt;object&gt; 标签或者 &lt;embed&gt; 标签添加在页面中。 </p><p>大多数辅助应用程序允许对音量设置和播放功能（比如后退、暂停、停止和播放）的手工（或程序的）控制。</p><h3 id="元素-2"><a href="#元素-2" class="headerlink" title="<object> 元素"></a>&lt;object&gt; 元素</h3><p>&lt;object&gt; 元素定义了在 HTML 文档中嵌入的对象。</p><p>该标签用于插入对象 (例如在网页中嵌入 Java 小程序, PDF 阅读器, Flash 播放器) 。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">data</span>=<span class="string">"bookmark.swf"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元素-3"><a href="#元素-3" class="headerlink" title="<embed> 元素"></a>&lt;embed&gt; 元素</h3><p>所有主流浏览器都支持 &lt;embed&gt; 元素。</p><p>&lt;embed&gt; 元素表示一个 HTML Embed 对象 。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">src</span>=<span class="string">"bookmark.swf"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-音频"><a href="#HTML-音频" class="headerlink" title="HTML 音频"></a>HTML 音频</h2><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>浏览器插件是一种扩展浏览器标准功能的小型计算机程序。</p><p>插件可以使用 &lt;object&gt; 标签 或者 &lt;embed&gt; 标签添加在页面上. </p><p>这些标签定义资源（通常非 HTML 资源）的容器，根据类型，它们即会由浏览器显示，也会由外部插件显示。</p><ul><li><p>使用 &lt;embed&gt; 元素</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>&lt;embed&gt; 标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。</li><li>不同的浏览器对音频格式的支持也不同。</li><li>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。</li><li>如果用户的计算机未安装插件，无法播放音频。</li><li>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li></ul></li><li><p>使用 &lt;object&gt; 元素</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">data</span>=<span class="string">"horse.mp3"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>不同的浏览器对音频格式的支持也不同。</li><li>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。</li><li>如果用户的计算机未安装插件，无法播放音频。</li><li>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li></ul></li></ul><h3 id="使用-元素"><a href="#使用-元素" class="headerlink" title="使用<audio> 元素"></a>使用&lt;audio&gt; 元素</h3><p>使用 &lt;audio&gt; 标签来描述 MP3 文件（Internet Explorer、Chrome 以及 Safari 中是有效的）, 同样添加一个 OGG 类型文件(Firefox 和 Opera浏览器中有效)。</p><ul><li>&lt;audio&gt; 标签在 HTML 4 中是无效的。您的页面无法通过 HTML 4 验证。</li><li>必须把音频文件转换为不同的格式。</li><li>&lt;audio&gt; 元素在老式浏览器中不起作用。</li></ul><h3 id="最好的-HTML-解决方法"><a href="#最好的-HTML-解决方法" class="headerlink" title="最好的 HTML 解决方法"></a>最好的 HTML 解决方法</h3><p>HTML5 &lt;audio&gt; 元素会尝试以 mp3 或 ogg 来播放音频。如果失败，代码将回退尝试 &lt;embed&gt; 元素。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">&nbsp;</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line">&nbsp; <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">&nbsp;</span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">height</span>=<span class="string">"50"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>必须把音频转换为不同的格式。</li><li>&lt;embed&gt; 元素无法回退来显示错误消息。</li></ul><h3 id="使用超链接"><a href="#使用超链接" class="headerlink" title="使用超链接"></a>使用超链接</h3><p>如果网页包含指向媒体文件的超链接，大多数浏览器会使用”辅助应用程序”来播放文件。</p><p>以下代码片段显示指向 mp3 文件的链接。如果用户点击该链接，浏览器会启动”辅助应用程序”来播放该文件：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"horse.mp3"</span>&gt;</span>Play the sound<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HTML-视频"><a href="#HTML-视频" class="headerlink" title="HTML 视频"></a>HTML 视频</h2><h3 id="使用-标签"><a href="#使用-标签" class="headerlink" title="使用 <embed> 标签"></a>使用 &lt;embed&gt; 标签</h3><p>&lt;embed&gt; 标签的作用是在 HTML 页面中嵌入多媒体元素。</p><ul><li>HTML4 无法识别 &lt;embed&gt; 标签。</li><li>如果浏览器不支持 Flash，那么视频将无法播放</li><li>iPad 和 iPhone 不能显示 Flash 视频。</li><li>如果将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li></ul><h3 id="使用-标签-1"><a href="#使用-标签-1" class="headerlink" title="使用 <object> 标签"></a>使用 &lt;object&gt; 标签</h3><p>&lt;object&gt; 标签的作用是在 HTML 页面中嵌入多媒体元素。</p><ul><li>如果浏览器不支持 Flash，将无法播放视频。</li><li>iPad 和 iPhone 不能显示 Flash 视频。</li><li>如果将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</li></ul><h3 id="使用-元素-1"><a href="#使用-元素-1" class="headerlink" title="使用<video> 元素"></a>使用&lt;video&gt; 元素</h3><p>HTML5 &lt;video&gt; 标签定义了一个视频或者影片。</p><p>&lt;video&gt; 元素在所有现代浏览器中都支持。</p><ul><li>必须把视频转换为很多不同的格式。</li><li>&lt;video&gt; 元素在老式浏览器中无效。</li></ul><h3 id="使用超链接-1"><a href="#使用超链接-1" class="headerlink" title="使用超链接"></a>使用超链接</h3><p>如果网页包含指向媒体文件的超链接，大多数浏览器会使用”辅助应用程序”来播放文件。</p><p>以下代码片段显示指向 AVI 文件的链接。如果用户点击该链接，浏览器会启动”辅助应用程序”，比如 Windows Media Player 来播放这个 AVI 文件：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"intro.swf"</span>&gt;</span>Play a video file<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三件套 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核技术-CPU</title>
      <link href="/2023/11/08/linux-nei-he-ji-zhu-cpu-xiang-guan/"/>
      <url>/2023/11/08/linux-nei-he-ji-zhu-cpu-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="如何让Linux内核更好地服务应用程序？"><a href="#如何让Linux内核更好地服务应用程序？" class="headerlink" title="如何让Linux内核更好地服务应用程序？"></a>如何让Linux内核更好地服务应用程序？</h1><p>当发生TCP重传时，有人可以从<strong>tcpdump</strong>里面的信息看到是哪个TCP连接进行重传，然而高手们却可以通过这些信息看到为什么会发生重传。</p><p>四大类中的典型问题：<strong>Page Cache管理问题、内存泄漏问题、TCP重传问题、内核态CPU利用率飙高问题</strong>。</p><p>如何更好地利用Page Cache来减少无谓的I/O开销；</p><p>应用程序都是如何从系统中申请内存以及如何释放的；</p><p>TCP连接的建立、传输以及断开的过程。这个过程究竟会受哪些配置项的影响，如果配置不当会引起什么网络问题；</p><p>应用程序该如何高效地使用CPU，以及哪些情况下会导致CPU的使用很低效。</p><h1 id="CPU是如何执行任务的？"><a href="#CPU是如何执行任务的？" class="headerlink" title="CPU是如何执行任务的？"></a><strong>CPU是如何执行任务的？</strong></h1><h2 id="CPU读写数据"><a href="#CPU读写数据" class="headerlink" title="CPU读写数据"></a>CPU读写数据</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/a418fbfc23d96aeb4813f1db4cbyy17f.jpg" alt="CPU的架构图"></p><p>一个实体CPU通常会有两个逻辑线程，也就是上图中的Core 0和Core 1。</p><p>每个Core都有自己的L1 Cache，L1 Cache又分为dCache和iCache，对应到上图就是L1d和L1i。L1 Cache只有Core本身可以看到，其他的Core是看不到的。</p><p>同一个实体CPU中的这两个Core会共享L2 Cache，其他的实体CPU是看不到这个L2 Cache的。</p><p>所有的实体CPU会共享L3 Cache。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/ed552cedfb95d0a3af920eca78c3069f.jpg" alt="Cache伪共享"></p><ul><li>两个CPU上并行运行着两个不同线程，它们同时从内存中读取两个不同的数据，这两个数据的地址在物理内存上是连续的，它们位于同一个Cache Line中。CPU从内存中读数据到Cache是以Cache Line为单位的，所以该Cache Line里的数据被同时读入到了这两个CPU的各自Cache中。</li><li>紧接着这两个线程分别改写不同的数据，每次改写Cache中的数据都会将<strong>整个Cache Line置为无效</strong>。</li><li>因此，虽然这两个线程改写的数据不同，但是由于它们位于同一个Cache Line中，所以一个CPU中的线程在写数据时会导致另外一个CPU中的Cache Line失效，而<strong>另外一个CPU中的线程在读写数据时就会发生cache miss</strong>，然后去内存读数据，这就大大降低了性能。</li></ul><p>定义一个结构体，该结构体里的两个成员a和b在地址上是连续的。如果CPU 0去写a，同时CPU 1去读b的话，此时不会有竞争，因为a和b是不同的地址。不过，a和b由于在地址上是连续的，它们可能会位于同一个Cache Line中，所以为了防止前面提到的Cache伪共享问题，我们可以<strong>强制将b的地址设置为Cache Line对齐地址</strong>，如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b ____cacheline_aligned;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="CPU如何选择线程执行"><a href="#CPU如何选择线程执行" class="headerlink" title="CPU如何选择线程执行"></a>CPU如何选择线程执行</h2><p>每个CPU都会维护着自己运行队列（runqueue）里的线程：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/6649d7e5984a3b9cd003fcbc97bfde62.jpg" alt="CPU运行队列的结构"></p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/1507d0ef23d5d1cd33769dd1953cffb1.jpg" alt="调度类、调度策略、运行队列对应关系"></p><p><strong>调度类的优先级如下：Deadline &gt; Realtime &gt; Fair。</strong></p><p>不做任何设置的话，用户线程在默认情况下都是普通线程，也就是属于Fair调度类，由CFS调度器来进行管理。</p><p>如果某些任务对延迟容忍度很低，可以考虑将任务设置为<strong>实时任务</strong>，比如将它设置为SCHED_FIFO的任务：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">chrt -f -p 1 1327</span></span><br></pre></td></tr></tbody></table></figure><h1 id="业务是否需要使用透明大页？"><a href="#业务是否需要使用透明大页？" class="headerlink" title="业务是否需要使用透明大页？"></a><strong>业务是否需要使用透明大页？</strong></h1><h2 id="细化CPU利用率监控"><a href="#细化CPU利用率监控" class="headerlink" title="细化CPU利用率监控"></a>细化CPU利用率监控</h2><p>CPU利用率监控通常是去解析**/proc/stat文件**，常用的top命令来看看CPU更加细化的利用率指标：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s): 12.5 us, 0.0 sy, 0.0 ni, 87.4 <span class="built_in">id</span>, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span></span><br></pre></td></tr></tbody></table></figure><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/3756d973a1f7f350bf600c9438f1a4a5.jpg" alt="CPU各指标具体含义"></p><h2 id="抓取sys利用率飙高现场"><a href="#抓取sys利用率飙高现场" class="headerlink" title="抓取sys利用率飙高现场"></a>抓取sys利用率飙高现场</h2><p>CPU的sys利用率高，说明内核函数执行花费了太多的时间，所以我们需要采集CPU在sys飙高的瞬间所执行的内核函数。采集内核函数的方法有很多，比如：</p><ul><li>通过<strong>perf可以采集CPU的热点</strong>，看看sys利用率高时，哪些内核耗时的CPU利用率高；</li><li>通过<strong>perf的call-graph功能可以查看具体的调用栈信息</strong>，也就是线程是从什么路径上执行下来的；</li><li>通过<strong>perf的annotate功能可以追踪到线程是在内核函数的哪些语句上比较耗时</strong>；</li><li>通过<strong>ftrace的function-graph功能可以查看这些内核函数的具体耗时</strong>，以及在哪个路径上耗时最大。</li></ul><p><strong>这些方法更加适合采集一个时间段内的信息。</strong></p><p><strong>sysrq</strong>是经常用来分析内核问题的工具，用它可以观察当前的内存快照、任务快照，可以构造vmcore把系统的所有信息都保存下来，甚至还可以在内存紧张的时候用它杀掉内存开销最大的那个进程。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysctl -w kernel.sysrq = 1<span class="comment"># 将sysrq的所有功能都使能</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> t &gt; /proc/sysrq-trigger<span class="comment"># 把当前的任务快照保存下来</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">dmesg<span class="comment"># 通过dmesg命令来查看任务快照信息</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="透明大页：水可载舟，亦可覆舟"><a href="#透明大页：水可载舟，亦可覆舟" class="headerlink" title="透明大页：水可载舟，亦可覆舟"></a>透明大页：水可载舟，亦可覆舟</h2><p>在本案例中，从dmesg输出的信息中，发现处于R状态的线程都在进行compcation（内存规整）：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/db981eb703a88ae85458618355789251.jpg" alt="内存规整过程"></p><p>这个过程是很耗时的，该过程需要持有粗粒度的锁，所以在运行过程中线程还可能会主动检查（_cond_resched）是否有其他更高优先级的任务需要执行。如果有的话就会让其他线程先执行，这便进一步加剧了它的执行耗时。这也就是sys利用率飙高的原因。</p><p>THP就是透明大页，它是一个2M的连续物理内存。THP的目的是用一个页表项来映射更大的内存（大页），这样可以减少Page Fault，因为需要的页数少了。当然，这也会提升TLB命中率，因为需要的页表项也少了。如果进程要访问的数据都在这个大页中，那么这个大页就会很热，会被缓存在Cache中。而大页对应的页表项也会出现在TLB中，从上一讲的存储层次我们可以知道，这有助于性能提升。但是反过来，假设应用程序的数据局部性比较差，它在短时间内要访问的数据很随机地位于不同的大页上，那么大页的优势就会消失。</p><p>针对THP的使用的几点建议：</p><ul><li>不要将/sys/kernel/mm/transparent_hugepage/enabled配置为always，可以将它配置为madvise。如果不清楚该如何来配置，那就将它配置为never；</li><li>如果想要用THP优化业务，最好可以让业务以madvise的方式来使用大页，即通过修改业务代码来指定特定数据使用THP，因为业务更熟悉自己的数据流；</li><li>很多时候修改业务代码会很麻烦，如果不想修改业务代码的话，就去优化THP的内核代码吧。</li></ul><h1 id="网络吞吐高的业务是否需要开启网卡特性呢？"><a href="#网络吞吐高的业务是否需要开启网卡特性呢？" class="headerlink" title="网络吞吐高的业务是否需要开启网卡特性呢？"></a><strong>网络吞吐高的业务是否需要开启网卡特性呢？</strong></h1><h2 id="中断与业务进程之间是如何相互干扰的"><a href="#中断与业务进程之间是如何相互干扰的" class="headerlink" title="中断与业务进程之间是如何相互干扰的"></a>中断与业务进程之间是如何相互干扰的</h2><p>案例：为了提升QPS（Query per Second），开启了RPS（Receivce Packet Steering）来模拟网卡多队列，反而导致了QPS明显下降。</p><p>在业务打开RPS之前的性能指标：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ dstat </span><br><span class="line">You did <span class="keyword">not</span> <span class="keyword">select</span> any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---<span class="keyword">system</span>--</span><br><span class="line">usr sys idl wai hiq si<span class="string">q| read  writ|</span> <span class="keyword">recv</span>  <span class="keyword">send</span>|  in   out | <span class="keyword">int</span>   csw </span><br><span class="line"> <span class="number">64</span>  <span class="number">23</span>   <span class="number">6</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">7</span>|   <span class="number">0</span>  <span class="number">8192</span>B|<span class="number">7917</span>k   <span class="number">12</span>M|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">27</span>k <span class="number">1922</span> </span><br><span class="line"> <span class="number">64</span>  <span class="number">22</span>   <span class="number">6</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">8</span>|   <span class="number">0</span>     <span class="number">0</span> |<span class="number">7739</span>k   <span class="number">12</span>M|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">26</span>k <span class="number">2210</span> </span><br><span class="line"> <span class="number">61</span>  <span class="number">23</span>   <span class="number">9</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">7</span>|   <span class="number">0</span>     <span class="number">0</span> |<span class="number">7397</span>k   <span class="number">11</span>M|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">25</span>k <span class="number">2267</span> </span><br></pre></td></tr></tbody></table></figure><p>打开了RPS之后的性能指标：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ dstat </span><br><span class="line">You did <span class="keyword">not</span> <span class="keyword">select</span> any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---<span class="keyword">system</span>--</span><br><span class="line">usr sys idl wai hiq si<span class="string">q| read  writ|</span> <span class="keyword">recv</span>  <span class="keyword">send</span>|  in   out | <span class="keyword">int</span>   csw </span><br><span class="line"> <span class="number">62</span>  <span class="number">23</span>   <span class="number">4</span>   <span class="number">0</span>   <span class="number">0</span>  <span class="number">12</span>|   <span class="number">0</span>     <span class="number">0</span> |<span class="number">7096</span>k   <span class="number">11</span>M|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">49</span>k <span class="number">2261</span> </span><br><span class="line"> <span class="number">74</span>  <span class="number">13</span>   <span class="number">4</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">9</span>|   <span class="number">0</span>     <span class="number">0</span> |<span class="number">4003</span>k <span class="number">6543</span>k|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">31</span>k <span class="number">2004</span> </span><br><span class="line"> <span class="number">59</span>  <span class="number">22</span>   <span class="number">5</span>   <span class="number">0</span>   <span class="number">0</span>  <span class="number">13</span>|   <span class="number">0</span>  <span class="number">4096</span>B|<span class="number">6710</span>k   <span class="number">10</span>M|   <span class="number">0</span>     <span class="number">0</span> |  <span class="number">48</span>k <span class="number">2220</span> </span><br></pre></td></tr></tbody></table></figure><p>打开RPS后，CPU的利用率有所升高。其中，siq即软中断利用率明显增加，int即硬中断频率也明显升高，而net这一项里的网络吞吐数据则有所下降。在网络吞吐不升反降的情况下，系统的硬中断和软中断都明显增加。由此我们可以推断出，网络吞吐的下降应该是中断增加导致的结果。</p><p>通过**/proc/interruptes**这个文件来查看硬中断及其发生频率：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/interrupts</span> </span><br></pre></td></tr></tbody></table></figure><p>可以通过**/proc/softirq**来查看软中断：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/softirqs</span> </span><br></pre></td></tr></tbody></table></figure><p><strong>软中断是用来处理硬中断在短时间内无法完成的任务的。</strong>相比硬中断，软中断的执行时间会长一些，而且它也会抢占正在执行进程的CPU，从而导致进程在它运行期间只能等待。</p><p>可以通过如下两个tracepoints来进行观测：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/kernel/debug/tracing/events/irq/softirq_entry</span><br><span class="line">/sys/kernel/debug/tracing/events/irq/softirq_exit</span><br></pre></td></tr></tbody></table></figure><p>这两个tracepoint分别表示软中断的进入和退出，退出时间减去进入时间就是该软中断这一次的耗时。</p><p>同样可以使用bcc里的<a href="https://github.com/iovisor/bcc/blob/master/tools/softirqs.py"><strong>softirqs.py</strong></a>工具进行观测，它会统计软中断的次数和耗时。</p><p>为了避免软中断太过频繁，进程无法得到CPU而被饿死的情况，内核引入了<strong>ksoftirqd</strong>机制。如果所有的软中断在短时间内无法被处理完，内核会唤醒ksoftirqd处理接下来的软中断。ksoftirqd与普通进程的优先级一样，也就是说它会和普通进程公平地使用CPU。如果ksoftrirqd长时间得不到CPU，就会致使软中断的延迟变得很大，它引起的典型问题也是ping延迟。</p><h2 id="softirq是如何影响业务的"><a href="#softirq是如何影响业务的" class="headerlink" title="softirq是如何影响业务的"></a>softirq是如何影响业务的</h2><p>RPS是通过CAL（Function Call Interrupts）这种方式来让其他CPU去接收网络包的。</p><p><strong>RPS的作用：让网络收包软中断处理在各个CPU间更加均衡，以防止其在某个CPU上达到瓶颈。</strong></p><p>理论上，处理网络收包软中断的CPU变多，那么在单位时间内这些CPU应该可以处理更多的网络包，从而提升系统整体的吞吐。可是，在案例中，为什么会引起业务的QPS不升反降呢？</p><p><strong>可以看到在使能RPS之前，CPU利用率已经很高了，达到了90%以上，也就是说CPU已经在超负荷工作了。而打开RPS，RPS又会消耗额外的CPU时间来模拟网卡多队列特性，这就会导致CPU更加超负荷地工作，从而进一步挤压用户进程的处理时间。</strong></p><p>使用RPS的前提条件是：系统的整体CPU利用率不能太高。</p><h1 id="如何分析CPU利用率飙高问题-？"><a href="#如何分析CPU利用率飙高问题-？" class="headerlink" title="如何分析CPU利用率飙高问题 ？"></a><strong>如何分析CPU利用率飙高问题 ？</strong></h1><h2 id="如何拓展分析问题的边界"><a href="#如何拓展分析问题的边界" class="headerlink" title="如何拓展分析问题的边界"></a>如何拓展分析问题的边界</h2><p><strong>strace：</strong></p><p>可以用来分析应用和内核的“边界”——系统调用。strace可以跟踪进程的系统调用、特定的系统调用以及系统调用的执行时间。</p><p>比如想要跟踪一个多线程程序的系统调用情况，那就可以这样使用strace：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strace -T -tt -ff -p pid -o strace.out</span></span><br></pre></td></tr></tbody></table></figure><h2 id="了解工具的原理"><a href="#了解工具的原理" class="headerlink" title="了解工具的原理"></a>了解工具的原理</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/bc04236262f16e0b69842dafd503616f.jpg" alt="strace工具的原理"></p><p><strong>对于正在运行的进程而言，strace可以attach到目标进程上，这是通过ptrace这个系统调用实现的（gdb工具也是如此）：</strong></p><ul><li>ptrace的PTRACE_SYSCALL会去追踪目标进程的系统调用；</li><li>目标进程被追踪后，<strong>每次进入syscall，都会产生SIGTRAP信号并暂停执行</strong>；</li><li>追踪者通过目标进程触发的SIGTRAP信号，就可以知道目标进程进入了系统调用，然后追踪者会去处理该系统调用，用strace命令观察到的信息输出就是该处理的结果；</li><li>追踪者处理完该系统调用后，就会恢复目标进程的执行；</li><li>被恢复的目标进程会一直执行下去，直到下一个系统调用。</li></ul><h2 id="内核开发常用的分析工具"><a href="#内核开发常用的分析工具" class="headerlink" title="内核开发常用的分析工具"></a>内核开发常用的分析工具</h2><p><strong>两种途径可以方便地获取到系统调用对应的内核函数：</strong></p><ul><li><p>查看<a href="https://elixir.bootlin.com/linux/v5.9-rc6/source/include/linux/syscalls.h">include/linux/syscalls.h</a>文件里的内核函数：</p></li><li><p>通过/proc/kallsyms这个文件来查找：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/kallsyms | grep pread64- …- ffffffffa02ef3d0 T ksys_pread64- …</span></span><br></pre></td></tr></tbody></table></figure><p>/proc/kallsyms里的每一行都是一个符号，其中第一列是符号地址，第二列是符号的属性，第三列是符号名字，比如上面这个信息中的T就表示全局代码符号，可以追踪这类的符号。关于这些符号属性的含义，可以通过<a href="https://man7.org/linux/man-pages/man1/nm.1p.html">man nm</a>来查看。</p></li></ul><p><strong>ftrace：</strong></p><p>​可以使用ftrace的function_trace功能来追踪内核函数的耗时情况。function_graph的使用方式如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先设置要追踪的函数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> ksys_pread64 &gt; /sys/kernel/debug/tracing/set_graph_function</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其次设置要追踪的线程的pid，如果有多个线程，那需要将每个线程都逐个写入</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 6577 &gt; /sys/kernel/debug/tracing/set_ftrace_pid</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 6589 &gt;&gt; /sys/kernel/debug/tracing/set_ftrace_pid</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将function_graph设置为当前的tracer，来追踪函数调用情况</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> function_graph &gt; /sys/kernel/debug/tracing/current_trace</span></span><br></pre></td></tr></tbody></table></figure><p><strong>iostat：</strong></p><p>查看系统的磁盘I/O情况：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iostat -dxm 1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="自己写分析工具"><a href="#自己写分析工具" class="headerlink" title="自己写分析工具"></a>自己写分析工具</h2><p><strong>判断内存中都有哪些文件以及这些文件的大小：</strong></p><p>常规方式是用fincore和mincore，不过它们都比较低效。</p><p>更加高效的方式：通过<strong>写一个内核模块遍历inode来查看Page Cache的组成</strong>。伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iterate_supers <span class="comment">// 遍历super block</span></span><br><span class="line">  iterate_pagecache_sb <span class="comment">// 遍历superblock里的inode</span></span><br><span class="line">      <span class="built_in">list_for_each_entry</span>(inode, &amp;sb-&gt;s_inodes, i_sb_list)</span><br><span class="line">        <span class="comment">// 记录该inode的pagecache大小 </span></span><br><span class="line">        nrpages = inode-&gt;i_mapping-&gt;nrpages; </span><br><span class="line">        <span class="comment">/* 获取该inode对应的dentry，然后根据该dentry来查找文件路径；</span></span><br><span class="line"><span class="comment">         * 请注意inode可能没有对应的dentry，因为dentry可能被回收掉了，</span></span><br><span class="line"><span class="comment">         * 此时就无法查看该inode对应的文件名了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dentry = <span class="built_in">dentry_from_inode</span>(inode); </span><br><span class="line">        <span class="built_in">dentry_path_raw</span>(dentry, filename, PATH_MAX);</span><br></pre></td></tr></tbody></table></figure><p>这种方式不仅可以查看进程正在打开的文件，也能查看文件已经被进程关闭，但文件内容还在内存中的情况。</p><h1 id="如何使用tracepoint来分析内核Bug的？"><a href="#如何使用tracepoint来分析内核Bug的？" class="headerlink" title="如何使用tracepoint来分析内核Bug的？"></a><strong>如何使用tracepoint来分析内核Bug的？</strong></h1><h2 id="内存申请在慢速路径上为什么会失败"><a href="#内存申请在慢速路径上为什么会失败" class="headerlink" title="内存申请在慢速路径上为什么会失败"></a>内存申请在慢速路径上为什么会失败</h2><p>在内存分配慢速路径里失败，原因可以分为以下三种情况：</p><ul><li>特殊的GFP flags导致；</li><li>进程自身的状态；</li><li>reclaim和compact无法满足需求。</li></ul><h2 id="使用tracepoint分析生产环境"><a href="#使用tracepoint分析生产环境" class="headerlink" title="使用tracepoint分析生产环境"></a>使用tracepoint分析生产环境</h2><p>tracepoint是一种性能开销比较小的追踪手段，在生产环境上使用它，不会给业务带来明显的性能影响。</p><p>以function tracer为例来追踪direct compact：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; /sys/kernel/debug/tracing/current_tracer</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> __alloc_pages_direct_compact &gt; /sys/kernel/debug/tracing/set_ftrace_filter</span></span><br></pre></td></tr></tbody></table></figure><p>这样，当发生direct compact时，在trace_pipe中就会有相应的信息输出。</p><p>可以借助direct reclaim的tracepoint来查看direct claim能否成功回收内存：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_direct_reclaim_begin/enable</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_direct_reclaim_end/enable</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核技术-TCP连接相关</title>
      <link href="/2023/10/31/linux-nei-he-ji-zhu-tcp-lian-jie-xiang-guan/"/>
      <url>/2023/10/31/linux-nei-he-ji-zhu-tcp-lian-jie-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="如何让Linux内核更好地服务应用程序？"><a href="#如何让Linux内核更好地服务应用程序？" class="headerlink" title="如何让Linux内核更好地服务应用程序？"></a>如何让Linux内核更好地服务应用程序？</h1><p>当发生TCP重传时，有人可以从<strong>tcpdump</strong>里面的信息看到是哪个TCP连接进行重传，然而高手们却可以通过这些信息看到为什么会发生重传。</p><p>四大类中的典型问题：<strong>Page Cache管理问题、内存泄漏问题、TCP重传问题、内核态CPU利用率飙高问题</strong>。</p><p>如何更好地利用Page Cache来减少无谓的I/O开销；</p><p>应用程序都是如何从系统中申请内存以及如何释放的；</p><p>TCP连接的建立、传输以及断开的过程。这个过程究竟会受哪些配置项的影响，如果配置不当会引起什么网络问题；</p><p>应用程序该如何高效地使用CPU，以及哪些情况下会导致CPU的使用很低效。</p><h1 id="TCP连接的建立和断开受哪些系统配置影响？"><a href="#TCP连接的建立和断开受哪些系统配置影响？" class="headerlink" title="TCP连接的建立和断开受哪些系统配置影响？"></a><strong>TCP连接的建立和断开受哪些系统配置影响？</strong></h1><h2 id="TCP连接的建立过程会受哪些配置项的影响"><a href="#TCP连接的建立过程会受哪些配置项的影响" class="headerlink" title="TCP连接的建立过程会受哪些配置项的影响"></a>TCP连接的建立过程会受哪些配置项的影响</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/afc841ee3822fyye3ec186b28ee93744.jpg"></p><p>TCP连接的建立是一个从Client侧调用connect()，到Server侧accept()成功返回的过程。</p><p><strong>tcp_syn_retries：</strong></p><p>第一次握手SYN包重传的最大次数，默认值是6，会在（1 + 2 + 4 + 8 + 16+ 32 + 64）秒，即127秒后产生ETIMEOUT的错误；</p><p><strong>tcp_max_syn_backlog：</strong></p><p>半连接队列（syn queue）最大长度，当系统中积压的半连接个数超过了该值后，新的SYN包就会被丢弃；</p><p><strong>SYN Flood攻击：</strong></p><p>Client高频地向Server发SYN包，并且这个SYN包的源IP地址不停地变换，那么Server每次接收到一个新的SYN后，都会给它分配一个半连接，Server的SYNACK根据之前的SYN包找到的是错误的Client IP， 所以也就无法收到Client的ACK包，导致无法正确建立TCP连接，这就会让Server的半连接队列耗尽，无法响应正常的SYN包；</p><p><strong>tcp_syncookies：</strong></p><p>等于1即开启SYN Cookies，用于防范SYN Flood攻击；在Server收到SYN包时，不去分配资源来保存Client的信息，而是根据这个SYN包计算出一个Cookie值，然后将Cookie记录到SYNACK包中发送出去。对于正常的连接，该Cookies值会随着Client的ACK报文被带回来。然后Server再根据这个Cookie检查这个ACK包的合法性，如果合法，才去创建新的TCP连接。</p><p><strong>tcp_synack_retries：</strong></p><p>第二次握手SYNACK包重传的最大次数，默认值是5；</p><p><strong>net.core.somaxconn：</strong></p><p>全连接队列（accept queue）的长度是由listen(sockfd, backlog)这个函数里的backlog控制的，而该backlog的最大值则是somaxconn。somaxconn在5.4之前的内核中，默认都是128（5.4开始调整为了默认4096）。</p><p><strong>tcp_abort_on_overflow：</strong></p><p>当服务器中积压的全连接个数超过该值后，新的全连接就会被丢弃掉。Server在将新连接丢弃时，是否需要给Client发送reset，是由这个配置项来控制的，该值默认为0，即不发送reset给Client。</p><h2 id="TCP连接的断开过程会受哪些配置项的影响"><a href="#TCP连接的断开过程会受哪些配置项的影响" class="headerlink" title="TCP连接的断开过程会受哪些配置项的影响"></a>TCP连接的断开过程会受哪些配置项的影响</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/1cf68d3eb4f07113ba13d84124f447cf.jpg"></p><p><strong>tcp_fin_timeout：</strong></p><p>防止Client长期处于FIN_WAIT_2状态产生资源开销，设置了这个状态的超时时间，默认为60s，超过这个时间后就会自动销毁该连接；</p><p><strong>tcp_max_tw_buckets：</strong></p><p>限制TIME_WAIT状态的最大个数；</p><p><strong>tcp_tw_reuse：</strong></p><p>防止快速重启应用程序时，出现端口被占用而无法创建新连接的情况，可以打开复用TIME_WAIT；</p><p><strong>tcp_tw_recycle：</strong></p><p>来控制TIME_WAIT状态，该选项很危险，因为它可能会引起意料不到的问题，比如可能会引起NAT环境下的丢包问题，新版本的内核删掉了这个配置选项。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/3d60be2523528f511dec0fbc88ce1ede.jpg"></p><h1 id="TCP收发包过程会受哪些配置项影响？"><a href="#TCP收发包过程会受哪些配置项影响？" class="headerlink" title="TCP收发包过程会受哪些配置项影响？"></a><strong>TCP收发包过程会受哪些配置项影响？</strong></h1><h2 id="TCP数据包的发送过程会受什么影响"><a href="#TCP数据包的发送过程会受什么影响" class="headerlink" title="TCP数据包的发送过程会受什么影响"></a>TCP数据包的发送过程会受什么影响</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/5ce5d202b7a179829f4c9b3863b0b15e.jpg" alt="TCP数据包的发送过程"></p><h3 id="TCP层相关配置项"><a href="#TCP层相关配置项" class="headerlink" title="TCP层相关配置项"></a>TCP层相关配置项</h3><p><strong>tcp_wmem：</strong></p><p>单个TCP发送缓冲区的大小</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_wmem = <span class="number">8192</span> <span class="number">65536</span> <span class="number">16777216</span></span><br></pre></td></tr></tbody></table></figure><p>三个数字的含义分别为min、default、max。TCP发送缓冲区的大小会在min和max之间动态调整，初始的大小是default，这个动态调整的过程是由内核自动来做的，应用程序无法干预。<strong>自动调整的目的，是为了在尽可能少的浪费内存的情况下来满足发包的需要；</strong></p><p><strong>wmem_max：</strong></p><p>tcp_wmem中的max不能超过net.core.wmem_max这个配置项的值，如果超过了，TCP 发送缓冲区最大就是net.core.wmem_max；</p><p><strong>setsockopt(2)里的SO_SNDBUF：</strong></p><p>应用程序如果明确地知道自己发送多大的数据，需要多大的TCP发送缓冲区，可以设置固定的缓冲区大小，tcp_wmem会失效；最大值不能超过net.core.wmem_max，超过了该值，内核会把它强制设置为net.core.wmem_max；</p><p><strong>tcp_mem：</strong></p><p>所有TCP连接消耗的总内存限制</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_mem = <span class="number">8388608</span> <span class="number">12582912</span> <span class="number">16777216</span></span><br></pre></td></tr></tbody></table></figure><p>当所有TCP连接消耗的内存总和达到max后，也会因达到限制而无法再往外发包。</p><p><strong>tcp_wmem以及wmem_max的大小设置都是针对单个TCP连接的，这两个值的单位都是Byte（字节）。</strong></p><p><strong>tcp_mem选项中这些值的单位是Page（页数）。</strong></p><h3 id="IP层相关配置项"><a href="#IP层相关配置项" class="headerlink" title="IP层相关配置项"></a>IP层相关配置项</h3><p><strong>ip_local_port_range：</strong></p><p>和其他服务器建立IP连接时本地端口（local port）的范围</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range = <span class="number">1024</span> <span class="number">65535</span></span><br></pre></td></tr></tbody></table></figure><p>默认的端口范围太小以致于无法创建新连接。所以通常情况下都会扩大默认的端口范围。</p><p><strong>txqueuelen：</strong></p><p>Linux内核在IP层实现了qdisc（排队规则）实现流控；</p><p>qdisc的队列长度，太小会导致数据包被丢弃；</p><p><strong>default_qdisc：</strong></p><p>Linux系统默认的qdisc为pfifo_fast（先进先出），通常情况下我们无需调整它。如果你想使用<a href="https://github.com/google/bbr">TCP BBR</a>来改善TCP拥塞控制的话，那就需要将它调整为fq（fair queue, 公平队列）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br></pre></td></tr></tbody></table></figure><h2 id="TCP数据包的接收过程会受什么影响"><a href="#TCP数据包的接收过程会受什么影响" class="headerlink" title="TCP数据包的接收过程会受什么影响"></a>TCP数据包的接收过程会受什么影响</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/9ca34a53abf57125334e0278edd10356.jpg" alt="TCP数据包的接收过程"></p><p><strong>netdev_budget：</strong></p><p>在高性能网络场景下，数据包的数量会非常大，如果每来一个数据包都要产生一个中断，那CPU的处理效率就会大打折扣，所以就产生了NAPI（New API）这种机制让CPU一次性地去轮询（poll）多个数据包，以批量处理的方式来提升效率，降低网卡中断带来的性能开销。</p><p>一次可以poll多少个可以通过该选项来控制，默认值是300。</p><p><strong>tcp_rmem：</strong></p><p>TCP接收缓冲区的大小；</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_rmem = <span class="number">8192</span> <span class="number">87380</span> <span class="number">16777216</span></span><br></pre></td></tr></tbody></table></figure><p>TCP接收缓冲区大小也是在min和max之间动态调整 ，不过跟发送缓冲区不同的是，这个动态调整是可以通过控制选项来关闭的，这个选项是tcp_moderate_rcvbuf 。</p><p><strong>setsockopt()中的SO_RCVBUF：</strong></p><p>如果应用程序设置了SO_RCVBUF这个标记，那么TCP接收缓冲区的动态调整就是关闭，即使tcp_moderate_rcvbuf为1，接收缓冲区的大小始终就为设置的SO_RCVBUF这个值。</p><p><strong>rmem_max：</strong></p><p>SO_RCVBUF设置的值最大也不能超过net.core.rmem_max。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/8d4ba95a95684004f271677f600cda9b.jpg"></p><h1 id="TCP拥塞控制是如何导致业务性能抖动的？"><a href="#TCP拥塞控制是如何导致业务性能抖动的？" class="headerlink" title="TCP拥塞控制是如何导致业务性能抖动的？"></a><strong>TCP拥塞控制是如何导致业务性能抖动的？</strong></h1><h2 id="TCP拥塞控制是如何对业务网络性能产生影响"><a href="#TCP拥塞控制是如何对业务网络性能产生影响" class="headerlink" title="TCP拥塞控制是如何对业务网络性能产生影响"></a>TCP拥塞控制是如何对业务网络性能产生影响</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/5c4504d70ce3abc939yyca54780dd43c.jpg"></p><h3 id="1-慢启动"><a href="#1-慢启动" class="headerlink" title="1. 慢启动"></a>1. 慢启动</h3><p>每经过一个RTT（round-trip time），发包数量就会翻倍。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/0534ce8d1e3a09a1def9c27e387eb64d.jpg"></p><p>在慢启动阶段，当拥塞窗口（cwnd）增大到一个阈值（ ssthresh，慢启动阈值）后，TCP拥塞控制就进入了下一个阶段：拥塞避免（Congestion Avoidance）。</p><h3 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2.拥塞避免"></a>2.拥塞避免</h3><p>cwnd不再成倍增加，而是一个RTT增加1，由于网络链路的复杂性，甚至会出现乱序（Out of Order）报文。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/0c2ce093d74a1dc76f39b7cbdd386699.jpg" alt="乱序报文产生的原因"></p><p>发送端一次性发送了4个TCP segments，但是第2个segment在传输过程中被丢弃掉了，那么接收方就接收不到该segment了。然而第3个TCP segment和第4个TCP segment能够被接收到，此时<strong>3和4就属于乱序报文</strong>，它们会被加入到接收端的ofo queue（乱序队列）里。</p><p>因为接收端没有接收到第2个segment，因此接收端每次收到一个新的segment后都会去ack第2个segment，即ack 17。紧接着，发送端就会接收到三个相同的ack（ack 17）。连续出现了3个响应的ack后，发送端会据此判断数据包出现了丢失，于是就进入了下一个阶段：快速重传。</p><h3 id="3-快速重传和快速恢复"><a href="#3-快速重传和快速恢复" class="headerlink" title="3.快速重传和快速恢复"></a>3.快速重传和快速恢复</h3><p>它们是为了应对丢包这种行为而做的优化，在这种情况下，由于网络并没有出现拥塞，所以拥塞窗口不必恢复到初始值。判断丢包的依据就是<strong>收到3个相同的ack</strong>。</p><p>除了快速重传外，还有一种重传机制是超时重传。不过，这是非常糟糕的一种情况。如果发送出去一个数据包，超过一段时间（RTO）都收不到它的ack，那就认为是网络出现了拥塞。这个时候就需要将cwnd恢复为初始值，再次从慢启动开始调整cwnd的大小。</p><p>总体来说，拥塞控制就是根据TCP的数据传输状况来灵活地调整拥塞窗口，从而控制发送方发送数据包的行为。换句话说，拥塞窗口的大小可以表示网络传输链路的拥塞情况。TCP连接cwnd的大小可以通过ss这个命令来查看：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ss -nipt</span><br><span class="line">State       Recv-Q Send-Q                        Local Address:Port                                       Peer Address:Port         </span><br><span class="line">ESTAB       <span class="number">0</span>      <span class="number">36</span>                             <span class="number">172.23</span><span class="number">.245</span><span class="number">.7</span>:<span class="number">22</span>                                        <span class="number">172.30</span><span class="number">.16</span><span class="number">.162</span>:<span class="number">60490</span>      </span><br><span class="line">users:((<span class="string">"sshd"</span>,pid=<span class="number">19256</span>,fd=<span class="number">3</span>))</span><br><span class="line"> cubic wscale:<span class="number">5</span>,<span class="number">7</span> rto:<span class="number">272</span> rtt:<span class="number">71.53</span>/<span class="number">1.068</span> ato:<span class="number">40</span> mss:<span class="number">1248</span> rcvmss:<span class="number">1248</span> advmss:<span class="number">1448</span> cwnd:<span class="number">10</span> bytes_acked:<span class="number">19591</span> bytes_received:<span class="number">2817</span> segs_out:<span class="number">64</span> segs_in:<span class="number">80</span> data_segs_out:<span class="number">57</span> data_segs_in:<span class="number">28</span> send <span class="number">1.4</span>Mbps lastsnd:<span class="number">6</span> lastrcv:<span class="number">6</span> lastack:<span class="number">6</span> pacing_rate <span class="number">2.8</span>Mbps delivery_rate <span class="number">1.5</span>Mbps app_limited busy:<span class="number">2016</span>ms unacked:<span class="number">1</span> rcv_space:<span class="number">14600</span> minrtt:<span class="number">69.402</span></span><br></pre></td></tr></tbody></table></figure><p>通过该命令，我们可以发现这个TCP连接的cwnd为10。</p><p>如果你想要追踪拥塞窗口的实时变化信息，还有另外一个更好的办法：通过tcp_probe这个tracepoint来追踪：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/kernel/debug/tracing/events/tcp/tcp_probe</span><br></pre></td></tr></tbody></table></figure><h2 id="接收方是如何影响发送方发送数据的"><a href="#接收方是如何影响发送方发送数据的" class="headerlink" title="接收方是如何影响发送方发送数据的"></a>接收方是如何影响发送方发送数据的</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/e920b93740d9677c5419dee332086827.jpg"></p><p>接收方在收到数据包后，会给发送方回一个ack，然后把自己的rwnd大小写入到TCP头部的win这个字段，这样发送方就能根据这个字段来知道接收方的rwnd了。接下来，发送方在发送下一个TCP segment的时候，会先对比发送方的cwnd和接收方的rwnd，得出这<strong>二者之间的较小值</strong>，然后控制发送的TCP segment个数不能超过这个较小值。</p><h1 id="TCP端到端时延变大，怎样判断是哪里出现了问题？"><a href="#TCP端到端时延变大，怎样判断是哪里出现了问题？" class="headerlink" title="TCP端到端时延变大，怎样判断是哪里出现了问题？"></a><strong>TCP端到端时延变大，怎样判断是哪里出现了问题？</strong></h1><h2 id="如何分析C-S架构中的网络抖动问题"><a href="#如何分析C-S架构中的网络抖动问题" class="headerlink" title="如何分析C/S架构中的网络抖动问题"></a>如何分析C/S架构中的网络抖动问题</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/bf1cd8873fff3a7528f194658753e837.jpg" alt="典型的C/S架构"></p><p>以MySQL为例来进行具体讲解。</p><p><strong>TCP流是很难和应用数据关联起来的。这就是用tcpdump分析业务请求和响应的难点。</strong></p><p>好办法还是需要和应用协议关联起来，不过我们可以把这些应用协议做一层抽象，从而可以更简单地来解析它们，甚至无需解析。对于MySQL而言呢，**工具<a href="https://www.percona.com/blog/2010/08/31/introducing-tcprstat-a-tcp-response-time-tool/">tcprstat**</a>就是来做这件事的。</p><p>tcprstat的大致原理是利用MySQL的request-response特征来简化对协议内容的处理。tcprstat就可以以数据包到达MySQL Server侧作为起始时间点，以MySQL将最后一个数据包发出去作为结束时间点，然后这二者的时间差就是RT（Response Time）。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/62666eab402a7d4ed9eb41ae8a2581d6.jpg"></p><p>tcprstat性能开销略大，特别是在TCP连接数较多的情况下，它的CPU利用率甚至能够超过10%，这难以满足我们生产环境中长时间运行的需要。</p><h2 id="如何轻量级地判断抖动发生在哪里"><a href="#如何轻量级地判断抖动发生在哪里" class="headerlink" title="如何轻量级地判断抖动发生在哪里"></a>如何轻量级地判断抖动发生在哪里</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/0e6bf3f396e9c89f8a35376075d8c5ff.jpg" alt="基于systemtap实现的追踪框架"></p><p>追踪每一个TCP流，TCP流对应到内核里的实现就是一个struct sock实例，然后记录TCP流经过A/B/C/D这四个点的时刻，依据这几个时间点，我们就可以得到下面的结论：</p><ul><li>如果C-B的时间差较大，那就说明Server侧有抖动，否则是Client或网络的问题；</li><li>如果D-A的时间差较小，那就说明是Client侧问题，否则是Server或者网络的问题。</li></ul><h2 id="虚拟机场景下该如何判断抖动是发生在宿主机上还是虚拟机里"><a href="#虚拟机场景下该如何判断抖动是发生在宿主机上还是虚拟机里" class="headerlink" title="虚拟机场景下该如何判断抖动是发生在宿主机上还是虚拟机里"></a>虚拟机场景下该如何判断抖动是发生在宿主机上还是虚拟机里</h2><p>进一步扩展，再增加新的hook点，去记录TCP流经过虚拟机的时间点。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/27e5240900409a0848842f73704d3bc1.jpg"></p><p>可以根据F和E的时间差来判断抖动是否发生在虚拟机内部。</p><h1 id="如何高效地分析TCP重传问题？"><a href="#如何高效地分析TCP重传问题？" class="headerlink" title="如何高效地分析TCP重传问题？"></a><strong>如何高效地分析TCP重传问题？</strong></h1><h2 id="什么是TCP重传"><a href="#什么是TCP重传" class="headerlink" title="什么是TCP重传"></a>什么是TCP重传</h2><p>TCP重传率是通过解析/proc/net/snmp这个文件里的指标计算出来的：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/d5be65df068c3a2c4d181f492791efe7.jpg"></p><p>TCP重传率的计算公式如下：</p><p><strong>retrans = (RetransSegs－last RetransSegs) ／ (OutSegs－last OutSegs) * 100</strong></p><p><strong>单位时间内TCP重传包的数量除以TCP总的发包数量，就是TCP重传率。</strong></p><p>OutSegs和RetransSegs的含义：每发出去一个TCP包（包括重传包），OutSegs会相应地加1；每发出去一个重传包，RetransSegs会相应地加1。</p><p><strong>哪些情况会导致TCP重传：</strong></p><ul><li><strong>丢包</strong>- TCP数据包在网络传输过程中可能会被丢弃；接收端也可能会把该数据包给丢弃；接收端回的ACK也可能在网络传输过程中被丢弃；数据包在传输过程中发生错误而被接收端给丢弃……；</li><li><strong>拥塞</strong>- TCP数据包在网络传输过程中可能会在某个交换机/路由器上排队，比如臭名昭著的Bufferbloat（缓冲膨胀）；TCP数据包在网络传输过程中因为路由变化而产生的乱序；接收端回的ACK在某个交换机/路由器上排队……。</li></ul><h2 id="分析TCP重传的常规手段"><a href="#分析TCP重传的常规手段" class="headerlink" title="分析TCP重传的常规手段"></a>分析TCP重传的常规手段</h2><p>可以使用<strong>tcpdump</strong>把进出某个网卡的数据包给保存下来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -s 0 -i eth0 -w tcpdumpfile</span><br></pre></td></tr></tbody></table></figure><p>可以使用<strong>tshark</strong>（wireshark的Linux版本）来过滤出TCP重传包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tshark -r tcpdumpfile -R tcp.analysis.retransmission</span><br></pre></td></tr></tbody></table></figure><p>tcpdump很重，如果直接在生产环境上进行采集的话，难免会对业务造成性能影响。</p><h2 id="如何高效地分析TCP重传"><a href="#如何高效地分析TCP重传" class="headerlink" title="如何高效地分析TCP重传"></a>如何高效地分析TCP重传</h2><p>TCP重传也需要调用特定**内核函数tcp_retransmit_skb()**。</p><p>追踪内核函数最通用的方法是使用Kprobe，其原理如下：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/9f3f412208d8e17dd859a97b017228c8.jpg"></p><p>可以实现一个内核模块，该内核模块中使用Kprobe在tcp_retransmit_skb这个函数入口插入一个probe，然后注册一个break_handler，这样在执行到tcp_retransmit_skb时就会异常跳转到注册的break_handler中，然后在break_handler中解析TCP报文（skb）就可以了，从而来判断是什么在重传。</p><p>Kprobe这种方式使用起来还是略有些不便，为了让Linux用户更方便地观察TCP重传事件，4.16内核版本中专门添加了<a href="https://github.com/torvalds/linux/commit/e086101b150ae8e99e54ab26101ef3835fa9f48d"><strong>TCP tracepoint</strong></a>来解析TCP重传事件。</p><p>TCP重传，可以使用如下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /sys/kernel/debug/tracing/events/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 1 &gt; tcp/tcp_retransmit_skb/enable</span></span><br></pre></td></tr></tbody></table></figure><p>然后就可以追踪TCP重传事件了：</p><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat trace_pipe</span><br><span class="line">&lt;idle&gt;-<span class="number">0</span>     [<span class="number">007</span>] ..s. <span class="number">265119.290232</span>: <span class="symbol">tcp_retransmit_skb:</span> sport=<span class="number">22</span> dport=<span class="number">62264</span> saddr=<span class="number">172.23</span>.<span class="number">245.8</span> daddr=<span class="number">172.30</span>.<span class="number">18.225</span> saddrv6=<span class="symbol">:</span><span class="symbol">:ffff</span><span class="symbol">:</span><span class="number">172.23</span>.<span class="number">245.8</span> daddrv6=<span class="symbol">:</span><span class="symbol">:ffff</span><span class="symbol">:</span><span class="number">172.30</span>.<span class="number">18.225</span> state=<span class="variable constant_">TCP_ESTABLISHED</span></span><br></pre></td></tr></tbody></table></figure><p>追踪结束后呢，你需要将这个Tracepoint给关闭：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 0 &gt; tcp/tcp_retransmit_skb/enable</span></span><br></pre></td></tr></tbody></table></figure><h1 id="如何分析常见的TCP问题？"><a href="#如何分析常见的TCP问题？" class="headerlink" title="如何分析常见的TCP问题？"></a><strong>如何分析常见的TCP问题？</strong></h1><h2 id="在Linux上检查网络的常用工具"><a href="#在Linux上检查网络的常用工具" class="headerlink" title="在Linux上检查网络的常用工具"></a>在Linux上检查网络的常用工具</h2><p><strong>dstat：</strong></p><p>显示四类系统资源的整体使用情况和两个关键的系统指标。这四类系统资源分别是：CPU、磁盘I/O、 网络和内存。两个关键的系统指标是中断次数（int）和上下文切换次数（csw）。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/145508f238e794df5fbf84f200c7ce68.jpg"></p><p><strong>dstat -tcp：</strong></p><p>针对TCP，就可以使用dstat -tcp。它会统计并显示系统中所有的TCP连接状态，这些指标的含义如下：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/c91a94caf6f74b508bf3648e7e9197a4.jpg"></p><p><strong>ss：</strong></p><p>你可以查看到每个TCP连接都是什么样的：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ss -natp</span><br><span class="line">State         Recv-Q         Send-Q                                       Local Address:Port                     Peer Address:Port                                                                        </span><br><span class="line">LISTEN0      100                                  0.0.0.0:36457         0.0.0.0:*                                                                                <span class="built_in">users</span>:(("test",pid=<span class="number">11307</span>,fd=<span class="number">17</span>))                                       </span><br><span class="line">LISTEN0      5                                    0.0.0.0:33811         0.0.0.0:*                                                                                <span class="built_in">users</span>:(("test",pid=<span class="number">11307</span>,fd=<span class="number">19</span>))                                       </span><br><span class="line">ESTAB 0      0                                  127.0.0.1:57396       127.0.1.1:34751                                                                            <span class="built_in">users</span>:(("test",pid=<span class="number">11307</span>,fd=<span class="number">106</span>))                                      </span><br><span class="line">ESTAB 0      0                                  127.0.0.1:57384       127.0.1.1:34751                                                                            <span class="built_in">users</span>:(("test",pid=<span class="number">11307</span>,fd=<span class="number">100</span>))                                                                          </span><br></pre></td></tr></tbody></table></figure><p>如上所示，我们能查看到每个TCP连接的状态（State）、接收队列大小（Recv-Q）、发送队列大小（Send-Q）、本地IP和端口（Local Address:Port ）、远端IP和端口（Peer Address:Port）以及打开该TCP连接的进程信息。</p><p><strong>netstat：</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -natp</span><br></pre></td></tr></tbody></table></figure><p>netstat不仅比ss慢，而且开销也大。netstat是通过直接读取/proc/net/下面的文件来解析网络连接信息的；而ss使用的是netlink方式，这种方式的效率会高很多。</p><p><strong>netstat -s / nstat：</strong></p><p>查看系统的网络状态，比如说系统中是否存在丢包，以及是什么原因引起了丢包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nstat -z | grep -i drop</span><br><span class="line">TcpExtLockDroppedIcmps          0                  0.0</span><br><span class="line">TcpExtListenDrops               0                  0.0</span><br><span class="line">TcpExtTCPBacklogDrop            0                  0.0</span><br><span class="line">TcpExtPFMemallocDrop            0                  0.0</span><br><span class="line">TcpExtTCPMinTTLDrop             0                  0.0</span><br><span class="line">TcpExtTCPDeferAcceptDrop        0                  0.0</span><br><span class="line">TcpExtTCPReqQFullDrop           0                  0.0</span><br><span class="line">TcpExtTCPOFODrop                0                  0.0</span><br><span class="line">TcpExtTCPZeroWindowDrop         0                  0.0</span><br><span class="line">TcpExtTCPRcvQDrop               0                  0.0</span><br></pre></td></tr></tbody></table></figure><p>假如通过这些常规检查手段没有发现异常，那你就需要考虑使用网络分析的必备工具——tcpdump了。</p><h2 id="分析网络问题必须要掌握的工具：tcpdump"><a href="#分析网络问题必须要掌握的工具：tcpdump" class="headerlink" title="分析网络问题必须要掌握的工具：tcpdump"></a>分析网络问题必须要掌握的工具：tcpdump</h2><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/a2a0cdc510d8e77677ba957e0408cf27.jpg" alt="tcpdump原理"></p><p>在收发包时，如果该包符合tcpdump设置的规则（BPF filter），那么该网络包就会被拷贝一份到tcpdump的内核缓冲区，然后以PACKET_MMAP的方式将这部分内存映射到tcpdump用户空间，解析后就会把这些内容给输出了。</p><p>网卡以内的问题可以交给tcpdump来处理；对于网卡以外（包括网卡上）的问题，tcpdump可能就捉襟见肘了。</p><p>tcpdump的开销比较大，这主要在于BPF过滤器。</p><h2 id="TCP疑难问题的轻量级分析手段：TCP-Tracepoints"><a href="#TCP疑难问题的轻量级分析手段：TCP-Tracepoints" class="headerlink" title="TCP疑难问题的轻量级分析手段：TCP Tracepoints"></a>TCP疑难问题的轻量级分析手段：TCP Tracepoints</h2><p>常用的TCP Tracepoints路径位于/sys/kernel/debug/tracing/events/tcp/和/sys/kernel/debug/tracing/events/sock/，它们的作用如下表所示：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/e8b54452ccff8545441e4b5c655b7d12.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核技术-内存泄漏相关</title>
      <link href="/2023/10/27/linux-nei-he-ji-zhu-nei-cun-xie-lou-xiang-guan/"/>
      <url>/2023/10/27/linux-nei-he-ji-zhu-nei-cun-xie-lou-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="如何让Linux内核更好地服务应用程序？"><a href="#如何让Linux内核更好地服务应用程序？" class="headerlink" title="如何让Linux内核更好地服务应用程序？"></a>如何让Linux内核更好地服务应用程序？</h1><p>当发生TCP重传时，有人可以从<strong>tcpdump</strong>里面的信息看到是哪个TCP连接进行重传，然而高手们却可以通过这些信息看到为什么会发生重传。</p><p>四大类中的典型问题：<strong>Page Cache管理问题、内存泄漏问题、TCP重传问题、内核态CPU利用率飙高问题</strong>。</p><p>如何更好地利用Page Cache来减少无谓的I/O开销；</p><p>应用程序都是如何从系统中申请内存以及如何释放的；</p><p>TCP连接的建立、传输以及断开的过程。这个过程究竟会受哪些配置项的影响，如果配置不当会引起什么网络问题；</p><p>应用程序该如何高效地使用CPU，以及哪些情况下会导致CPU的使用很低效。</p><h1 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h1><h2 id="进程的哪些内存类型容易引起内存泄漏？"><a href="#进程的哪些内存类型容易引起内存泄漏？" class="headerlink" title="进程的哪些内存类型容易引起内存泄漏？"></a><strong>进程的哪些内存类型容易引起内存泄漏？</strong></h2><p>内存泄漏指的是内存被分配出去后一直没有被释放，导致这部分内存无法被再次使用，甚至更加严重的是，指向这块内存空间的指针都不存在了，进而再也无法访问这块内存空间。</p><h3 id="内存泄漏可能导致的问题"><a href="#内存泄漏可能导致的问题" class="headerlink" title="内存泄漏可能导致的问题"></a>内存泄漏可能导致的问题</h3><ul><li>伴随着服务器中的后台任务持续地运行，系统中可用内存越来越少；</li><li>应用程序正在运行时忽然被OOM kill掉了；</li><li>进程看起来没有消耗多少内存，但是系统内存就是不够用了；</li><li>……</li></ul><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/c321c56a7b719bf14b0b5133d0a66132.jpg"></p><h3 id="进程地址空间四种类型与易泄露类型"><a href="#进程地址空间四种类型与易泄露类型" class="headerlink" title="进程地址空间四种类型与易泄露类型"></a>进程地址空间四种类型与易泄露类型</h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/85e7da0e15587c6a1d31f7e60e1ab00f.jpg"></p><ul><li><strong>私有匿名内存</strong>。**进程的堆、栈，以及mmap(MAP_ANON | MAP_PRIVATE)**这种方式申请的内存都属于这种类型的内存。其中栈是由操作系统来进行管理的，应用程序无需关注它的申请和释放；堆和私有匿名映射则是由应用程序（程序员）来进行管理的，它们的申请和释放都是由应用程序来负责的，所以它们是容易产生内存泄漏的地方。</li><li><strong>共享匿名内存</strong>。进程通过**mmap(MAP_ANON | MAP_SHARED)**这种方式来申请的内存，比如说tmpfs和shm。这个类型的内存也是由应用程序来进行管理的，所以也可能会发生内存泄漏。</li><li><strong>私有文件映射</strong>。进程通过**mmap(MAP_FILE | MAP_PRIVATE)**这种方式来申请的内存，比如进程将共享库（Shared libraries）和可执行文件的代码段（Text Segment）映射到自己的地址空间就是通过这种方式。对于共享库和可执行文件的代码段的映射，这是通过操作系统来进行管理的，应用程序无需关注它们的申请和释放。而应用程序直接通过mmap(MAP_FILE | MAP_PRIVATE)来申请的内存则是需要应用程序自己来进行管理，这也是可能会发生内存泄漏的地方。</li><li><strong>共享文件映射</strong>。进程通过**mmap(MAP_FILE | MAP_SHARED)**这种方式来申请的内存，我们在上一个模块课程中讲到的File Page Cache就属于这类内存。这部分内存也需要应用程序来申请和释放，所以也存在内存泄漏的可能性。</li></ul><p><strong>即使进程只是调用malloc()或者mmap()而不去写这些地址，不去给它分配物理内存，也可能导致进程虚拟地址空间耗尽，即虚拟地址空间同样存在内存泄露的问题。</strong></p><h3 id="分页过程（虚拟内存到物理地址的映射）"><a href="#分页过程（虚拟内存到物理地址的映射）" class="headerlink" title="分页过程（虚拟内存到物理地址的映射）"></a><strong>分页过程（虚拟内存到物理地址的映射）</strong></h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/5e2dacf3890cd9d508d3e0181a8ac868.jpg"></p><p>Paging的大致过程是，CPU将要请求的虚拟地址传给MMU（Memory Management Unit，内存管理单元），然后MMU先在高速缓存TLB（Translation Lookaside Buffer，页表缓存）中查找转换关系，如果找到了相应的物理地址则直接访问；如果找不到则在地址转换表（Page Table）里查找计算。最终进程访问的虚拟地址就对应到了实际的物理地址。</p><p><strong>Linux上最典型的规划进程地址空间的方式就是通过ulimit，来规划进程最大的虚拟地址空间、物理地址空间、栈空间是多少等等。</strong></p><h3 id="用数据观察进程的内存"><a href="#用数据观察进程的内存" class="headerlink" title="用数据观察进程的内存"></a>用数据观察进程的内存</h3><p>常用来观察进程内存的工具，比如说pmap、ps、top等，都可以很好地来观察进程的内存。</p><p><strong>top</strong></p><p>可以使用top来观察系统所有进程的内存使用概况，打开top后，然后按g再输入3，进入内存模式。</p><p>在内存模式中，我们可以看到各个进程内存的%MEM、VIRT、RES、CODE、DATA、SHR、nMaj、nDRT</p><p>nMaj（Major Page Fault， 主缺页中断，指内容不在内存中然后从磁盘中来读取的页数），%MEM则是从RES计算而来的。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/a9615117becc0244a2a23802a9cf5c1d.jpg"></p><p>如果RES太高而SHR不高，那可能是堆内存泄漏；如果SHR很高，那可能是tmpfs/shm之类的数据在持续增长，如果VIRT很高而RES很小，那可能是进程不停地在申请内存，但是却没有对这些内存进行任何的读写操作，即虚拟地址空间存在内存泄漏。</p><p><strong>pmap</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$  pmap -x `pidof sshd`</span><br><span class="line"></span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping </span><br><span class="line"><span class="number">000055e798</span>e1d000     <span class="number">768</span>     <span class="number">652</span>       <span class="number">0</span> r-x-- sshd</span><br><span class="line"><span class="number">000055e7990</span>dc000      <span class="number">16</span>      <span class="number">16</span>      <span class="number">16</span> r---- sshd</span><br><span class="line"><span class="number">000055e7990</span>e0000       <span class="number">4</span>       <span class="number">4</span>       <span class="number">4</span> rw--- sshd</span><br><span class="line"><span class="number">000055e7990</span>e1000      <span class="number">40</span>      <span class="number">40</span>      <span class="number">40</span> rw---   [ anon ]</span><br><span class="line">...</span><br><span class="line"><span class="number">00007f</span>189613a000    <span class="number">1800</span>    <span class="number">1624</span>       <span class="number">0</span> r-x-- libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">00007f</span>18962fc000    <span class="number">2048</span>       <span class="number">0</span>       <span class="number">0</span> ----- libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">00007f</span>18964fc000      <span class="number">16</span>      <span class="number">16</span>      <span class="number">16</span> r---- libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">00007f</span>1896500000       <span class="number">8</span>       <span class="number">8</span>       <span class="number">8</span> rw--- libc<span class="number">-2.17</span>.so</span><br><span class="line">...</span><br><span class="line"><span class="number">00007f</span>fd9d30f000     <span class="number">132</span>      <span class="number">40</span>      <span class="number">40</span> rw---   [ stack ]</span><br></pre></td></tr></tbody></table></figure><p>每一行表示一种类型的内存（Virtual Memory Area），每一列的含义如下。</p><ul><li><strong>Mapping</strong>，用来表示文件映射中占用内存的文件，比如sshd这个可执行文件，或者堆[heap]，或者栈[stack]，或者其他，等等。</li><li><strong>Mode</strong>，它是该内存的权限，比如，“r-x”是可读可执行，它往往是代码段(Text Segment)；“rw-”是可读可写，这部分往往是数据段(Data Segment)；“r–”是只读，这往往是数据段中的只读部分。</li><li><strong>Address、Kbytes、RSS、Dirty</strong>，Address和Kbytes分别表示起始地址和虚拟内存的大小，RSS（Resident Set Size）则表示虚拟内存中已经分配的物理内存的大小，Dirty则表示内存中数据未同步到磁盘的字节数。</li></ul><p>如果地址空间中[heap]太大，那有可能是堆内存产生了泄漏；再比如说，如果进程地址空间包含太多的vma（可以把maps中的每一行理解为一个vma），那很可能是应用程序调用了很多mmap而没有munmap；再比如持续观察地址空间的变化，如果发现某些项在持续增长，那很可能是那里存在问题。</p><h2 id="如何预防内存泄漏导致的系统假死？"><a href="#如何预防内存泄漏导致的系统假死？" class="headerlink" title="如何预防内存泄漏导致的系统假死？"></a><strong>如何预防内存泄漏导致的系统假死？</strong></h2><h3 id="valgrind检测内存泄漏"><a href="#valgrind检测内存泄漏" class="headerlink" title="valgrind检测内存泄漏"></a>valgrind检测内存泄漏</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full  ./a.out </span><br><span class="line"></span><br><span class="line">==<span class="number">20146</span>== HEAP SUMMARY:</span><br><span class="line">==<span class="number">20146</span>==     in use at exit: <span class="number">1</span>,<span class="number">073</span>,<span class="number">741</span>,<span class="number">824</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">20146</span>==   total heap usage: <span class="number">1</span> allocs, <span class="number">0</span> frees, <span class="number">1</span>,<span class="number">073</span>,<span class="number">741</span>,<span class="number">824</span> bytes allocated</span><br><span class="line">==<span class="number">20146</span>== </span><br><span class="line">==<span class="number">20146</span>== <span class="number">1</span>,<span class="number">073</span>,<span class="number">741</span>,<span class="number">824</span> bytes in <span class="number">1</span> blocks are possibly lost in loss record <span class="number">1</span> of <span class="number">1</span></span><br><span class="line">==<span class="number">20146</span>==    at <span class="number">0x4C29F73</span>: <span class="built_in">malloc</span> (vg_replace_malloc.c:<span class="number">309</span>)</span><br><span class="line">==<span class="number">20146</span>==    by <span class="number">0x400543</span>: <span class="built_in">main</span> (in /home/yafang/test/mmleak/a.out)</span><br><span class="line">==<span class="number">20146</span>== </span><br><span class="line">==<span class="number">20146</span>== LEAK SUMMARY:</span><br><span class="line">==<span class="number">20146</span>==    definitely lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">20146</span>==    indirectly lost: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">20146</span>==      possibly lost: <span class="number">1</span>,<span class="number">073</span>,<span class="number">741</span>,<span class="number">824</span> bytes in <span class="number">1</span> blocks</span><br><span class="line">==<span class="number">20146</span>==    still reachable: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br><span class="line">==<span class="number">20146</span>==         suppressed: <span class="number">0</span> bytes in <span class="number">0</span> blocks</span><br></pre></td></tr></tbody></table></figure><h3 id="进程地址分配和销毁过程"><a href="#进程地址分配和销毁过程" class="headerlink" title="进程地址分配和销毁过程"></a>进程地址分配和销毁过程</h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/e0e227529ba7f2fcab1ab445c4634764.jpg"></p><p>进程在退出的时候，会把它建立的映射都给解除掉。换句话说，进程退出时，会把它申请的内存都给释放掉，那上面这个内存泄漏就是没危害的。</p><p>对于后台服务型的业务而言，基本上都是需要长时间运行的程序，所以后台服务的内存泄漏会给系统造成实际的危害。</p><h3 id="如何预防内存泄漏导致的危害？"><a href="#如何预防内存泄漏导致的危害？" class="headerlink" title="如何预防内存泄漏导致的危害？"></a>如何预防内存泄漏导致的危害？</h3><p>系统内存不足时会唤醒OOM killer来选择一个进程给杀掉，<strong>OOM killer选择进程是有策略的，它未必一定会杀掉正在内存泄漏的进程，很有可能是一个无辜的进程被杀掉。</strong></p><p><strong>案例：OOM日志打印导致多进程内存申请失败：</strong></p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/b39503a3fb39e731d2d4c51687db70a7.jpg"></p><p>OOM日志可以理解为是一个单生产者多消费者的模型。问题就出在console这里，如果console的速率很慢，输出太多日志会非常消耗时间。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/2c4e5452584e9a1525921dffbdfda4e7.jpg"></p><ul><li>进程A在申请内存失败后会触发OOM，在发生OOM的时候会打印很多很多日志，会选择一个合适的进程来杀掉，从而释放出来空闲的内存；</li><li>进程B同样也会触发OOM来尝试释放内存，而OOM这里又有一个全局锁（oom_lock）来进行保护，进程B尝试获取（trylock）这个锁的时候会失败，就只能再次重试；</li><li>如果此时系统中有很多进程都在申请内存，那么这些申请内存的进程都会被阻塞在这里，这就形成了一个恶性循环，甚至会引发系统长时间无响应（假死）。</li></ul><p><strong>解决方案：</strong></p><ul><li><strong>在发生OOM时尽可能少地打印信息</strong>，<strong>这并不是一个完美的方案，只是一个规避措施</strong>。</li><li><strong>调整串口打印级别，不将OOM信息打印到串口。</strong></li></ul><p>建议选择第二种，因为使用console的概率还是较少一些，所以第二种方案的影响也相对较小一些。</p><h2 id="进程没有消耗内存，内存哪去了？"><a href="#进程没有消耗内存，内存哪去了？" class="headerlink" title="进程没有消耗内存，内存哪去了？"></a><strong>进程没有消耗内存，内存哪去了？</strong></h2><p>磁盘的速度是远远低于内存的，有些应用程序为了提升性能，会避免将一些无需持续化存储的数据写入到磁盘，而是把这部分临时数据写入到内存中，然后定期或者在不需要这部分数据时，清理掉这部分内容来释放出内存。在这种需求下，就产生了一种特殊的Shmem：tmpfs。它是一种内存文件系统，只存在于内存中，它无需应用程序去申请和释放内存，而是操作系统自动来规划好一部分空间，应用程序只需要往这里面写入数据就可以了，这样会很方便。<strong>tmpfs中的文件一样不会体现在进程的内存占用上。</strong></p><p>除了tmpfs之外，其他一些类型的内存也不会体现在进程内存中，比如内核消耗的内存：**/proc/meminfo中的Slab（高速缓存）、KernelStack（内核栈）和VmallocUsed（内核通过vmalloc申请的内存）。**</p><h3 id="OOM杀进程的危害"><a href="#OOM杀进程的危害" class="headerlink" title="OOM杀进程的危害"></a>OOM杀进程的危害</h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/150863953f090f09179e87814322a5ee.jpg"></p><p>如果你的进程无论如何都不能被杀掉，那你可以将oom_score_adj配置为-1000。</p><h2 id="如何对内核内存泄漏做些基础的分析？"><a href="#如何对内核内存泄漏做些基础的分析？" class="headerlink" title="如何对内核内存泄漏做些基础的分析？"></a><strong>如何对内核内存泄漏做些基础的分析？</strong></h2><h3 id="内核内存泄漏是什么？"><a href="#内核内存泄漏是什么？" class="headerlink" title="内核内存泄漏是什么？"></a>内核内存泄漏是什么？</h3><p>应用程序可以通过malloc()和free()在用户态申请和释放内存，与之对应，可以通过<strong>kmalloc()/kfree()以及vmalloc()/vfree()在内核态申请和释放内存</strong>。kmalloc()内存的物理地址是连续的，而vmalloc()内存的物理地址则是不连续的。</p><p>内核空间内存的生命周期是与内核一致的，却不是跟内核模块一致的，也就是说，在内核模块退出时，不会自动释放掉该内核模块申请的内存，只有在内核重启（即服务器重启）时才会释放掉这部分内存。</p><p>内核内存泄漏的问题往往会发生在一些驱动程序中，比如说网卡驱动，SSD卡驱动等。</p><h3 id="如何观察内核内存泄漏？"><a href="#如何观察内核内存泄漏？" class="headerlink" title="如何观察内核内存泄漏？"></a>如何观察内核内存泄漏？</h3><p>通过/proc/meminfo来观察内核内存的分配情况：</p><ul><li>如果/proc/meminfo中内核内存（比如VmallocUsed和SUnreclaim）太大，那很有可能发生内核内存泄漏；</li><li>也可以周期性地观察VmallocUsed和SUnreclaim的变化，如果它们持续增长而不下降，也可能是发生了内核内存泄漏。</li></ul><h3 id="复杂场景下内核内存泄漏问题分析思路"><a href="#复杂场景下内核内存泄漏问题分析思路" class="headerlink" title="复杂场景下内核内存泄漏问题分析思路"></a>复杂场景下内核内存泄漏问题分析思路</h3><p>最常用的分析工具就是<a href="https://www.kernel.org/doc/html/v4.10/dev-tools/kmemleak.html">kmemleak</a>。因为打开该特性会给性能带来一些损耗，所以生产环境中的内核都会默认关闭该特性。</p><p>kmemleak是通过检查内核内存的申请和释放，来判断是否存在申请的内存不再使用也不释放的情况。</p><p>如果存在，就认为是内核内存泄漏，然后把这些泄漏的信息通过/sys/kernel/debug/kmemleak这个文件导出给用户分析。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unreferenced object <span class="number">0xffffc9008a003000</span> (size <span class="number">1073741824</span>):</span><br><span class="line">  comm <span class="string">"insmod"</span>, pid <span class="number">11247</span>, jiffies <span class="number">4344145825</span> (age <span class="number">3719.606</span>s)</span><br><span class="line">  <span class="function">hex <span class="title">dump</span> <span class="params">(first <span class="number">32</span> bytes)</span>:</span></span><br><span class="line"><span class="function">    <span class="number">38</span> <span class="number">40</span> <span class="number">18</span> ba <span class="number">80</span> <span class="number">88</span> ff ff <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">8</span>@..............</span></span><br><span class="line"><span class="function">    f0 <span class="number">13</span> c9 <span class="number">73</span> <span class="number">80</span> <span class="number">88</span> ff ff <span class="number">18</span> <span class="number">40</span> <span class="number">18</span> ba <span class="number">80</span> <span class="number">88</span> ff ff  ...s.....@......</span></span><br><span class="line"><span class="function">  backtrace:</span></span><br><span class="line"><span class="function">    [&lt;<span class="number">00000000f</span>bd7cb65&gt;] __vmalloc_node_range+<span class="number">0x22f</span>/<span class="number">0x2a0</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000008</span>c0afaef&gt;] vmalloc+<span class="number">0x45</span>/<span class="number">0x50</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000004f</span>3750a2&gt;] <span class="number">0xffffffffa0937013</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">0000000078198</span>a11&gt;] <span class="number">0xffffffffa093c01a</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000002041</span>c0ec&gt;] do_one_initcall+<span class="number">0x4a</span>/<span class="number">0x200</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000008</span>d10d1ed&gt;] do_init_module+<span class="number">0x60</span>/<span class="number">0x220</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000003</span>c285703&gt;] load_module+<span class="number">0x156c</span>/<span class="number">0x17f0</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">00000000</span>c428a5fe&gt;] __do_sys_finit_module+<span class="number">0xbd</span>/<span class="number">0x120</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">00000000b</span>c613a5a&gt;] __x64_sys_finit_module+<span class="number">0x1a</span>/<span class="number">0x20</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000004b</span>0870a2&gt;] do_syscall_64+<span class="number">0x52</span>/<span class="number">0x90</span></span></span><br><span class="line"><span class="function">    [&lt;<span class="number">000000002f</span>458917&gt;] entry_SYSCALL_64_after_hwframe+<span class="number">0x44</span>/<span class="number">0xa9</span></span></span><br></pre></td></tr></tbody></table></figure><p>在生产环境上来观察内核内存泄漏，可以使用内核提供的内核内存申请释放的tracepoint，来动态观察内核内存使用情况：</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/4c434f56b5c41f9cc2eb53a2c98f948c.jpg"></p><p>想要观察某些内核结构体的申请和释放时，可能没有对应的tracepiont。这个时候就需要使用kprobe或者systemtap，来针对具体的内核结构体申请释放函数进行追踪了。</p><h2 id="内存泄漏时，如何一步步找到根因？"><a href="#内存泄漏时，如何一步步找到根因？" class="headerlink" title="内存泄漏时，如何一步步找到根因？"></a><strong>内存泄漏时，如何一步步找到根因？</strong></h2><h3 id="如何定位出是谁在消耗内存-？"><a href="#如何定位出是谁在消耗内存-？" class="headerlink" title="如何定位出是谁在消耗内存 ？"></a>如何定位出是谁在消耗内存 ？</h3><p>如果进程的内存有问题，那使用top就可以观察出来；</p><p>如果进程的内存没有问题，那你可以从/proc/meminfo入手来一步步地去深入分析。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/a48d1c573d19e30ecee8dc6f6fdd3930.jpg"></p><h3 id="如何去分析进程的内存泄漏原因？"><a href="#如何去分析进程的内存泄漏原因？" class="headerlink" title="如何去分析进程的内存泄漏原因？"></a>如何去分析进程的内存泄漏原因？</h3><p>案例：业务进程的虚拟地址空间（VIRT）被消耗很大，但是物理内存（RES）使用得却很少。</p><ol><li><p>可以用<strong>pidstat命令来追踪下该进程的内存行为</strong>，看看能够发现什么现象：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -r -p <span class="number">31108</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">04</span>:<span class="number">47</span>:<span class="number">00</span> PM     <span class="number">31108</span>    <span class="number">353.00</span>      <span class="number">0.00</span> <span class="number">299029776</span> <span class="number">4182152</span>  <span class="number">12.73</span>  app_server</span><br><span class="line">...</span><br><span class="line"><span class="number">04</span>:<span class="number">47</span>:<span class="number">59</span> PM     <span class="number">31108</span>    <span class="number">149.00</span>      <span class="number">0.00</span> <span class="number">299029776</span> <span class="number">4181052</span>  <span class="number">12.73</span>  app_server</span><br><span class="line"><span class="number">04</span>:<span class="number">48</span>:<span class="number">00</span> PM     <span class="number">31108</span>    <span class="number">191.00</span>      <span class="number">0.00</span> <span class="number">299040020</span> <span class="number">4181188</span>  <span class="number">12.73</span>  app_server</span><br><span class="line">...</span><br><span class="line"><span class="number">04</span>:<span class="number">48</span>:<span class="number">59</span> PM     <span class="number">31108</span>    <span class="number">179.00</span>      <span class="number">0.00</span> <span class="number">299040020</span> <span class="number">4181400</span>  <span class="number">12.73</span>  app_server</span><br><span class="line"><span class="number">04</span>:<span class="number">49</span>:<span class="number">00</span> PM     <span class="number">31108</span>    <span class="number">183.00</span>      <span class="number">0.00</span> <span class="number">299050264</span> <span class="number">4181524</span>  <span class="number">12.73</span>  app_server</span><br></pre></td></tr></tbody></table></figure><p>如上所示，在每个整分钟的时候，VSZ会增大10244KB，这看起来是一个很有规律的现象；</p></li><li><p>可以通过**/proc/PID/smaps来看增大的这个内存区域**到底是什么：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/<span class="number">31108</span>/smaps </span><br><span class="line">...</span><br><span class="line"><span class="number">7f</span>aae0e49000<span class="number">-7f</span>aae1849000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line">Size:              <span class="number">10240</span> kB</span><br><span class="line">Rss:                  <span class="number">80</span> kB</span><br><span class="line">Pss:                  <span class="number">80</span> kB</span><br><span class="line">Shared_Clean:          <span class="number">0</span> kB</span><br><span class="line">Shared_Dirty:          <span class="number">0</span> kB</span><br><span class="line">Private_Clean:         <span class="number">0</span> kB</span><br><span class="line">Private_Dirty:        <span class="number">80</span> kB</span><br><span class="line">Referenced:           <span class="number">60</span> kB</span><br><span class="line">Anonymous:            <span class="number">80</span> kB</span><br><span class="line">AnonHugePages:         <span class="number">0</span> kB</span><br><span class="line">Swap:                  <span class="number">0</span> kB</span><br><span class="line">KernelPageSize:        <span class="number">4</span> kB</span><br><span class="line">MMUPageSize:           <span class="number">4</span> kB</span><br><span class="line"></span><br><span class="line"><span class="number">7f</span>aae1849000<span class="number">-7f</span>aae184a000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line">Size:                  <span class="number">4</span> kB</span><br><span class="line">Rss:                   <span class="number">0</span> kB</span><br><span class="line">Pss:                   <span class="number">0</span> kB</span><br><span class="line">Shared_Clean:          <span class="number">0</span> kB</span><br><span class="line">Shared_Dirty:          <span class="number">0</span> kB</span><br><span class="line">Private_Clean:         <span class="number">0</span> kB</span><br><span class="line">Private_Dirty:         <span class="number">0</span> kB</span><br><span class="line">Referenced:            <span class="number">0</span> kB</span><br><span class="line">Anonymous:             <span class="number">0</span> kB</span><br><span class="line">AnonHugePages:         <span class="number">0</span> kB</span><br><span class="line">Swap:                  <span class="number">0</span> kB</span><br><span class="line">KernelPageSize:        <span class="number">4</span> kB</span><br><span class="line">MMUPageSize:           <span class="number">4</span> kB</span><br></pre></td></tr></tbody></table></figure><p>它包括：一个私有地址空间，这从rw-p这个属性中的private可以看出来；以及一个保护页 ，这从—p这个属性可以看出来，即进程无法访问。</p><p>对于有经验的开发者而言，从这个4K的保护页就可以猜测出应该跟<strong>线程栈</strong>有关了。</p></li><li><p>通过<strong>strace命令来跟踪系统调用了解进程申请这部分地址空间的目的</strong>是什么：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="number">31108.</span>strace | grep <span class="number">10489856</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">31152</span> <span class="number">23</span>:<span class="number">00</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31151</span> <span class="number">23</span>:<span class="number">01</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31157</span> <span class="number">23</span>:<span class="number">02</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31158</span> <span class="number">23</span>:<span class="number">03</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31165</span> <span class="number">23</span>:<span class="number">04</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31163</span> <span class="number">23</span>:<span class="number">05</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31153</span> <span class="number">23</span>:<span class="number">06</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br><span class="line"><span class="number">31155</span> <span class="number">23</span>:<span class="number">07</span>:<span class="number">00</span> <span class="built_in">mmap</span>(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, <span class="number">-1</span>, <span class="number">0</span> &lt;unfinished ...&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>实际上，系统中并没有很多app_server的线程，那这是为什么呢？答案其实比较简单：线程短暂执行完毕后就退出了，可是mmap的线程栈却没有被释放。</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核技术-Page Cache相关</title>
      <link href="/2023/10/16/linux-nei-he-ji-zhu-page-cache-xiang-guan/"/>
      <url>/2023/10/16/linux-nei-he-ji-zhu-page-cache-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h1 id="如何让Linux内核更好地服务应用程序？"><a href="#如何让Linux内核更好地服务应用程序？" class="headerlink" title="如何让Linux内核更好地服务应用程序？"></a>如何让Linux内核更好地服务应用程序？</h1><p>当发生TCP重传时，有人可以从<strong>tcpdump</strong>里面的信息看到是哪个TCP连接进行重传，然而高手们却可以通过这些信息看到为什么会发生重传。</p><p>四大类中的典型问题：<strong>Page Cache管理问题、内存泄漏问题、TCP重传问题、内核态CPU利用率飙高问题</strong>。</p><p>如何更好地利用Page Cache来减少无谓的I/O开销；</p><p>应用程序都是如何从系统中申请内存以及如何释放的；</p><p>TCP连接的建立、传输以及断开的过程。这个过程究竟会受哪些配置项的影响，如果配置不当会引起什么网络问题；</p><p>应用程序该如何高效地使用CPU，以及哪些情况下会导致CPU的使用很低效。</p><h1 id="Page-Cache管理问题"><a href="#Page-Cache管理问题" class="headerlink" title="Page Cache管理问题"></a>Page Cache管理问题</h1><h2 id="如何用数据观测Page-Cache？"><a href="#如何用数据观测Page-Cache？" class="headerlink" title="如何用数据观测Page Cache？"></a><strong>如何用数据观测Page Cache？</strong></h2><h3 id="Page-Cache存在的意义"><a href="#Page-Cache存在的意义" class="headerlink" title="Page Cache存在的意义"></a><strong>Page Cache存在的意义</strong></h3><p><strong>减少I/O，提升应用的I/O速度。</strong></p><p>但它对应用程序太过于透明，以至于应用程序很难有好方法来控制它。</p><h3 id="Page-Cache管理不当可能导致"><a href="#Page-Cache管理不当可能导致" class="headerlink" title="Page Cache管理不当可能导致"></a><strong>Page Cache管理不当可能导致</strong></h3><ul><li>服务器的load飙高；</li><li>服务器的I/O吞吐飙高；</li><li>业务响应时延出现大的毛刺；</li><li>业务平均访问时延明显增加</li></ul><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/f344917f3cacd5bc06ae7c743a217f1b.png"></p><p><strong>Page Cache是内核管理的内存，也就是说，它属于内核不属于用户。</strong></p><h3 id="查看Page-Cache的方式"><a href="#查看Page-Cache的方式" class="headerlink" title="查看Page Cache的方式"></a><strong>查看Page Cache的方式</strong></h3><p>/proc/meminfo、free 、/proc/vmstat命令等</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo</span><br><span class="line">...</span><br><span class="line">Buffers:            <span class="number">1224</span> kB</span><br><span class="line">Cached:           <span class="number">111472</span> kB</span><br><span class="line">SwapCached:        <span class="number">36364</span> kB</span><br><span class="line">Active:          <span class="number">6224232</span> kB</span><br><span class="line">Inactive:         <span class="number">979432</span> <span class="function">kB</span></span><br><span class="line"><span class="function"><span class="title">Active</span><span class="params">(anon)</span>:    <span class="number">6173036</span> kB</span></span><br><span class="line"><span class="function">Inactive(anon):   <span class="number">927932</span> kB</span></span><br><span class="line"><span class="function">Active(file):      <span class="number">51196</span> kB</span></span><br><span class="line"><span class="function">Inactive(file):    <span class="number">51500</span> kB</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">Shmem:             <span class="number">10000</span> kB</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">SReclaimable:      <span class="number">43532</span> kB</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</strong></p><p><strong>等式两边的内容就是我们平时说的Page Cache</strong></p><p>Active(file)+Inactive(file)是File-backed page（与文件对应的内存页），是你最需要关注的部分。因为你平时用的mmap()内存映射方式和buffered I/O来消耗的内存就属于这部分，<strong>最重要的是，这部分在真实的生产环境上也最容易产生问题</strong></p><p>SwapCached只在Swap分区打开的情况下才会有，而我建议你在生产环境中关闭Swap分区，因为Swap过程产生的I/O会很容易引起性能抖动。</p><p>应用本身消耗内存<strong>（RSS）不多</strong>的情况下，整个<strong>系统的内存使用率还是很高</strong>，那不妨去排查下是不是Shmem(共享内存)消耗了太多内存导致的。</p><h2 id="Page-Cache是怎样产生和释放的？"><a href="#Page-Cache是怎样产生和释放的？" class="headerlink" title="Page Cache是怎样产生和释放的？"></a><strong>Page Cache是怎样产生和释放的？</strong></h2><h3 id="Page-Cache是如何“诞生”的"><a href="#Page-Cache是如何“诞生”的" class="headerlink" title="Page Cache是如何“诞生”的"></a><strong>Page Cache是如何“诞生”的</strong></h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/4eb820e15a5560dee4b847227ee75752.jpg"></p><p><strong>标准I/O（Buffered I/O）</strong>是写的(write(2))用户缓冲区(Userpace Page对应的内存)，然后再将用户缓冲区里的数据拷贝到内核缓冲区(Pagecache Page对应的内存)；如果是读的(read(2))话则是先从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区读数据，也就是buffer和文件内容不存在任何映射关系。</p><p>对于<strong>存储映射I/O（Memory-Mapped I/O）</strong>而言，则是直接将Pagecache Page给映射到用户地址空间，用户直接读写Pagecache Page中内容。</p><p>存储映射I/O要比标准I/O效率高一些，毕竟少了“用户空间到内核空间互相拷贝”的过程。</p><h3 id="标准IO流程"><a href="#标准IO流程" class="headerlink" title="标准IO流程"></a><strong>标准IO流程</strong></h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/c728b8a189fb4e35e536cf131c4d9b5e.jpg"></p><p>Alloc Page理解为Page Cache的“诞生”，将Dirty Page理解为Page Cache的婴幼儿时期（最容易生病的时期），将Clean Page理解为Page Cache的成年时期（在这个时期就很少会生病了）</p><h3 id="观测page-cache"><a href="#观测page-cache" class="headerlink" title="观测page cache"></a><strong>观测page cache</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/vmstat | egrep <span class="string">"dirty|writeback"</span></span><br><span class="line">nr_dirty <span class="number">40</span></span><br><span class="line">nr_writeback <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>nr_dirty表示当前系统中积压了多少脏页，nr_writeback则表示有多少脏页正在回写到磁盘中，他们两个的单位都是Page(4KB)。</p><h3 id="Page-Cache是如何“死亡”的"><a href="#Page-Cache是如何“死亡”的" class="headerlink" title="Page Cache是如何“死亡”的"></a><strong>Page Cache是如何“死亡”的</strong></h3><p>应用在申请内存的时候，即使没有free内存，只要还有足够可回收的Page Cache，就可以通过回收Page Cache的方式来申请到内存，<strong>回收的方式主要是两种：直接回收和后台回收。</strong></p><h3 id="观察Page-Cache回收方式"><a href="#观察Page-Cache回收方式" class="headerlink" title="观察Page Cache回收方式"></a><strong>观察Page Cache回收方式</strong></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sar -B <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="number">02</span>:<span class="number">14</span>:<span class="number">01</span> PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line"></span><br><span class="line"><span class="number">02</span>:<span class="number">14</span>:<span class="number">01</span> PM      <span class="number">0.14</span>    <span class="number">841.53</span> <span class="number">106745.40</span>      <span class="number">0.00</span>  <span class="number">41936.13</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">02</span>:<span class="number">15</span>:<span class="number">01</span> PM      <span class="number">5.84</span>    <span class="number">840.97</span>  <span class="number">86713.56</span>      <span class="number">0.00</span>  <span class="number">43612.15</span>    <span class="number">717.81</span>      <span class="number">0.00</span>    <span class="number">717.66</span>     <span class="number">99.98</span></span><br><span class="line"><span class="number">02</span>:<span class="number">16</span>:<span class="number">01</span> PM     <span class="number">95.02</span>    <span class="number">816.53</span> <span class="number">100707.84</span>      <span class="number">0.13</span>  <span class="number">46525.81</span>   <span class="number">3557.90</span>      <span class="number">0.00</span>   <span class="number">3556.14</span>     <span class="number">99.95</span></span><br><span class="line"><span class="number">02</span>:<span class="number">17</span>:<span class="number">01</span> PM     <span class="number">10.56</span>    <span class="number">901.38</span> <span class="number">122726.31</span>      <span class="number">0.27</span>  <span class="number">54936.13</span>   <span class="number">8791.40</span>      <span class="number">0.00</span>   <span class="number">8790.17</span>     <span class="number">99.99</span></span><br><span class="line"><span class="number">02</span>:<span class="number">18</span>:<span class="number">01</span> PM    <span class="number">108.14</span>    <span class="number">306.69</span>  <span class="number">96519.75</span>      <span class="number">1.15</span>  <span class="number">67410.50</span>  <span class="number">14315.98</span>     <span class="number">31.48</span>  <span class="number">14319.38</span>     <span class="number">99.80</span></span><br><span class="line"><span class="number">02</span>:<span class="number">19</span>:<span class="number">01</span> PM      <span class="number">5.97</span>    <span class="number">489.67</span>  <span class="number">88026.03</span>      <span class="number">0.18</span>  <span class="number">48526.07</span>   <span class="number">1061.53</span>      <span class="number">0.00</span>   <span class="number">1061.42</span>     <span class="number">99.99</span></span><br></pre></td></tr></tbody></table></figure><p>借助上面这些指标，你可以更加明确地观察内存回收行为，下面是这些指标的具体含义：</p><ul><li>pgscank/s : kswapd(后台回收线程)每秒扫描的page个数。</li><li>pgscand/s: Application在内存申请过程中每秒直接扫描的page个数。</li><li>pgsteal/s: 扫描的page中每秒被回收的个数。</li><li>%vmeff: pgsteal/(pgscank+pgscand), 回收效率，越接近100说明系统越安全，越接近0说明系统内存压力越大。</li></ul><h2 id="如何处理Page-Cache难以回收产生的load飙高问题？"><a href="#如何处理Page-Cache难以回收产生的load飙高问题？" class="headerlink" title="如何处理Page Cache难以回收产生的load飙高问题？"></a><strong>如何处理Page Cache难以回收产生的load飙高问题？</strong></h2><h3 id="load飙升的原因"><a href="#load飙升的原因" class="headerlink" title="load飙升的原因"></a><strong>load飙升的原因</strong></h3><ul><li>直接内存回收引起的load飙高；</li><li>系统中脏页积压过多引起的load飙高；</li><li>系统NUMA策略配置不当引起的load飙高。</li></ul><h3 id="直接内存回收引起的load飙高"><a href="#直接内存回收引起的load飙高" class="headerlink" title="直接内存回收引起的load飙高"></a><strong>直接内存回收引起的load飙高</strong></h3><p>直接内存回收是在进程申请内存的过程中同步进行的回收，而这个回收过程可能会消耗很多时间，进而导致进程的后续行为都被迫等待，这样就会造成很长时间的延迟，以及系统的CPU利用率会升高，最终引起load飙高。</p><p>解决：</p><p><strong>及早地触发后台回收来避免应用程序进行直接内存回收。</strong>当内存水位低于watermark low时，会唤醒kswapd进行后台回收，然后kswapd会一直回收到watermark high；</p><p>可以增大min_free_kbytes这个配置选项来及早地触发后台回收，对于大于等于128G的系统而言，将min_free_kbytes设置为4G比较合理；</p><p>可以渐进式地增大该值，比如先调整为1G，观察sar -B中pgscand是否还有不为0的情况；如果存在不为0的情况，继续增加到2G，再次观察是否还有不为0的情况来决定是否增大，以此类推。</p><p>调整的效果可以通过/proc/zoneinfo来观察：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ egrep <span class="string">"min|low|high"</span> /proc/zoneinfo </span><br><span class="line">...</span><br><span class="line">        min      <span class="number">7019</span></span><br><span class="line">        low      <span class="number">8773</span></span><br><span class="line">        high     <span class="number">10527</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="系统中脏页过多引起load飙高"><a href="#系统中脏页过多引起load飙高" class="headerlink" title="系统中脏页过多引起load飙高"></a><strong>系统中脏页过多引起load飙高</strong></h3><p>存在较多脏页就可能涉及在回收过程中进行回写，这可能会造成非常大的延迟，而且因为这个过程本身是阻塞式的，所以又可能进一步导致系统中处于D状态的进程数增多，最终的表现就是系统的load值很高。</p><p>解决：</p><p>调小如下设置来将系统脏页个数控制在一个合理范围:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.dirty_background_bytes = <span class="number">0</span>- vm.dirty_background_ratio = <span class="number">10</span>- vm.dirty_bytes = <span class="number">0</span>- vm.dirty_expire_centisecs = <span class="number">3000</span>- vm.dirty_ratio = <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><h3 id="系统NUMA策略配置不当引起的load飙高"><a href="#系统NUMA策略配置不当引起的load飙高" class="headerlink" title="系统NUMA策略配置不当引起的load飙高"></a><strong>系统NUMA策略配置不当引起的load飙高</strong></h3><p>系统中还有一半左右的free内存，但还是频频触发direct reclaim，导致业务抖动得比较厉害。后来经过排查发现是由于设置了zone_reclaim_mode，这是NUMA策略的一种。内核将该配置从默认配置1修改为了默认配置0，避免了在其他node有空闲内存时，不去使用这些空闲内存而是去回收当前node的Page Cache。</p><h2 id="如何处理Page-Cache容易回收引起的业务性能问题？"><a href="#如何处理Page-Cache容易回收引起的业务性能问题？" class="headerlink" title="如何处理Page Cache容易回收引起的业务性能问题？"></a><strong>如何处理Page Cache容易回收引起的业务性能问题？</strong></h2><h3 id="两方面问题"><a href="#两方面问题" class="headerlink" title="两方面问题"></a><strong>两方面问题</strong></h3><ul><li>操作而导致Page Cache被回收掉，进而导致业务性能下降明显；</li><li>内核的一些机制导致业务Page Cache被回收，从而引起性能下降。</li></ul><h3 id="对Page-Cache操作不当产生的业务性能下降"><a href="#对Page-Cache操作不当产生的业务性能下降" class="headerlink" title="对Page Cache操作不当产生的业务性能下降"></a><strong>对Page Cache操作不当产生的业务性能下降</strong></h3><p>系统内存紧张的时候，运维人员或者开发人员会想要通过drop_caches的方式来释放一些内存。使用drop_cache来释放inode的话，可以通过写入不同的数值来释放不同类型的cache（用户数据Page Cache，内核数据Slab，或者二者都释放）</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/ab748f14be603df45c2570fe8e24707d.jpg"></p><p>Page Cache被释放掉会影响业务性能，所以就期望只去drop slab而不去drop pagecache。</p><p>可以通过/proc/vmstat来判断是否有执行过drop_caches。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep drop /proc/vmstat</span><br><span class="line">drop_pagecache <span class="number">3</span></span><br><span class="line">drop_slab <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>如果这两个值在问题发生前后没有变化，那就可以排除是有人执行了drop_caches；否则可以认为是因为drop_caches引起的Page Cache被回收。</p><h3 id="内核机制引起Page-Cache被回收而产生的业务性能下降"><a href="#内核机制引起Page-Cache被回收而产生的业务性能下降" class="headerlink" title="内核机制引起Page Cache被回收而产生的业务性能下降"></a><strong>内核机制引起Page Cache被回收而产生的业务性能下降</strong></h3><p>在内存紧张的时候会触发内存回收，内存回收会尝试去回收reclaimable（可以被回收的）内存，这部分内存既包含Page Cache又包含reclaimable kernel memory(比如slab)。</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/d33a7264358f20fb063cb49fc3f3163c.jpg"></p><p>如果inode被回收的话，那么它对应的Page Cache也都会被回收掉，所以如果业务进程读取的文件对应的inode被回收了，那么该文件所有的Page Cache都会被释放掉，这也是容易引起性能问题的地方。</p><p>可以通过/proc/vmstat来观察：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep inodesteal /proc/vmstat </span><br><span class="line">pginodesteal <span class="number">114341</span></span><br><span class="line">kswapd_inodesteal <span class="number">1291853</span></span><br></pre></td></tr></tbody></table></figure><h3 id="如何避免Page-Cache被回收而引起的性能问题"><a href="#如何避免Page-Cache被回收而引起的性能问题" class="headerlink" title="如何避免Page Cache被回收而引起的性能问题"></a><strong>如何避免Page Cache被回收而引起的性能问题</strong></h3><p>优化思路：</p><ul><li><p>从应用代码层面来优化：</p><p>对于重要的数据，可以通过mlock(2)来保护它，防止被回收以及被drop；</p><p>对于不重要的数据（比如日志），那可以通过madvise(2)告诉内核来立即释放这些Page Cache。</p></li><li><p>从系统层面来调整：</p><p>memory cgroup protection：需要保护的应用程序使用memory cgroup来保护起来</p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/71e7347264a54773d902aa92535b87cc.jpg"></p></li></ul><p><strong>如果想要保护Page Cache不被回收，就可以考虑将业务进程放在一个memory cgroup中，然后设置memory.{min,low} 来进行保护；与之相反，如果想要尽快释放Page Cache，那你可以考虑设置memory.high来及时的释放掉不活跃的Page Cache。</strong></p><h2 id="如何判断问题是否由Page-Cache产生的？"><a href="#如何判断问题是否由Page-Cache产生的？" class="headerlink" title="如何判断问题是否由Page Cache产生的？"></a><strong>如何判断问题是否由Page Cache产生的？</strong></h2><h3 id="Linux问题经典分析手段"><a href="#Linux问题经典分析手段" class="headerlink" title="Linux问题经典分析手段"></a><strong>Linux问题经典分析手段</strong></h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/ee08329fc5eb7fb8ddff14dba9ebf0c1.jpg"></p><p><strong>Linux内核主要是通过/proc和/sys把系统信息导出给用户，当你不清楚问题发生的原因时，你就可以试着去这几个目录下读取一下系统信息，看看哪些指标异常。</strong></p><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/ed990308aef09a5918e6855362284dbb.jpg"></p><p>如果pgscan相关指标变化较大，那就可能是Page Cache引起的。</p><h3 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a><strong>分析工具</strong></h3><p><img src="http://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Linux%e5%86%85%e6%a0%b8%e6%8a%80%e6%9c%af%e5%ae%9e%e6%88%98%e8%af%be/assets/0ccc072485d8ca2b995a6e7b6a75da97.jpg"></p><p>因为分析工具自身也会对业务造成一些影响（Heisenbug），比如说使用strace会阻塞进程的运行，再比如使用systemtap也会有加载编译的开销等，<strong>所以我们在使用这些工具之前也需要去详细了解下这些工具的副作用，以免引起意料之外的问题</strong>。</p><p><strong>有时候，我们没有办法及时地去搜集现场信息，可以根据sar的日志信息来判断当时发生了什么事情。</strong>根据sar的这些信息我们可以推断出故障是否跟Page Cache相关。比如，业务RT抖动的时间和sar -B里的pgscand不为0的时刻相比较后发现，二者在很多时候都是吻合的，则可以推断业务抖动跟Page Cache回收存在一些关系。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake学习与实战</title>
      <link href="/2023/08/08/cmake-xue-xi-yu-shi-zhan/"/>
      <url>/2023/08/08/cmake-xue-xi-yu-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>cmake的定义是高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）时，所有操作都是通过编译CMakeLists.txt来完成的</p><p>官方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p><h1 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h1><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p><h1 id="CMake一个HelloWord"><a href="#CMake一个HelloWord" class="headerlink" title="CMake一个HelloWord"></a>CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">std::cout &lt;&lt;  <span class="string">"hello word"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span> <span class="params">(HELLO)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">"This is BINARY dir "</span> ${HELLO_BINARY_DIR})</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">"This is SOURCE dir "</span>${HELLO_SOURCE_DIR})</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello ${SRC_LIST})</span></span></span><br></pre></td></tr></tbody></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[root@localhost cmake]<span class="meta"># cmake .</span></span><br><span class="line"><span class="function">CMake <span class="title">Warning</span> <span class="params">(dev)</span> in CMakeLists.txt:</span></span><br><span class="line"><span class="function">  Syntax Warning in cmake code at</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Argument not separated from preceding token by whitespace.</span></span><br><span class="line"><span class="function">This warning is for project developers.  Use -Wno-dev to suppress it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- The C compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- The CXX compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc</span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc -- works</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info - done</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info - done</span></span><br><span class="line"><span class="function">-- This is BINARY dir /root/cmake</span></span><br><span class="line"><span class="function">-- This is SOURCE dir /root/cmake</span></span><br><span class="line"><span class="function">-- Configuring done</span></span><br><span class="line"><span class="function">-- Generating done</span></span><br><span class="line"><span class="function">-- Build files have been written to: /root/cmake</span></span><br></pre></td></tr></tbody></table></figure><p>目录下就生成了这些文件-<strong>CMakeFiles, CMakeCache.txt, cmake_install.cmake</strong> 等文件，并且生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost cmake]<span class="meta"># make</span></span><br><span class="line">Scanning dependencies of target hello</span><br><span class="line">[<span class="number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span><br><span class="line">Linking CXX executable hello</span><br><span class="line">[<span class="number">100</span>%] Built target hello</span><br></pre></td></tr></tbody></table></figure><p>5、最终生成了Hello的可执行程序</p><h1 id="CMake一个HelloWord-的语法介绍"><a href="#CMake一个HelloWord-的语法介绍" class="headerlink" title="CMake一个HelloWord-的语法介绍"></a>CMake一个HelloWord-的语法介绍</h1><h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</projectname></p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</projectname></p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h1><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐全部使用大写指令</p></li></ul><h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="外部构建方式举例"><a href="#外部构建方式举例" class="headerlink" title="外部构建方式举例"></a>外部构建方式举例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子目录，CMakeLists.txt和上面例子一致</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># pwd</span></span><br><span class="line">/root/cmake</span><br><span class="line">[root@localhost cmake]<span class="meta"># ll</span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">198</span> Dec <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span> CMakeLists.txt</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root  <span class="number">76</span> Dec <span class="number">28</span> <span class="number">00</span>:<span class="number">18</span> main.cpp</span><br></pre></td></tr></tbody></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录"><a href="#将目标文件放入构建目录的-bin-子目录" class="headerlink" title="将目标文件放入构建目录的 bin 子目录"></a>将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></tbody></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></tbody></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></tbody></table></figure><h3 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR=/tmp/test</li><li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</li></ul></li></ul><h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│&nbsp;&nbsp; └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">7</span> files</span><br></pre></td></tr></tbody></table></figure><h3 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>cmake ..</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></tbody></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"hello.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED ${LIBHELLO_SRC})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED ${LIBHELLO_SRC})</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello STATIC ${LIBHELLO_SRC})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED ${LIBHELLO_SRC})</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC ${LIBHELLO_SRC})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC ${LIBHELLO_SRC})</span><br><span class="line"></span><br><span class="line"><span class="comment">//对hello_static的重名为hello</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED ${LIBHELLO_SRC})</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">"hello"</span>)</span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</prefix></p><p>将 hello.h 安装到<prefix>/include/hello 目录</prefix></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello/hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]<span class="meta"># ldd main </span></span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffedfda4000</span>)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.<span class="built_in">so</span> (<span class="number">0x00007f41c0d8f000</span>)</span><br><span class="line">libstdc++.so<span class="number">.6</span> =&gt; /lib64/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007f41c0874000</span>)</span><br><span class="line">libm.so<span class="number">.6</span> =&gt; /lib64/libm.so<span class="number">.6</span> (<span class="number">0x00007f41c0572000</span>)</span><br><span class="line">libgcc_s.so<span class="number">.1</span> =&gt; /lib64/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f41c035c000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f41bff8e000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f41c0b7c000</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结-RPC分布式通信框架</title>
      <link href="/2023/05/27/rpc-fen-bu-shi-tong-xin-kuang-jia-zong-jie/"/>
      <url>/2023/05/27/rpc-fen-bu-shi-tong-xin-kuang-jia-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>基于轻量级的Mudoo网络库和高效的Protobuf串行化协议，实现了RPC通信框架，用于实现分布式系统之间基于TCP的远程过程调用，具有高性能和高可靠性的特点。</p><p><img src="https://github.com/AutinC/RPC/blob/main/images/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92%E5%9B%BE-%E7%94%A8%E7%94%BB%E5%9B%BE%E6%9D%BF%E6%89%93%E5%BC%80.png?raw=true" alt="RPC分布式通信框架"></p><h1 id="一、集群和分布式的理论讲解"><a href="#一、集群和分布式的理论讲解" class="headerlink" title="一、集群和分布式的理论讲解"></a>一、集群和分布式的理论讲解</h1><h2 id="单机聊天服务器存在什么缺点"><a href="#单机聊天服务器存在什么缺点" class="headerlink" title="单机聊天服务器存在什么缺点"></a>单机聊天服务器存在什么缺点</h2><ul><li>单机聊天服务器所能承受的用户并发量受限于硬件资源的限制，如Linux端口数只有65536（2^16）个；</li><li>任意模块的修改，都会导致整个项目代码的重新编译、部署；</li><li>系统中有些模块是属于CPU密集型，有些属于IO密集型，所以各个模块对于硬件资源的需求不同，造成内存、CPU、带宽都有可能成为瓶颈</li></ul><h2 id="集群服务器的优缺点"><a href="#集群服务器的优缺点" class="headerlink" title="集群服务器的优缺点"></a>集群服务器的优缺点</h2><ul><li>优点：架构简单；每台机器是独立的系统，硬件资源提升，用户并发量提升</li><li>缺点：代码做修改需要整体重新编译并多次部署；某些模块（如管理员模块）不需要高并发，多处部署的意义不大</li></ul><h2 id="分布式服务器的优缺点"><a href="#分布式服务器的优缺点" class="headerlink" title="分布式服务器的优缺点"></a>分布式服务器的优缺点</h2><ul><li>优点：<ul><li><strong>可靠性</strong>：由于分布式系统是由多个节点组成的，因此任何一个节点发生故障不会影响整个系统的运行。</li><li><strong>可扩展性：</strong>当需要增加处理能力时，可以通过增加节点的方式来扩展系统的性能，而无需对整个系统进行重新设计。</li><li><strong>高性能：</strong>由于分布式系统可以利用多个节点的处理能力，因此可以更快地完成处理任务。</li><li><strong>资源共享：</strong>分布式系统中的节点可以共享资源，如存储空间、处理能力、网络带宽等，从而更加高效地利用系统资源。</li><li><strong>灵活性：</strong>分布式系统中的节点可以动态地加入或退出系统，因此可以根据需要随时调整系统的规模。</li></ul></li><li>缺点：<ul><li><strong>复杂性：</strong>分布式系统由多个节点组成，节点之间需要进行通信和协调，这增加了系统的复杂性，需要更多的开发和维护工作。</li><li><strong>一致性：</strong>在分布式系统中，数据存储在不同的节点上，节点之间需要保持数据一致性，这增加了数据管理的难度。</li><li><strong>安全性：</strong>由于分布式系统中的节点数量较多，因此需要更高的安全性保护，以避免恶意攻击或数据泄露。</li><li>性能瓶颈：由于节点之间需要进行通信和协调，因此在某些情况下可能会出现性能瓶颈，影响系统的性能。</li><li>成本：建立和维护分布式系统需要更多的硬件、软件和人力资源，因此成本较高。</li></ul></li></ul><h1 id="二、RPC通信原理及项目技术选型"><a href="#二、RPC通信原理及项目技术选型" class="headerlink" title="二、RPC通信原理及项目技术选型"></a>二、RPC通信原理及项目技术选型</h1><p><img src="https://github.com/AutinC/RPC/blob/main/images/1682240550705.png?raw=true" alt="RPC通信主要模块"></p><p><strong>黄色部分</strong>：设计rpc方法参数的打包和解析，也就是数据的<strong>序列化和反序列化</strong>，使用Protobuf。 </p><blockquote><p>Protobuf，即 Protocol Buffers，是一种轻量级的数据序列化协议，由Google公司开发，可用于将结构化数据序列化为可在网络上传输的格式。它支持多种编程语言，包括C++、Java、Python等，并且具有跨平台和语言互操作性的特性。</p><p>使用Protobuf，可以将数据结构定义为.proto文件，然后使用特定的编译器将其编译为目标语言的类。这些类可以用于在不同的系统和编程语言之间传输数据，并且具有更小的体积、更高的效率和更好的可读性。</p><p>与json比较：</p><p>1.Protobuf是二进制存储的，xml和json都是文本存储的；</p><p>2.Protobuf不需要存储额外信息，json存储键值对</p><p>因此，Protobuf序列化后的数据更小、更快、更灵活，尤其适合在高并发和网络通信中使用。</p></blockquote><p>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用<strong>muduo网络库和zookeeper服务配置中心</strong>（专门做服务发现）。 </p><h1 id="三、环境配置与使用"><a href="#三、环境配置与使用" class="headerlink" title="三、环境配置与使用"></a>三、环境配置与使用</h1><h2 id="项目代码工程目录"><a href="#项目代码工程目录" class="headerlink" title="项目代码工程目录"></a>项目代码工程目录</h2><p>bin：可执行文件<br>build：项目编译文件<br>lib：项目库文件<br>src：源文件<br>test：测试代码<br>example：框架代码使用范例<br>CMakeLists.txt：顶层的cmake文件<br>README.md：项目自述文件<br>autobuild.sh：一键编译脚本 </p><h2 id="Windows-VScode配置远程Linux开发环境"><a href="#Windows-VScode配置远程Linux开发环境" class="headerlink" title="Windows + VScode配置远程Linux开发环境"></a>Windows + VScode配置远程Linux开发环境</h2><p>参考博客：<a href="https://blog.csdn.net/qq756684177/article/details/94236990">https://blog.csdn.net/qq756684177/article/details/94236990</a> </p><ol><li>linux系统运行sshd服务 </li><li>在vscode上安装Remote Development插件，其依赖插件会自动安装 </li><li>配置远程linux主机的信息 </li><li>在vscode上开发远程连接linux</li></ol><h2 id="muduo源码编译安装与使用样例"><a href="#muduo源码编译安装与使用样例" class="headerlink" title="muduo源码编译安装与使用样例"></a>muduo源码编译安装与使用样例</h2><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>参考博客：<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980</a></p><h3 id="基于muduo的客户端服务器编程"><a href="#基于muduo的客户端服务器编程" class="headerlink" title="基于muduo的客户端服务器编程"></a>基于muduo的客户端服务器编程</h3><p>muduo网络库的编程很容易，要实现基于muduo网络库的服务器和客户端程序，只需要简单的组合TcpServer和TcpClient就可以，主要分为五个步骤：</p><ol><li>组合TcpServer对象</li><li>创建EventLoop事件循环对象指针</li><li>明确TcpServer构造函数的参数，输出ChatServer的构造函数</li><li>在当前服务器类的构造函数中，注册处理连接的回调函数和处理读写事件的回调函数</li><li>设置合适的服务端线程数量，muduo库会自己分配IO线程和worker线程</li></ol><ul><li>优点：灵活；根据节点的并发要求，对一个节点可以再做节点模块集群部署 </li><li>缺点：服务器共同构成一个系统，耦合度高</li></ul><h3 id="网络服务器编程常用模型"><a href="#网络服务器编程常用模型" class="headerlink" title="网络服务器编程常用模型"></a>网络服务器编程常用模型</h3><p><strong>【方案1】 ： accept + read/write</strong><br>不是并发服务器</p><p><strong>【方案2】 ： accept + fork - process-pre-connection</strong><br>适合并发连接数不大，计算任务工作量大于fork的开销</p><p><strong>【方案3】 ：accept + thread-pre-connection</strong><br>比方案2的开销小了一点，但是并发造成线程堆积过多</p><p><strong>【方案4】： muduo的网络设计：reactors in threads - one loop per thread</strong><br>方案的特点是one loop per thread，有一个main reactor负载accept连接，然后把连接分发到某个subreactor（采用round-robin的方式来选择sub reactor），该连接的所用操作都在那个sub reactor所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用CPU。<br>Reactor poll的大小是固定的，根据CPU的数目确定 。</p><p>一个Base IO thread负责accept新的连接，接收到新的连接以后，使用轮询的方式在reactor pool中找到合适的sub reactor将这个连接挂载上去，这个连接上的所有任务都在这个sub reactor上完成。<br>如果有过多的耗费CPU I/O的计算任务，可以提交到创建的ThreadPool线程池中专门处理耗时的计算任务。 </p><p><strong>【方案5】 ： reactors in process - one loop pre process</strong><br>Nginx服务器的网络模块设计，基于进程设计，采用多个Reactors充当I/O进程和工作进程，通过一把accept锁，完美解决多个Reactors的“惊群现象” 。</p><h3 id="muduo中的Reactor模型"><a href="#muduo中的Reactor模型" class="headerlink" title="muduo中的Reactor模型"></a>muduo中的Reactor模型</h3><ol><li>事件驱动（event handling）</li><li>可以处理一个或多个输入源（one or more inputs）</li><li>通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理</li></ol><p><img src="https://github.com/AutinC/RPC/blob/main/images/1683098044886.png?raw=true" alt="多Reactor模型"></p><h2 id="Protobuf安装配置与使用"><a href="#Protobuf安装配置与使用" class="headerlink" title="Protobuf安装配置与使用"></a>Protobuf安装配置与使用</h2><p>Protobuf（protocol buffer）是google 的一种数据交换的格式，它独立于平台语言。<br>Google 提供了protobuf多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。<br>由于它是一种二进制的格式，比使用 xml（20倍） 、json（10倍）进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域 。</p><h3 id="ubuntu-protobuf环境搭建"><a href="#ubuntu-protobuf环境搭建" class="headerlink" title="ubuntu protobuf环境搭建"></a>ubuntu protobuf环境搭建</h3><p><strong>github源代码下载地址：<a href="https://github.com/google/protobuf">https://github.com/google/protobuf</a></strong><br>安装过程如下：<br>1、解压压缩包：unzip protobuf-master.zip<br>2、进入解压后的文件夹：cd protobuf-master<br>3、安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip<br>4、自动生成configure配置文件：./autogen.sh<br>5、配置环境：./configure<br>6、编译源代码：make </p><p>7、安装：sudo make install<br>8、刷新动态库：sudo ldconfig </p><h3 id="Protobuf示例"><a href="#Protobuf示例" class="headerlink" title="Protobuf示例"></a>Protobuf示例</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">// 声明了protobuf的版本</span></span><br><span class="line"></span><br><span class="line">package fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义下面的选项，表示生成service服务类和rpc方法描述，默认不生成</span></span><br><span class="line">option cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message ResultCode</span><br><span class="line">{</span><br><span class="line">    int32 errcode = <span class="number">1</span>;</span><br><span class="line">    bytes errmsg = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据   列表   映射表</span></span><br><span class="line"><span class="comment">// 定义登录请求消息类型  name   pwd</span></span><br><span class="line">message LoginRequest</span><br><span class="line">{</span><br><span class="line">    bytes name = <span class="number">1</span>; <span class="comment">//等于1表示这是消息体里的第一个字段</span></span><br><span class="line">    bytes pwd = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录响应消息类型</span></span><br><span class="line">message LoginResponse</span><br><span class="line">{</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义获取好友列表请求消息类型</span></span><br><span class="line">message GetFriendListsRequest</span><br><span class="line">{</span><br><span class="line">    uint32 userid = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户信息类型</span></span><br><span class="line">message User</span><br><span class="line">{</span><br><span class="line">    bytes name = <span class="number">1</span>;</span><br><span class="line">    uint32 age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Sex</span></span><br><span class="line">    {</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义获取好友列表响应消息类型</span></span><br><span class="line">message GetFriendListsResponse</span><br><span class="line">{</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    repeated User friend_list = <span class="number">2</span>;  <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里面怎么定义描述rpc方法的类型 - service</span></span><br><span class="line">service UserServiceRpc</span><br><span class="line">{</span><br><span class="line">    <span class="function">rpc <span class="title">Login</span><span class="params">(LoginRequest)</span> <span class="title">returns</span><span class="params">(LoginResponse)</span></span>;</span><br><span class="line">    <span class="function">rpc <span class="title">GetFriendLists</span><span class="params">(GetFriendListsRequest)</span> <span class="title">returns</span><span class="params">(GetFriendListsResponse)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://github.com/AutinC/RPC/blob/main/images/1683104270953.png?raw=true" alt="message对象LoginRequest、LoginResponse继承于Message类"></p><p><img src="https://github.com/AutinC/RPC/blob/main/images/1683104510918.png?raw=true" alt="Service-->UserServiceRpc-->UserServiceRpc_Stub"></p><p><img src="https://github.com/AutinC/RPC/blob/main/images/1683166312879.png?raw=true" alt="RpcChannel调用CallMethod"></p><p>UserServiceRpc类自动继承于Service类，是rpc服务的提供者；</p><p>UserServiceRpc_Stub类自动继承于UserServiceRpc类，是rpc服务的消费者，其包含一个RpcChannel类型的成员变量channel，所有成员方法的调用本质都是通过channel调用其CallMethod方法。</p><p>RpcChannel类只有一个纯虚函数CallMethod，需要用户自己重写CallMethond方法（MyRpcChannel）并继承于RpcChannel，在构造UserServiceRpc_Stub时传入MyRpcChannel</p><h1 id="四、mprpc框架设计"><a href="#四、mprpc框架设计" class="headerlink" title="四、mprpc框架设计"></a>四、mprpc框架设计</h1><h2 id="框架的使用"><a href="#框架的使用" class="headerlink" title="框架的使用"></a>框架的使用</h2><p>example目录下的 <code>callee/UserService.cpp</code> 里面：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RpcApplication::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">//框架服务提供provider</span></span><br><span class="line">RpcProvider provide;</span><br><span class="line">provide.<span class="built_in">notify_service</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line">provide.<span class="built_in">run</span>();</span><br></pre></td></tr></tbody></table></figure><p>主要做了三个事情：</p><ul><li>首先 RPC 框架肯定是部署到一台服务器上的，所以我们需要对这个服务器的 ip 和 port 进行初始化</li><li>然后创建一个 porvider（也就是server）对象，将当前 UserService 这个对象传递给他，也就是其实这个 RPC 框架和我们执行具体业务的节点是在同一个服务器上的。RPC框架负责解析其他服务器传递过来的请求，然后将这些参数传递给本地的方法。并将返回值返回给其他服务器</li><li>最后是去让这个 provider 去 run 起来</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//获取ip和port</span></span><br><span class="line">    string ip = RpcApplication::<span class="built_in">get_instance</span>().<span class="built_in">get_configure</span>().<span class="built_in">find_load</span>(<span class="string">"rpcserver_ip"</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(RpcApplication::<span class="built_in">get_instance</span>().<span class="built_in">get_configure</span>().<span class="built_in">find_load</span>(<span class="string">"rpcserver_port"</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ip &lt;&lt; ":" &lt;&lt; port &lt;&lt; endl;</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建tcpserver对象</span></span><br><span class="line">    <span class="function">TcpServer <span class="title">server</span><span class="params">(&amp;eventloop_, address, <span class="string">"RpcProvider"</span>)</span></span>;</span><br><span class="line">    <span class="comment">//绑定链接回调和消息读写回调方法</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::on_connection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(<span class="built_in">bind</span>(&amp;RpcProvider::on_message, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置muduo库的线程数量</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把当前rpc节点上要发布的服务全部注册到zk上面，让rpc client可以从zk上发现服务</span></span><br><span class="line">    ZookeeperClient zk_client;</span><br><span class="line">    zk_client.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在配置中心中创建节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;sp : service_map_)</span><br><span class="line">    {</span><br><span class="line">        string service_path = <span class="string">"/"</span> + sp.first;</span><br><span class="line">        zk_client.<span class="built_in">create</span>(service_path.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;mp : sp.second.method_map_)</span><br><span class="line">        {</span><br><span class="line">            string method_path = service_path + <span class="string">"/"</span> + mp.first;</span><br><span class="line">            <span class="type">char</span> method_path_data[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">            <span class="built_in">sprintf</span>(method_path_data, <span class="string">"%s:%d"</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">            <span class="comment">//ZOO_EPHEMERAL 表示znode时候临时性节点</span></span><br><span class="line">            zk_client.<span class="built_in">create</span>(method_path.<span class="built_in">c_str</span>(), method_path_data, <span class="built_in">strlen</span>(method_path_data), ZOO_EPHEMERAL);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RPC_LOG_INFO</span>(<span class="string">"server RpcProvider [ip: %s][port: %d]"</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">    <span class="comment">//启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    eventloop_.<span class="built_in">loop</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>run函数的实现：</p><ul><li>因为底层调用的是muduo网络库，所以这里会获取ip地址和端口号，然后初始化网络层</li><li>然后去设置一个连接回调以及发生读写事件时候的回调函数（稍后介绍）</li><li>然后设置整个 muduo 网络库工作的线程数量</li><li>然后创建zookeeper配置中心，将这些方法的信息以及本机的IP地址注册到zookeeper</li><li>然后开启本机服务器的事件循环，等待其他服务器的连接</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目总结-百万高并发网络通信引擎</title>
      <link href="/2023/03/22/bai-wan-gao-bing-fa-wang-luo-tong-xin-yin-qing-zong-jie/"/>
      <url>/2023/03/22/bai-wan-gao-bing-fa-wang-luo-tong-xin-yin-qing-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="0、简介"><a href="#0、简介" class="headerlink" title="0、简介"></a>0、简介</h1><h2 id="1-方式：Socket、全栈、跨平台"><a href="#1-方式：Socket、全栈、跨平台" class="headerlink" title="1. 方式：Socket、全栈、跨平台"></a>1. 方式：Socket、全栈、跨平台</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>运用C++和Socket API来构建百万级处理能力的网络通信引擎</p><h3 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h3><p>不仅包含后端(服务端）的开发知识，还包括前端（客户端)的网络通信知识，并且会在主流引擎工具实际应用。</p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>项目中的技术知识和设计方案可以应用在Windows/Linux/Android/IOS等主流操作系统上，支持Socket的其他语言也开始借鉴使用。</p><h2 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows10+ Visual Studio 20XX</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux(ubuntu 16.04 64位)/GCC/Gedit编辑器<br>Visual Studio Code</p><p>Android</p><p>Windows 10 + VS2015 + NDK + JDK + ADT +ANT</p><h3 id="IOS-Macos"><a href="#IOS-Macos" class="headerlink" title="IOS/ Macos"></a>IOS/ Macos</h3><p>MacOS(MacOS 10.12 64位)+ Xcode 9</p><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><p>虚拟机VMware Player、代码管理工具SVN、文本比较工具WinMarge等辅助开发工具</p><h2 id="3-学习计划"><a href="#3-学习计划" class="headerlink" title="3. 学习计划"></a>3. 学习计划</h2><p>学会如何搭建不同平台下的C++开发环境。<br>学会Socket网络通信基础知识。<br>学会前端(客户端)网络通信，并实际应用到商业工具引擎中.<br>学会后端(服务端)网络通信，一步一步建立高性能服务器.</p><h2 id="4-最终任务"><a href="#4-最终任务" class="headerlink" title="4. 最终任务"></a>4. 最终任务</h2><p>从1个用户连接到10000个用户链接，从每秒1个用户/1个数据包,到1万用户/1百万个数据包,我们探索性能瓶颈,<br>解决瓶颈,一步一步加入优化点,进行前后对比,深度解析每一个优化解决了那些问题。真正掌握核心知识。 </p><h1 id="一、建立基础TCP服务端-客户端"><a href="#一、建立基础TCP服务端-客户端" class="headerlink" title="一、建立基础TCP服务端/客户端"></a>一、建立基础TCP服务端/客户端</h1><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201126212745789.png?raw=true" alt="单个客户端服务端通信框架"></p><h2 id="1-建立服务端大致流程"><a href="#1-建立服务端大致流程" class="headerlink" title="1. 建立服务端大致流程"></a>1. 建立服务端大致流程</h2><ol><li>建立一个套接字 <strong>（socket）</strong></li><li>绑定客户端连接的端口 <strong>（bind）</strong></li><li>监听网络端口 <strong>（listen）</strong></li><li>等待接受客户端连接 <strong>（accept）</strong></li><li>接收客户端发送的数据 <strong>（recv）</strong></li><li>向客户端发送数据 <strong>（send）</strong></li><li>关闭套接字 <strong>（closesocket）</strong></li></ol><h2 id="2-建立客户端大致流程"><a href="#2-建立客户端大致流程" class="headerlink" title="2. 建立客户端大致流程"></a>2. 建立客户端大致流程</h2><ol><li>建立一个套接字 <strong>（socket）</strong></li><li>连接服务器 <strong>（connect）</strong></li><li>向客户端发送数据 <strong>（send）</strong></li><li>接收客户端发送的数据 <strong>（recv）</strong></li><li>关闭套接字 <strong>（closesocket）</strong></li></ol><h2 id="3-实现多个客户端与服务器相连"><a href="#3-实现多个客户端与服务器相连" class="headerlink" title="3. 实现多个客户端与服务器相连"></a>3. 实现多个客户端与服务器相连</h2><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201126213341195.png?raw=true" alt="多个客户端与服务端通信框架"></p><h2 id="4-建立可持续处理请求的网络程序"><a href="#4-建立可持续处理请求的网络程序" class="headerlink" title="4. 建立可持续处理请求的网络程序"></a>4. 建立可持续处理请求的网络程序</h2><p>  在进行socket连接后，即服务端进行<strong>accept</strong>操作、客户端进行<strong>connect</strong>操作后，使用循环，在此循环中进行<strong>send/recv</strong>操作传输数据，即可实现持续处理请求。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201126214543105.png?raw=true" alt="多个客户端与服务端可持续通信框架"></p><h1 id="二、网络数据报文的定义与收发"><a href="#二、网络数据报文的定义与收发" class="headerlink" title="二、网络数据报文的定义与收发"></a>二、网络数据报文的定义与收发</h1><h2 id="1-网络数据报文的格式定义"><a href="#1-网络数据报文的格式定义" class="headerlink" title="1. 网络数据报文的格式定义"></a>1. 网络数据报文的格式定义</h2><ul><li>报文有两个部分，<strong>包头</strong>和<strong>包体</strong>，是网络消息的基本单元。</li><li><strong>包头：</strong> 描述本次消息包的大小，描述包体数据的作用。</li><li><strong>包体：</strong> 其中包含了需要传输的数据。</li></ul><p> 根据此数据结构，可以根据包头的内容，来灵活的对包体的数据进行处理。</p><h2 id="2-将包头与包体数据分开收发"><a href="#2-将包头与包体数据分开收发" class="headerlink" title="2. 将包头与包体数据分开收发"></a>2. 将包头与包体数据分开收发</h2><p>通过上文对网络数据报文的定义，可以很轻易的想到：</p><ul><li><p>发送端进行两次send操作，<strong>第一次send发送包头</strong>，<strong>第二次send发送包体</strong>，即可实现网络数据报文的发送。</p></li><li><p>接收端进行两次recv操作，<strong>第一次recv接收包头</strong>，<strong>第二次recv接收包体</strong>并根据包头的内容进行数据处理，即可实现网络数据报文的接收。</p><p>按以上操作，即可实现网络数据报文的收发。</p></li></ul><h2 id="3-将分开收发报文数据改为一次收发"><a href="#3-将分开收发报文数据改为一次收发" class="headerlink" title="3. 将分开收发报文数据改为一次收发"></a>3. 将分开收发报文数据改为一次收发</h2><ul><li>由上文可以知道，可以通过两次send和两次recv进行报文的收发，但是其中操作较为麻烦，需要多次声明DateHeader包头结构体，不仅消耗时间资源，也容易出错。</li><li>因此，可以尝试将分开收发改为一次收发。大致思路为完善报文的结构体，<strong>使包体继承包头结构体，或者使包体结构体中包含一个包头结构体</strong>。由此完善报文的结构体，只进行一次send操作，即可发送所有报文数据。</li><li>在进行数据接收时，我们先接收包头大小的数据，随后根据包头的内容，来确定接下来接收数据的大小，即<strong>接收总数据大小 减去 包头数据大小</strong> 的数据。而在接下来使用recv接收剩下数据时，要<strong>使用指针偏移</strong>，跳过结构体包头的接收(因为接收过了)，直接接收到包体数据位置上。</li></ul><h1 id="三、升级为select网络模型"><a href="#三、升级为select网络模型" class="headerlink" title="三、升级为select网络模型"></a>三、升级为select网络模型</h1><h2 id="1-为什么要用select网络模型"><a href="#1-为什么要用select网络模型" class="headerlink" title="1. 为什么要用select网络模型"></a>1. 为什么要用select网络模型</h2><p>通过前面的学习，已经实现了简单的网络报文收发。但是可以很明显的看出其中的缺点，那就是整个程序的运行是<strong>阻塞模式</strong>的：</p><ul><li>服务端在与一个客户端进行socket连接时，只要连接不中断，那么就无法接收新的客户端的消息；</li><li>客户端在未输入命令时，是阻塞状态，也无法接收服务端发来的消息。</li></ul><p>在之前碰到这个问题时，我的想法是通过多线程来解决程序运行中的阻塞问题，但是在最近的学习中，我了解到可以使用select网络模型来方便快捷的解决小型网络程序运行中的阻塞问题。（查阅I/O多路复用模型相关内容）</p><h2 id="2-select相关使用总结与心得"><a href="#2-select相关使用总结与心得" class="headerlink" title="2. select相关使用总结与心得"></a>2. select相关使用总结与心得</h2><p>在一开始的select使用中，我以为向select函数中传入fd_set地址，select会把待处理事件的socket放在set集合中，但是发现并不是这样。<br>经过网络上资料的查询以及我个人的测试，可以发现，用户首先需要把一份socket数组传入到此set中，<strong>select函数的作用是移除该set中没有待处理事件的socket</strong>，则剩下的socket都存在待处理事件(未决I/O操作)。这个过程可以说是一种“选择”的过程，select函数“选择”出需要操作的socket，这或许就是select(选择)的意思吧。<br>在接下来的源码中，对于需要存储所有已连接socket的服务端，我使用动态数组vector进行socket的储存。在进行select筛选前，先把vector中的socket导入到set中，随后set中筛选剩下的即为有待处理事件的socket。<br>如果服务端自己的socket提示有待处理事件，则说明有新的客户端尝试进行连接，此时进行accept操作即可。<br>对于客户端的多线程问题，需要注意<strong>使用detach()方法使主线程与新线程分类</strong>，否则可能会出现主线程先结束的情况，导致程序出错。<br>在线程中，我们可以引入一个bool变量，用来记录客户端是否仍在连接中，当输入exit命令退出客户端时，通过此bool变量使主线程停止，跳出循环。</p><h2 id="3-升级为select网络模型的思路"><a href="#3-升级为select网络模型的思路" class="headerlink" title="3. 升级为select网络模型的思路"></a>3. 升级为select网络模型的思路</h2><ul><li><p>服务端升级（<strong>select</strong>）</p><p>之前的思路是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="number">4.</span>与客户端连接</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">5.</span>接收数据</span><br><span class="line"><span class="number">6.</span>发送数据</span><br><span class="line">}</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure><p>导致服务端只能与一个客户端进行连接，随后便进入循环，只能接收这一个客户端的消息，且由于send与recv函数都是阻塞函数，所以程序也是阻塞模式的。</p><p>根据select网络模型，对服务端进行升级。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line"><span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line"><span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure></li><li><p>客户端升级（<strong>select+多线程</strong>）</p><p>之前的思路是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">3.</span>发送数据</span><br><span class="line"><span class="number">4.</span>接收数据</span><br><span class="line">}</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure><p>导致客户端在与一个服务端连接后，无法被动的接收服务器端发来的消息。因为send与recv函数都是阻塞函数，程序也为阻塞模式。如果我们想要客户端能接收服务端发来的消息，那么就可以使用select模型。</p><p>根据select网络模型，对客户端进行升级。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">3.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line"><span class="number">4.</span>如果有，就处理它(接收/发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure><p>但是，这样的程序结构也有很明显的缺点，因为数据接收函数也为阻塞函数，如果我们想要主动输入一些命令发送给服务端，就会阻塞程序运行。对此，我们可以引入<strong>多线程</strong>解决问题。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line"><span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">5.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">1.</span>键入数据</span><br><span class="line"><span class="number">2.</span>发送数据</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="四、跨平台移植到Linux、macOS中"><a href="#四、跨平台移植到Linux、macOS中" class="headerlink" title="四、跨平台移植到Linux、macOS中"></a>四、跨平台移植到Linux、macOS中</h1><h2 id="1-为什么要进行跨平台操作"><a href="#1-为什么要进行跨平台操作" class="headerlink" title="1. 为什么要进行跨平台操作"></a>1. 为什么要进行跨平台操作</h2><p>首先，我是想在网络编程学习渐入佳境后，自己尝试做一个网络方面的项目，其中就必须用到服务器。Linux服务器相比Windows服务器更加稳定且高效，所以对于我来说，学会如何编写出可以在Linux系统下运行的网络程序是必不可少的。其次，就目前来说，企业中的高性能网络编程都是基于Linux的，学会跨平台的网络编程技能，可以在未来就业方面等有很大的好处。由此，我决定在网络编程学习的第四小阶段，学习如何进行跨平台的网络编程。</p><h2 id="2-关于Win与Linux系统下网络编程的差异"><a href="#2-关于Win与Linux系统下网络编程的差异" class="headerlink" title="2. 关于Win与Linux系统下网络编程的差异"></a>2. 关于Win与Linux系统下网络编程的差异</h2><ul><li><p><strong>在Linux环境下，程序的头文件与定义与Win环境下存在差异</strong></p><ul><li>Win环境下的特有头文件 &lt;windows.h&gt; 对应Linux环境下的特有头文件 &lt;unistd.h&gt;</li><li>Win环境下的网络头文件 &lt;winSock2.h&gt; 对应Linux环境下的特有头文件 &lt;arpa/inet.h&gt;</li><li>SOCKET为Win环境下的特有数据类型，其原型为unsigned __int64，所以我们在Linux下，需要简单对SOCKET进行定义</li><li>Linux中同样对INVALID_SOCKET与SOCKET_ERROR也没有定义，所以我们参考Win中的定义，在Linux系统下对其定义。</li></ul></li><li><p>在Linux环境下不需要使用<strong>WSAStartup</strong>与<strong>WSACleanup</strong>搭建网络环境，这是Win环境特有的，所以只需要加上#ifdef _WIN32的判断即可，当检测到系统环境为Win时执行</p></li><li><p>Linux环境与Win环境下，网络通信相关结构体 <strong>sockaddr_in</strong>和<strong>sockaddr</strong> 存在差异，最明显的差异为存储IP的结构不太一样</p></li><li><p>Linux环境与Win环境下，关闭套接字的函数存在差异，Win下为<strong>closesocket()<strong>，Linux下则简单粗暴为</strong>close()</strong></p></li><li><p>Linux环境与Win环境下，服务器的accept连接函数参数存在差异，Win下的最后一个参数为<strong>int</strong>型地址，Linux下则为<strong>socklen_t</strong>型地址，进行一次强制转换即可</p></li><li><p>Linux环境与Win环境下，fd_set结构体中的参数出现了变化，不再有储存socket数量的fd_count变量</p><ul><li><p>需要对源码下select函数的第一个参数进行准确的数据传入。select函数的第一个参数实际为<strong>所有socket的最大值+1</strong>，所以我们新建一个变量，用于储存最大值。在每次对fdread集合进行导入时，找到socket的最大值，随后传入select函数即可。</p></li><li><p>需要对源码下面关于遍历socket的逻辑进行改变。首先遍历 _clients 数组中的所有socket，随后使用FD_ISSET函数判定其是否存在待处理事件，如果有，即可按逻辑进行处理。</p></li></ul></li></ul><h2 id="3-移植过程中遇到的一些问题"><a href="#3-移植过程中遇到的一些问题" class="headerlink" title="3. 移植过程中遇到的一些问题"></a>3. 移植过程中遇到的一些问题</h2><ul><li><p><strong>关于IP的问题</strong></p><p>如果服务端在本机Windows环境下运行，客户端在VM虚拟机Linux环境下运行，则在Windows命令行上输入<strong>ipconfig</strong>命令。下面这一块数据下的IPv4地址即为客户端需要连接的IP。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : </span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : </span><br><span class="line">   子网掩码  . . . . . . . . . . . . : </span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br></pre></td></tr></tbody></table></figure><p>如果服务端在VM虚拟机Linux环境下运行，客户端在本机Windows环境下运行，则在Linux命令行上输入<strong>ifconfig</strong>命令。显示出来的数据中网卡的IP即为客户端需要连接的IP。</p></li><li><p><strong>关于端口的问题</strong></p><p>如果服务端运行正常，客户端运行正常，本机双开客户端和服务端也运行正常，但本机与虚拟机各开一个却连接不上时，可能是服务端的端口未开放导致的。</p><ul><li><p>Windows环境下会主动提示，点击允许即可。</p></li><li><p>Linux环境下相关命令如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld 查看防火墙状态</span><br><span class="line">systemctl start firewalld 开启防火墙 </span><br><span class="line">systemctl stop firewalld 关闭防火墙 </span><br><span class="line">service firewalld start 开启防火墙 </span><br><span class="line"></span><br><span class="line">查看对外开放的<span class="number">8888</span>端口状态 yes/no</span><br><span class="line">firewall-cmd --query-port=<span class="number">8888</span>/tcp</span><br><span class="line">打开<span class="number">8888</span>端口</span><br><span class="line">firewall-cmd --add-port=<span class="number">8888</span>/tcp --permanent</span><br><span class="line">重载端口</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">移除指定的<span class="number">8888</span>端口：</span><br><span class="line">firewall-cmd --permanent --remove-port=<span class="number">8888</span>/tcp</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h1 id="五、源码的封装"><a href="#五、源码的封装" class="headerlink" title="五、源码的封装"></a>五、源码的封装</h1><h2 id="1-为什么要进行封装操作"><a href="#1-为什么要进行封装操作" class="headerlink" title="1. 为什么要进行封装操作"></a>1. 为什么要进行封装操作</h2><p>C++为面向对象编程语言，我们要以面向对象的思路进行源码的编写。在对主要源码进行封装后，客户端与服务端的代码编写更加清晰明了，逻辑性更强，便于开发维护。且在今后的服务端高并发测试中，便于新建多个连接进行测试。<br>在本部分中，基于第四部分的源码进行封装，并将记录我对客户端与服务端源码进行封装时的思路与步骤。最终源码为客户端封装类文件TcpClient.hpp与服务端封装类文件TcpServer.hpp，以及客户端源码clien.cpp与服务端源码server.cpp。</p><h2 id="2-封装的思路"><a href="#2-封装的思路" class="headerlink" title="2. 封装的思路"></a>2. 封装的思路</h2><ul><li><p><strong>客户端的封装</strong></p><p>客户端的大致流程：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>连接服务器</span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">4.</span>使用select函数获取服务器端是否有待处理事件</span><br><span class="line"><span class="number">5.</span>如果有，就处理它(接收/发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">6.</span>关闭socket</span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">1.</span>键入数据</span><br><span class="line"><span class="number">2.</span>发送数据</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要封装的方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//连接服务器 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//关闭socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>按照此思路，客户端的源码思路为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.</span><span class="built_in">Connect</span>(<span class="type">const</span> <span class="type">char</span> *ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//连接服务器 传入IP与端口</span></span><br><span class="line"><span class="number">3.</span>建立新线程 用于发送命令</span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">{</span><br><span class="line"><span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查询是否有待处理消息</span></span><br><span class="line">}</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br><span class="line"></span><br><span class="line">新线程：</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1.</span><span class="built_in">IsRun</span>())<span class="comment">//检测是否工作中</span></span><br><span class="line">{</span><br><span class="line"><span class="number">2.</span>键入数据</span><br><span class="line"><span class="number">3.</span><span class="built_in">SendData</span>(DataHeader *_head);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，<strong>OnRun()</strong> 方法中使用的是select网络结构，在select筛选出待处理事件后，使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。<strong>NetMsg() 方法为虚方法</strong>，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p><p>另外，由于已经被封装，所以在调用方法时，可能会出现<strong>步骤错误</strong>的情况。例如还没进行新建套接字就进行<strong>connect连接操作或是关闭套接字操作、传入数据有误</strong>等等，此时就会出现问题。<br>我解决此类问题的方法是<strong>多加判定</strong>。例如判定套接字是否已经被建立，或是传入数据是否有误等等，随后根据情况进行处理。</p></li><li><p><strong>服务端的封装</strong></p><p>服务端的大致流程：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line"><span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line"><span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure><p>需要封装的方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化socket </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//绑定IP/端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//接受连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭socket </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//发送数据 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendData</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET _temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *_head,SOCKET _temp_socket)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>按照此思路，服务端的源码思路为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>();<span class="comment">//建立socket</span></span><br><span class="line"><span class="number">2.B</span>ind(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port);<span class="comment">//绑定端口IP</span></span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n);<span class="comment">//监听端口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">4.</span><span class="built_in">IsRun</span>())<span class="comment">//是否工作中</span></span><br><span class="line">{</span><br><span class="line"><span class="number">5.</span><span class="built_in">OnRun</span>();<span class="comment">//查看是否有待处理消息</span></span><br><span class="line">}</span><br><span class="line"><span class="number">6.</span><span class="built_in">CloseSocket</span>();<span class="comment">//关闭socket</span></span><br></pre></td></tr></tbody></table></figure><p>其中，<strong>OnRun()</strong> 方法中使用的是select网络结构。在select筛选出待处理事件后，如果为新连接，则使用<strong>Accept()</strong> 方法进行新客户端连接操作；如果为已连接客户端的待接受事件，则使用<strong>RecvData()</strong> 方法进行包头与包体的接收，随后调用<strong>NetMsg()</strong> 方法，依据包头的报文类型对包体数据进行处理。NetMsg() 方法为虚方法，在之后调用此封装类时，可以进行继承重载操作，便于对数据响应的操作进行变更。</p></li></ul><h1 id="六、缓冲区溢出与粘包分包"><a href="#六、缓冲区溢出与粘包分包" class="headerlink" title="六、缓冲区溢出与粘包分包"></a>六、缓冲区溢出与粘包分包</h1><h2 id="1-关于缓冲区溢出的原因与解决办法"><a href="#1-关于缓冲区溢出的原因与解决办法" class="headerlink" title="1. 关于缓冲区溢出的原因与解决办法"></a>1. 关于缓冲区溢出的原因与解决办法</h2><ul><li><p><strong>缓冲区溢出的原因</strong></p><p>之前我们所编写的服务端与客户端的数据量都是很小的，且操作也不频繁，需要键入指令发送报文。</p><p>我们可以尝试在之前客户端代码的循环里，不断发送一种数据包，且把数据包的大小加大到1000字节，会发现很快服务端和客户端就会出现问题——要么是数据接收出现问题，要么是服务端或者客户端程序直接卡掉。这里出现问题的原因就是<strong>socket内核缓冲区溢出</strong>。</p><p>首先，send和recv函数并不是直接通过网卡操作。在使用send函数时，<strong>send函数首先把数据写入到发送缓冲区，随后通过网卡发出；在使用recv函数时，网卡首先把接收到的消息写入接收缓冲区，recv函数再从中copy数据</strong>。注意，上文中的两个缓冲区是存在于内核中的，并不是程序中自定义的缓冲区。</p><p>在之前的源码中，recv的逻辑是先接收包头，随后根据包头接收包体。而当网卡接收数据太多时，我们接收一个包头的时间，网卡可能就新接收了两个完整的数据包，这就导致内核接收缓冲区里的数据量是在不断增加的，最终导致接收缓冲区溢出，造成无法正常发送以及程序阻塞的问题。</p><p>举个例子，缓冲区就像一个浴缸，而我们是一个拿盆子舀水的人。我们之前先接收一个包头就相当于舀出一个包头那么多的水，随后再舀出包体那么多的水。舀了两次仅仅舀出一个报文那么多的水。如果浴缸放水的速度比较大的话，我们很容易就会处理不过来。最终造成浴缸溢出(缓冲区溢出)。</p></li><li><p><strong>缓冲区溢出的解决办法</strong></p><p>首先不大可能改变浴缸的大小，因为太过麻烦以及治标不治本，只要浴缸放水的时间够长，总会溢出。接着，舀水的速度我们也不好改变，因为一时半会是改不了的。那我们就只能改变<strong>舀水的次数和数量</strong>了。</p><p>如何改变舀水的数量和次数？我们可以<strong>一次舀出足够多的水，随后再从舀出的水中分出想要数量的水</strong>，这样浴缸溢出的可能性就大大减少了。</p><p>从代码层面来看上面的思路，只要我们<strong>程序内新建一个足够大的缓冲区，一次从内核缓冲区上recv足够的数据，就可以避免内核缓冲区溢出</strong>了。</p><p>但是这样会出现新的问题，即<strong>粘包与分包</strong>问题。</p></li></ul><h2 id="2-粘包与分包的原因及解决方法"><a href="#2-粘包与分包的原因及解决方法" class="headerlink" title="2. 粘包与分包的原因及解决方法"></a>2. 粘包与分包的原因及解决方法</h2><ul><li><p><strong>粘包与分包的原因</strong></p><p>一次接收那么多数据，其中数据的界限是没有限定的，比如上文中是想要一次接收4096个字节。假如缓冲区内有5个1000字节大小的数据包，我们这次接收4096字节，等于说接收的数据中有4.096个数据包，其中就包含了新的问题。</p><ul><li><strong>粘包问题：</strong>一次接收中含有多个数据包，这就导致数据包界限不清，粘在了一起。像上文中的4.096个包，接收端是不清楚的，接收端只知道有4096字节的数据，但是它不知道一个包是多大。所以我们可以通<strong>过包头来获取一个数据包的大小</strong>，由此来处理相应大小的数据以解决粘包问题。</li><li><strong>分包问题：</strong>一次接收中含有不完整的包。例如上文中的4096个字节，其中包含了4个完整的包，和一个包的前96个字节。对此，我们只能处理前4个完整的数据包。那么问题来了，对于上文中的缓冲区，由于recv函数每次都会覆盖这个缓冲区，这就导致缓冲区内无法存放未处理的消息。对于这个问题，我们可以<strong>新建一个缓冲区，来存放未处理的消息，实现双缓冲，</strong>即可处理分包问题。</li></ul><p>TCP是面向数据流的协议，所以会出现粘包分包问题；UDP是面向消息的协议，每一个数据段都是一条消息，所以不会出现粘包分包问题。</p></li><li><p><strong>粘包与分包的解决办法</strong></p><ul><li><p><strong>客户端升级思路</strong></p><p>首先是<strong>新建两个缓冲区，一个用来存放recv到的数据，一个用来存放所有待处理数据</strong>。首先第一个缓冲区recv到数据，随后把第一个缓冲区内的数据copy到第二个缓冲区内，即可实现数据的存放。随后处理数据之类的还是先获取包头，随后根据包头处理包体数据。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>]</span><br><span class="line"><span class="type">char</span> 消息缓冲区[<span class="number">40960</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(SOCKET temp_socket)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="comment">//接收客户端发送的数据 </span></span><br><span class="line"><span class="type">int</span> recv_len = <span class="built_in">recv</span>(temp_socket, 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"与服务器断开连接,任务结束\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">} </span><br><span class="line"><span class="number">1.</span>将接收缓冲区的数据拷贝到消息缓冲区 </span><br><span class="line"><span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) </span><br><span class="line">{</span><br><span class="line"><span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">{</span><br><span class="line"><span class="number">5.</span>响应数据 </span><br><span class="line"><span class="number">6.</span>将处理过的消息移出消息缓冲区</span><br><span class="line">} </span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>服务端升级思路</strong></p><p>与客户端整体思路相似，但是需要注意，服务端有多个连接，如果多个连接共用一个缓冲区会存在错误，所以每一个客户端连接都需要有自己的缓冲区。对此，我们可以<strong>新建一个客户端连接类，来存放每一个客户端的socket以及它的缓冲区</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 客户端连接</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="number">1.</span>获取<span class="built_in">socket</span>() </span><br><span class="line"><span class="number">2.</span>获取缓冲区()</span><br><span class="line"><span class="number">3.</span>获取缓冲区长度()</span><br><span class="line"><span class="number">4.</span>设置缓冲区长度()</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="number">1.</span>socket</span><br><span class="line"><span class="number">2.</span>缓冲区</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line">std::vector&lt;客户端连接*&gt; _clients;<span class="comment">//储存客户端socket</span></span><br><span class="line"><span class="type">char</span> 接收缓冲区[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">0.</span>此时前面OnRun函数里的判断过程也需要改变</span><br><span class="line"><span class="comment">//遍历所有socket 查看是否有待处理事件 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); ++n)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(_clients[n]-&gt;获取<span class="built_in">socket</span>(),&amp;fdRead))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">RecvData</span>(_clients[n]))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">{</span><br><span class="line">std::vector&lt;客户端连接*&gt;::iterator iter = _clients.<span class="built_in">begin</span>()+n;<span class="comment">//找到退出客户端的地址</span></span><br><span class="line"><span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())<span class="comment">//如果是合理值</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">delete</span> _clients[n];</span><br><span class="line">_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(客户端连接* client)</span><span class="comment">//处理数据 </span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="comment">//接收客户端发送的数据 </span></span><br><span class="line"><span class="type">int</span> recv_len = <span class="built_in">recv</span>(client-&gt;获取<span class="built_in">socket</span>(), 接收缓冲区, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(recv_len &lt;= <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"与服务器断开连接,任务结束\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">} </span><br><span class="line"><span class="number">1.</span>将接收缓冲区的数据拷贝到传入对象的消息缓冲区 client-&gt;获取缓冲区();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">2.</span>判断消息缓冲区的数据长度是否大于等于包头长度) client-&gt;获取缓冲区长度();</span><br><span class="line">{</span><br><span class="line"><span class="number">3.</span>选出包头数据 <span class="comment">//解决粘包问题</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">4.</span>判断消息缓冲区内数据长度是否大于等于报文长度) <span class="comment">//解决少包问题 </span></span><br><span class="line">{</span><br><span class="line"><span class="number">5.</span>响应数据 </span><br><span class="line"><span class="number">6.</span>将处理过的消息移出消息缓冲区 client-&gt;设置缓冲区长度();</span><br><span class="line">} </span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h1 id="七、多线程分离业务处理高负载"><a href="#七、多线程分离业务处理高负载" class="headerlink" title="七、多线程分离业务处理高负载"></a>七、多线程分离业务处理高负载</h1><h2 id="1-思路与准备"><a href="#1-思路与准备" class="headerlink" title="1. 思路与准备"></a>1. 思路与准备</h2><ul><li><p><strong>客户端多线程改造</strong></p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201218163531660.png?raw=true" alt="多线程客户端"></p><p>客户端多线程分组发送消息，尽可能提升发送频率，模拟大规模客户端并发连接，并发数据消息。之前的方法是在<strong>主线程中建立1000个客户端</strong>，然后进行连接和发送消息。现在<strong>创立四个线程，然后将1000个客户端分散到四个线程中</strong>，每个线程处理250个从而减轻压力，并且提升速度。</p></li><li><p><strong>服务端多线程改造</strong></p><p>之前的服务端思路为：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立socket</span><br><span class="line"><span class="number">2.</span>绑定端口IP</span><br><span class="line"><span class="number">3.</span>监听端口</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="number">4.</span>使用select函数获取存在待监听事件的socket</span><br><span class="line"><span class="number">5.</span>如果有新的连接则与新的客户端连接</span><br><span class="line"><span class="number">6.</span>如果有待监听事件，则对其进行处理(接受与发送)</span><br><span class="line">}</span><br><span class="line"><span class="number">7.</span>关闭socket</span><br></pre></td></tr></tbody></table></figure><p>但是，这样的架构在select处理事件较多时，很容易效率低下。对于这类问题，我们可以引入<strong>生产者与消费者模式</strong>，来处理此类并发问题。<br><strong>主线程为生产者线程，用来处理新客户端加入事件，把新客户端分配至消费者线程中</strong>。<strong>消费者线程便是建立的新线程，专门用来处理客户端发送的报文</strong>。这样就实现了事件处理的分离，从而使服务端处理效率更高。当过多客户端同时涌入时，可以更快的建立连接(因为有专门的线程用来处理这一事件)；而当客户端发送报文频率很快时，多线程处理报文也会大大提高效率。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201218164714164.png?raw=true" alt="多线程服务端"></p><p>所以首先需要新建一个<strong>线程类</strong>，用来封装关于<strong>消费者线程</strong>的内容，从而建立多线程架构。随后，在本次的改进中，<strong>加入计时器用来统计数据以及显示数据</strong>，主要需要统计的数据为：<strong>当前客户端连接数量、数据包的每秒接收数量</strong>。同时<strong>对报文类型进行了分离</strong>，把报文类型放在单独的头文件里，这样既方便更改也方便引用。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201218165300642.png?raw=true" alt="引入消息多列"></p><p><strong>缓冲区作用：</strong></p><p>​生产者把数据放入缓冲区，而消费者从缓冲区取出数据。 生产者和消费者只依赖缓冲区，而不互相依赖 ，支持并发和异步 。</p></li></ul><h2 id="2-基于chrono库的高精度计时器"><a href="#2-基于chrono库的高精度计时器" class="headerlink" title="2. 基于chrono库的高精度计时器"></a>2. 基于chrono库的高精度计时器</h2><p>C++11中新引入了<strong>std::chrono库</strong>，由此可以较为容易的实现一个计时器。同时，<strong>休眠操作</strong>也可以通过这个库来实现，从而使代码有良好的跨平台性，避免使用Windows/Linux的系统休眠函数，同时引入该计时器可以<strong>实现对每秒收包、连接等数据的计数显示</strong>。</p><ul><li><p><strong>简易的计时器类</strong>（CELLTimestamp.hpp)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CELLTimestamp_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CELLTimestamp_hpp_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CELLTimestamp</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CELLTimestamp</span>()</span><br><span class="line">{</span><br><span class="line"><span class="built_in">update</span>();</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">CELLTimestamp</span>()</span><br><span class="line">{</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_begin = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取当前秒</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getElapsedSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getElapsedTimeInMicroSec</span>() * <span class="number">0.000001</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获取毫秒</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getElapsedTimeInMilliSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">getElapsedTimeInMicroSec</span>() * <span class="number">0.001</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获取微秒</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">getElapsedTimeInMicroSec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">duration_cast</span>&lt;microseconds&gt;(high_resolution_clock::<span class="built_in">now</span>() - _begin).<span class="built_in">count</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">time_point&lt;high_resolution_clock&gt; _begin;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>基于chrono库的休眠</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//休眠一毫秒 </span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3-多线程的代码实现"><a href="#3-多线程的代码实现" class="headerlink" title="3. 多线程的代码实现"></a>3. 多线程的代码实现</h2><ul><li><p><strong>新建子线程类</strong>（CELLSever.hpp)</p><p>其中包含的基础方法以及相关变量如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellServer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造 </span></span><br><span class="line"><span class="built_in">CellServer</span>(SOCKET sock = INVALID_SOCKET);</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">CellServer</span>();</span><br><span class="line"><span class="comment">//关闭socket </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RecvData</span><span class="params">(ClientSocket *t_client)</span></span>;</span><br><span class="line"><span class="comment">//响应数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetMsg</span><span class="params">(DataHeader *head,SOCKET temp_socket)</span></span>;</span><br><span class="line"><span class="comment">//增加客户端 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addClient</span><span class="params">(ClientSocket* client)</span></span>;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//获取该线程内客户端数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetClientCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">//缓冲区相关 </span></span><br><span class="line"><span class="function">char *_Recv_buf;</span><span class="comment">//接收缓冲区 </span></span><br><span class="line"><span class="comment">//socket相关 </span></span><br><span class="line">SOCKET _sock; </span><br><span class="line"><span class="comment">//正式客户队列 </span></span><br><span class="line">std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line"><span class="comment">//客户缓冲区队列</span></span><br><span class="line">std::vector&lt;ClientSocket*&gt; _clientsBuf; </span><br><span class="line">std::mutex _mutex;<span class="comment">//锁</span></span><br><span class="line"><span class="comment">//线程 </span></span><br><span class="line">std::thread* _pThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::atomic_int _recvCount;<span class="comment">//接收包的数量 </span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>处理思路如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">线程外：</span><br><span class="line"><span class="built_in">Start</span>() 首先调用该方法启动线程</span><br><span class="line"></span><br><span class="line">新客户端加入：</span><br><span class="line"><span class="built_in">GetClientCount</span>() 首先主线程使用这个方法获取各个线程内客户端数量</span><br><span class="line"><span class="comment">//这个添加客户端的方法内涉及到临界区，需要上锁</span></span><br><span class="line"><span class="built_in">addClient</span>(ClientSocket* client) 主线程找到客户端数量最少的线程，使用该线程添加客户端至缓冲队列</span><br><span class="line"></span><br><span class="line">线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()<span class="comment">//运行线程</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">IsRun</span>())<span class="comment">//判断是否工作中</span></span><br><span class="line">{</span><br><span class="line"><span class="number">1.</span>将缓冲队列中的客户数据加入正式队列</span><br><span class="line"><span class="number">2.</span>正式客户队列为空的话，<span class="keyword">continue</span>本次循环</span><br><span class="line"><span class="number">3.</span>select选择出待处理事件，错误的话就关闭所有连接<span class="built_in">CloseSocket</span>()</span><br><span class="line"><span class="number">4.</span>对待处理事件进行接收<span class="built_in">RecvData</span>()，接收包的数量加一，随后处理<span class="built_in">NetMsg</span>()</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>服务端主线程类的更改</strong>（EasyTcpServer.hpp)</p><p>由于处理事件都改为在子线程中，所以主线程中不需要处理报文消息，所以类中接收消息和处理消息的方法都可以删除了。同时我们加入<code>Start</code>方法用来启动子线程，加入<strong>time4msg()方法用来显示子线程中的客户端数量、每秒收包数等数据</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EasyTcpServer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造 </span></span><br><span class="line"><span class="built_in">TcpServer</span>();</span><br><span class="line"><span class="comment">//析构 </span></span><br><span class="line">~<span class="built_in">TcpServer</span>();</span><br><span class="line"><span class="comment">//初始化socket 返回1为正常 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//绑定IP/端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//接受连接</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//添加客户端至服务端  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddClientToServer</span><span class="params">(ClientSocket* pClient)</span></span>;</span><br><span class="line"><span class="comment">//线程启动 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//关闭socket </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseSocket</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//判断是否工作中 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有待处理消息 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OnRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//显示各线程数据信息 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">time4msg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//socket相关 </span></span><br><span class="line">SOCKET _sock; </span><br><span class="line">std::vector&lt;ClientSocket*&gt; _clients;<span class="comment">//储存客户端</span></span><br><span class="line">std::vector&lt;CellServer*&gt; _cellServers;<span class="comment">//子线程们 </span></span><br><span class="line"><span class="comment">//计时器</span></span><br><span class="line">CELLTimestamp _time; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>处理思路如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">调用EasyTcpServer封装类建立服务端的流程：</span><br><span class="line"><span class="number">1.</span><span class="built_in">InitSocket</span>() 建立一个socket</span><br><span class="line"><span class="number">2.B</span>ind(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">unsigned</span> <span class="type">short</span> port) 绑定端口和IP</span><br><span class="line"><span class="number">3.L</span>isten(<span class="type">int</span> n) 监听</span><br><span class="line"><span class="number">4.</span><span class="built_in">Start</span>() 线程启动</span><br><span class="line"><span class="keyword">while</span>(<span class="number">5.</span><span class="built_in">IsRun</span>()) 主线程循环 </span><br><span class="line">{</span><br><span class="line"><span class="number">6.</span><span class="built_in">OnRun</span>() 开始select选择处理事件</span><br><span class="line">}</span><br><span class="line"><span class="number">7.</span><span class="built_in">CloseSocket</span>() 关闭socket</span><br><span class="line"></span><br><span class="line">主线程内：</span><br><span class="line"><span class="built_in">OnRun</span>()</span><br><span class="line">{</span><br><span class="line"><span class="built_in">time4msg</span>()显示数据 </span><br><span class="line">select选择出新客户端加入事件</span><br><span class="line">如果有新客户端加入，调用<span class="built_in">Accept</span>()接受连接</span><br><span class="line"><span class="built_in">Accept</span>()连接成功后，调用<span class="built_in">AddClientToServer</span>(ClientSocket* pClient)分配客户端到子线程中</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddClientToServer</span>()内：</span><br><span class="line">首先调用子线程的<span class="built_in">GetClientCount</span>()方法获取各条子线程中的客户端数量</span><br><span class="line">随后调用子线程的<span class="built_in">addClient</span>(ClientSocket* client)方法，把新客户端添加至客户端最少的线程中</span><br><span class="line"></span><br><span class="line"><span class="built_in">time4msg</span>()内：</span><br><span class="line">首先<span class="built_in">GetSecond</span>()获取计时器的计时</span><br><span class="line">如果大于一秒，就统计客户端的情况：子线程内_recvCount为收包数，主线程内_clients.<span class="built_in">size</span>()获取客户端数量</span><br><span class="line">显示后<span class="built_in">UpDate</span>()重置计时器，并且重置收包数，从而达到统计每秒收包数的作用</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>引入接口类，实现子线程向主线程通信</strong>（INetEvent.hpp）</p><p>子线程对象是在主线程Start()方法被创建的，随后被加入容器_cellServers储存。这就导致主线程中可以调用子线程类中的方法与成员变量，但是<strong>子线程中却无法调用主线程的方法与成员变量</strong>。从而导致<strong>当子线程中有客户端退出时，主线程无法了解</strong>。对于这种情况，我们可以<strong>创建一个接口，让主线程类继承这个接口，子线程即可通过这个接口调用主线程中的特定方法</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">INetEvent</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//有客户端退出 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>首先是主线程类继承该接口：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasyTcpServer</span> : <span class="keyword">public</span> INetEvent</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>随后实现接口中的虚方法：</span><br><span class="line"><span class="comment">//客户端退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnLeave</span><span class="params">(ClientSocket* pClient)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//找到退出的客户端 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;_clients.<span class="built_in">size</span>(); n++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(_clients[n] == pClient)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>() + n;</span><br><span class="line"><span class="keyword">if</span>(iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">{</span><br><span class="line">_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">} </span><br><span class="line">即可实现调用该方法，移除客户端容器中指定客户端</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>随后在子线程类中添加私有成员变量： </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">INetEvent* _pNetEvent; </span><br><span class="line">创建接口对象</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>子线程内创建方法，让接口对象指向主线程类</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setEventObj</span><span class="params">(INetEvent* event)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_pNetEvent = event; </span><br><span class="line">}</span><br><span class="line">event传进去主线程即可，接口对象即指向主线程</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>主线程创建、启动子线程类时，调用该方法，传入自身<span class="keyword">this</span></span><br><span class="line">子线程对象-&gt;<span class="built_in">setEventObj</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>随后即可通过子线程调用主线程的<span class="built_in">OnLeave</span>()方法删除客户端</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnLeave</span>(要删除的客户端);</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="八、对select网络模型进行优化"><a href="#八、对select网络模型进行优化" class="headerlink" title="八、对select网络模型进行优化"></a>八、对select网络模型进行优化</h1><h2 id="1-思路与流程"><a href="#1-思路与流程" class="headerlink" title="1. 思路与流程"></a>1. 思路与流程</h2><ul><li><p>获取一到三个fd_set集合，获取一个timeval</p></li><li><p>select函数对fd_set集合进行选择筛选</p></li><li><p>FD_ISSET函数依据fd_set集合遍历查找待处理事件</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINSOCK_API_LINKAGE <span class="type">int</span> WSAAPI <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nfds,<span class="comment">//是指待监听集合里的范围 即待监听数量最大值+1</span></span></span></span><br><span class="line"><span class="params"><span class="function">fd_set *readfds,<span class="comment">//待监听的可读文件集合 </span></span></span></span><br><span class="line"><span class="params"><span class="function">fd_set *writefds,<span class="comment">//待监听的可写文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function">fd_set *exceptfds,<span class="comment">//待监听的异常文件集合  </span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> PTIMEVAL timeout)</span></span>;<span class="comment">//超时设置 传入NULL为阻塞模式 传入timeval结构体为非阻塞模式</span></span><br><span class="line"></span><br><span class="line">返回值为满足条件的待监听socket数量和，如果出错返回<span class="number">-1</span>，如果超时返回<span class="number">0</span>。</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="2-对fd-set的优化"><a href="#2-对fd-set的优化" class="headerlink" title="2. 对fd_set的优化"></a>2. 对fd_set的优化</h2><p>之前，我们每进行一次select操作，都要使用循环把所有的已连接socket放到fd_set集合中，随后进行选择操作。但是当连接数很大、select操作频繁时，不断的新建fd_set并用循环放入socket，很明显会大大增大系统的消耗。<br>由于fd_set集合中一定存放的是当前所有的socket，由此，我们可以<strong>建立两个fd_set集合与一个bool变量</strong>。<strong>bool变量用来表示socket的组成是否发生了变化</strong>，当有客户端加入或断开时，该变量为true，否则为false。<br>我们使用一个fd_set集合储存”老的”socket集合，当socket集合没有发生变化时，我们另一个<strong>新fd_set集合直接使用memcpy函数复制老集合中的内容</strong>，从而避免从头循环放入。当socket集合发生变化时，新集合直接循环从头录入，随后老集合使用memcpy函数把新集合内的内容复制过去，方便下一次使用。<br>这样，我们即可大大减少关于fd_set集合初始化的消耗。</p><h2 id="3-对select函数的优化"><a href="#3-对select函数的优化" class="headerlink" title="3. 对select函数的优化"></a>3. 对select函数的优化</h2><p>当前代码只对read可读集合进行操作，并没有write可写集合与except异常集合的操作，所以select目前第三、第四个参数都传了空。这样可以增加一点select的效率。因为select函数被封装了，目前来看应该没法做进一步的优化，可能以后会有吧。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span>(_sock+<span class="number">1</span>,&amp;fdRead,<span class="number">0</span>,<span class="number">0</span>,&amp;<span class="type">s_t</span>); </span><br></pre></td></tr></tbody></table></figure><h2 id="4-对FD-ISSET的优化"><a href="#4-对FD-ISSET的优化" class="headerlink" title="4. 对FD_ISSET的优化"></a>4. 对FD_ISSET的优化</h2><p>这是select架构里最消耗资源的部分，当socket连接数很大时，显而易见的是这种<strong>O(N^2)<strong>的查询方法会极大的消耗资源。对此我们可以引入</strong>map</strong>加快查找操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;socket,Client&gt; _clients;</span><br></pre></td></tr></tbody></table></figure><p>socket当键，客户端对象当值。根据select处理后的fd_set集合内的socket进行查找。效率提高为**O(logN)**。</p><h1 id="九、消息接收与发送分离"><a href="#九、消息接收与发送分离" class="headerlink" title="九、消息接收与发送分离"></a>九、消息接收与发送分离</h1><h2 id="1-思路与流程-1"><a href="#1-思路与流程-1" class="headerlink" title="1. 思路与流程"></a>1. 思路与流程</h2><p>在之前第七部分的多线程分离业务处理高负载中，将业务处理相关内容从主线程中分离，大大提高了服务端的效率。随着服务端的进一步完善，把各个模块进行分离，从而使代码的结构更加便于修改与完善，同时也可以提高代码的运行效率。</p><p>大致思路如下：<strong>处理事件线程 &gt;&gt; 发送线程缓冲区 &gt;&gt; 发送线程</strong>。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20210221123454584.png?raw=true" alt="分离消息收发架构"></p><p>新建业务子线程时创建一条发送子线程。其中由<strong>主线程创建子线程对象</strong>，子线程对象中包含两条子线程，<strong>一条为业务子线程，一条为发送子线程</strong>。这样两条线程可以在一个对象中进行相关操作，便于实现。同时，<strong>主线程只需声明一个对象即可，封装性良好且低耦合</strong>。<br>在业务线程需要发送消息时，首先创建一个消息发送对象，其中包含发送的目标和内容。随后把该对象加入缓冲区。在发送线程中，首先把缓冲区内的对象提取到正式发送队列中，随后把正式发送队列中的待发送事件挨个进行处理即可。</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><ul><li><p><strong>发送线程类</strong>(CELLTask.hpp)</p><p>新建两个类，<strong>一个是发送任务基类，一个是发送线程类</strong>。<br>发送任务基类中，含有一个<strong>虚方法DoTask()用来执行发送任务</strong>。该方法在服务端源码中被重载。<br>发送线程类中，含有一条发送线程，同时有一个Start()方法用来启动该线程。含有两条链表，<strong>一条为缓冲区链表，一条为正式消息链表</strong>，同时有一个<strong>addTask()方法用来把消息任务加入缓冲区</strong>。线程执行<strong>OnRun()方法把缓冲区中的任务加入正式队列并执行该任务的DoTask()方法</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CELL_Task_hpp_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CELL_Task_hpp_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTask</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//执行任务 </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span> </span>= <span class="number">0</span>; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellTaskServer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CellTaskServer</span>()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CellTaskServer</span>()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(CellTask* ptask)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line">_tasksBuf.<span class="built_in">push_back</span>(ptask);</span><br><span class="line">} </span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::mem_fn(&amp;CellTaskServer::OnRun),<span class="keyword">this</span>)</span></span>; </span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//工作函数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//将缓冲区内数据加入 </span></span><br><span class="line"><span class="keyword">if</span>(!_tasksBuf.<span class="built_in">empty</span>())<span class="comment">//不为空 </span></span><br><span class="line">{</span><br><span class="line">std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(_mutex);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pTask : _tasksBuf)</span><br><span class="line">{</span><br><span class="line">_tasks.<span class="built_in">push_back</span>(pTask);</span><br><span class="line">} </span><br><span class="line">_tasksBuf.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果无任务</span></span><br><span class="line"><span class="keyword">if</span>(_tasks.<span class="built_in">empty</span>())</span><br><span class="line">{</span><br><span class="line"><span class="comment">//休息一毫秒 </span></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(t);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pTask:_tasks)</span><br><span class="line">{</span><br><span class="line">pTask-&gt;<span class="built_in">DoTask</span>();</span><br><span class="line"><span class="keyword">delete</span> pTask;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//清空任务 </span></span><br><span class="line">_tasks.<span class="built_in">clear</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//任务数据 </span></span><br><span class="line">std::list&lt;CellTask*&gt;_tasks;</span><br><span class="line"><span class="comment">//任务数据缓冲区 </span></span><br><span class="line">std::list&lt;CellTask*&gt;_tasksBuf;</span><br><span class="line"><span class="comment">//锁 锁数据缓冲区 </span></span><br><span class="line">std::mutex _mutex; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>其中的缓冲区加入操作涉及到临界操作，所以加个自解锁。</li><li>因为缓冲区以及正式队列涉及到频繁进出，所以用的是链表<code>list</code>。</li><li>当没有发送任务时，会进行一毫秒的休息，防止消耗太多的内存。</li></ul></li><li><p><strong>主文件重写DoTask</strong>(CELLSendMsgTask)</p><p>在导入上述CELLTask.hpp头文件后，需要重载DoTask方法，从而实现把主文件内的相关类型数据进行发送。<br>可以创建一个新类，使它继承CELLTask任务基类。其中导入主文件内的相关类型。例如下面的例子中就导入了ClientSocket客户端类与DataHeader报文结构体。同时重写了DoTask方法，使其调用ClientSocket客户端类的SendData方法发送报文。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络消息发送任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellSendMsgTask</span> : <span class="keyword">public</span> CellTask</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CellSendMsgTask</span>(ClientSocket* pClient,DataHeader* pHead)</span><br><span class="line">{</span><br><span class="line">_pClient = pClient;</span><br><span class="line">_pHeader = pHead;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_pClient-&gt;<span class="built_in">SendData</span>(_pHeader);</span><br><span class="line"><span class="keyword">delete</span> _pHeader;</span><br><span class="line">}  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ClientSocket* _pClient;</span><br><span class="line">DataHeader* _pHeader;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>而想要发送报文时，只需要新建上述<code>CELLSendMsgTask</code>对象，并调用<code>CELLTaskServer</code>任务线程类的<code>addTask</code>方法添加至发送队列即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向 pClient 客户端发送 pHead 报文</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSendTask</span><span class="params">(ClientSocket* pClient,DataHeader* pHead)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">CellSendMsgTask* ptask = <span class="keyword">new</span> <span class="built_in">CellSendMsgTask</span>(pClient,pHead);</span><br><span class="line">_taskServer.<span class="built_in">addTask</span>(ptask);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="十、内存池设计与实现"><a href="#十、内存池设计与实现" class="headerlink" title="十、内存池设计与实现"></a>十、内存池设计与实现</h1><h2 id="1-内存池设计思路"><a href="#1-内存池设计思路" class="headerlink" title="1. 内存池设计思路"></a>1. 内存池设计思路</h2><p>为什么要使用内存池？我是这样理解的：不断的使用new/malloc从堆中申请内存，会在内存中留下一些碎片。例如我们申请三份8个字节大小的内存A、B、C，由于内存地址是连续的，则ABC的地址值每个相差8(正常情况)。此时我们delete/free掉B内存，A与C内存之间此时就有了8个字节的空白。假如我们今后申请的内存都比8个字节大，则A与C之间这块内存就会一直为空白，这就是内存碎片。<br>过多的内存碎片会影响程序的内存分配效率，为了降低内存碎片的影响，我们可以引入内存池来尝试解决它。</p><p>在程序启动时(或是其他合适的时机)，预先申请足够的、大小相同的内存，把这些内存放在一个容器内。在需要申请内存时，直接从容器中取出一块内存使用；而释放内存时，把这块内存放回容器中即可。这个容器就被称为内存池。而这样操作也可以大大减少内存碎片出现的可能性，提高内存申请/释放的效率。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20210228213013636.png?raw=true" alt="内存池设计思路"></p><p>需要新建三个类：</p><ul><li>首先是底层的内存块类，其中包含了该内存块的信息<strong>：内存块编号、引用情况、所属内存池、下一块的位置</strong>等。</li><li>其次是内存池类，它<strong>对成组的内存块进行管理</strong>，可以实现把内存块从内存池中取出以及把内存块放回内存池。</li><li>最后是内存管理工具类，其中包含一个或多个内存池，所以它要<strong>根据用户申请的内存大小找到合适的内存池</strong>，调用内存池类的方法申请/释放内存。</li></ul><p>需要重载的函数：</p><ul><li>对<code>new/delete</code>进行重载，使其直接调用内存管理工具类申请/释放内存。</li></ul><p>上面的工作完成后，虽然仍是以<code>new/delete</code>来申请/释放内存，但是已经是通过内存池来实现的了。</p><h2 id="2-底层内存块类MemoryBlock的设计与实现"><a href="#2-底层内存块类MemoryBlock的设计与实现" class="headerlink" title="2. 底层内存块类MemoryBlock的设计与实现"></a>2. 底层内存块类MemoryBlock的设计与实现</h2><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20210228215549586.png?raw=true" alt="内存块MemoryBlock设计"></p><p>首先，在内存池中每一块内存是由一个内存头以及其可用内存组成的，其中<strong>内存头</strong>里储存了这块内存的相关信息，<strong>可用内存</strong>即为数据域，类似链表中节点的结构。而一块块内存之间正是一种类似链表的结构，即通过内存头中的一个指针进行连接。内存头中包含的信息大概如下：</p><ul><li><strong>内存块编号</strong></li><li><strong>引用情况</strong></li><li><strong>所属内存池</strong></li><li><strong>下一块位置</strong></li><li><strong>是否在内存池内</strong></li></ul><p>通过上面的思路新建内存块类<code>MemoryBlock</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">由于内存头中要标记所属内存池，所以我们先预声明内存池类，在之后再进行实现。</span><br><span class="line">建立完成后，内存池内一块内存的大小为：<span class="built_in">sizeof</span>(MemoryBlock) + 可用内存的大小</span><br><span class="line"></span><br><span class="line"><span class="comment">//预声明内存池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span>;</span><br><span class="line"><span class="comment">//内存块类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryBlock</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//内存块编号</span></span><br><span class="line"><span class="type">int</span> _nID;</span><br><span class="line"><span class="comment">//引用情况</span></span><br><span class="line"><span class="type">int</span> _nRef;</span><br><span class="line"><span class="comment">//所属内存池</span></span><br><span class="line">MemoryAlloc* _pAlloc;</span><br><span class="line"><span class="comment">//下一块位置</span></span><br><span class="line">MemoryBlock* _pNext;</span><br><span class="line"><span class="comment">//是否在内存池内</span></span><br><span class="line"><span class="type">bool</span> _bPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="3-中间件内存池类MemoryAlloc的设计与实现"><a href="#3-中间件内存池类MemoryAlloc的设计与实现" class="headerlink" title="3. 中间件内存池类MemoryAlloc的设计与实现"></a>3. 中间件内存池类MemoryAlloc的设计与实现</h2><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20210228222838762.png?raw=true" alt="内存池类MemoryAlloc设计"></p><p>由图可知，整个内存池的管理基本为<strong>链表结构</strong>，内存池对象一直指向头部内存单元。在<strong>申请内存时移除头部单元</strong>，类似链表头结点的移除；在<strong>释放内存时，类似链表的头插法，把回收回来的内存单元放在内存池链表的头部</strong>。</p><ul><li><p><strong>MemoryAlloc类内成员：</strong></p><ul><li><p><strong>成员方法</strong></p><ul><li>成员变量初始化 —— 对内存单元可用内存大小以及内存单元数量进行设定</li><li>初始化 —— 依据内存单元的大小与数量，对内存池内的内存进行malloc申请，完善每一个内存单元的信息</li><li>申请内存 —— 从内存池链表中取出一块可用内存</li><li>释放内存 —— 将一块内存放回内存池链表中</li></ul></li><li><p><strong>成员变量</strong></p><ul><li>内存池地址 —— 指向内存池内的总内存</li><li>头部内存单元 —— 指向头部内存单元</li><li>内存块大小 —— 内存单元的可用内存大小</li><li>内存块数量 —— 内存单元的数量</li></ul></li></ul></li></ul><p>通过上面的思路新建内存块类<code>MemoryAlloc</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入内存块头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"MemoryBlock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAlloc</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MemoryAlloc</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">MemoryAlloc</span>();</span><br><span class="line"><span class="comment">//设置初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setInit</span><span class="params">(<span class="type">size_t</span> nSize,<span class="type">size_t</span> nBlockSize)</span></span>;<span class="comment">//传入的为内存块可用内存大小和内存块数量</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initMemory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;<span class="comment">//传入的为申请可用内存的大小</span></span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//内存池地址</span></span><br><span class="line"><span class="type">char</span>* _pBuf;</span><br><span class="line"><span class="comment">//头部内存单元</span></span><br><span class="line">MemoryBlock* _pHeader;</span><br><span class="line"><span class="comment">//内存块大小</span></span><br><span class="line"><span class="type">size_t</span> _nSize;</span><br><span class="line"><span class="comment">//内存块数量</span></span><br><span class="line"><span class="type">size_t</span> _nBlockSize;</span><br><span class="line"><span class="comment">//多线程锁</span></span><br><span class="line">std::mutex _mutex;<span class="comment">//锁上申请内存方法和释放内存方法即可实现多线程操作</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="4-顶层内存管理工具类MemoryMgr的实际与实现"><a href="#4-顶层内存管理工具类MemoryMgr的实际与实现" class="headerlink" title="4. 顶层内存管理工具类MemoryMgr的实际与实现"></a>4. 顶层内存管理工具类MemoryMgr的实际与实现</h2><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20210228230825518.png?raw=true" alt="内存管理类MemoryMgr设计"></p><p>内存管理工具类用的是<strong>单例模式</strong>，从而能简易的对内存池进行管理。在这次的实现里，使用的是<strong>饿汉式</strong>单例对象。其次，为了更简单的判断出申请内存时所需要调用的内存池，<strong>建立了一个数组映射内存池</strong>。在工具类构造函数内，首先是对内存池进行初始化，随后便是将其映射到数组上。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">映射：</span><br><span class="line">假如申请一个<span class="number">64</span>字节内存池，申请一个<span class="number">128</span>字节内存池</span><br><span class="line">新建一个指针数组test，使下标<span class="number">0</span>~<span class="number">64</span>指向<span class="number">64</span>字节内存池，下标<span class="number">65</span>~<span class="number">128</span>指向<span class="number">128</span>字节内存池</span><br><span class="line">则我们通过 test[要申请的内存大小] 即可确定合适的内存池</span><br></pre></td></tr></tbody></table></figure><p>在随后的申请过程中，我们首先判断申请内存大小是否超过内存池最大可用内存，若没超过，则通过映射数组指向的内存池进行内存申请；<strong>若超过了，则直接使用malloc申请</strong>，记得多申请一个内存头大小的内存。随后完善内存头内的资料。<br>在随后的释放过程中，我们<strong>通过内存头判断这块内存是否使属于内存池的内存</strong>，如果是，则通过其所属内存池进行内存回收；若不是，则直接进行free释放。</p><ul><li><p><strong>MemoryMgr类内成员：</strong></p><ul><li><p><strong>成员方法</strong></p><ul><li>饿汉式单例模式 —— 调用返回单例对象</li><li>申请内存 —— 调用获取一块内存</li><li>释放内存 —— 调用释放一块内存</li><li>内存初始化 —— 将内存池映射到数组上</li></ul></li><li><p>成员变量</p><ul><li>映射数组 —— 映射内存池</li><li>内存池1</li><li>内存池2</li><li>……</li></ul></li></ul></li></ul><p>通过上面的思路新建内存管理工具类<code>MemoryMgr</code>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存池最大申请</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEMORY_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入内存池模板类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"MemoryAlloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryMgr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//饿汉式单例模式</span></span><br><span class="line"><span class="function"><span class="type">static</span> MemoryMgr* <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">allocMem</span><span class="params">(<span class="type">size_t</span> nSize)</span></span>;</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeMem</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">MemoryMgr</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">MemoryMgr</span>();</span><br><span class="line"><span class="comment">//内存映射初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_szAlloc</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end,MemoryAlloc* pMem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//映射数组</span></span><br><span class="line">MemoryAlloc* _szAlloc[MAX_MEMORY_SIZE + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//64字节内存池</span></span><br><span class="line">MemoryAlloc _mem64;</span><br><span class="line"><span class="comment">//128字节内存池</span></span><br><span class="line">MemoryAlloc _mem128;</span><br><span class="line"><span class="comment">//内存池...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="5-重载new-delete函数"><a href="#5-重载new-delete函数" class="headerlink" title="5. 重载new/delete函数"></a>5. 重载new/delete函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mem_alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;<span class="comment">//malloc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mem_free</span><span class="params">(<span class="type">void</span>* p)</span></span>;<span class="comment">//free</span></span><br></pre></td></tr></tbody></table></figure><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><ul><li>在申请与释放内存时，返回给用户和用户传进来的都是可用内存的地址，并不是内存头的地址。我们需要<strong>对地址进行偏移</strong>，从而返回/接收正确的地址。具体为可用内存地址向前偏移一个内存头大小即为内存头地址；内存头地址向后偏移一个内存头大小即为可用内存地址。</li><li>内存池初始化时，<strong>申请总地址大小为：(可用地址大小+内存头大小) * 内存单元数量</strong><br>内存池外申请的内存，不会在内存池析构函数内被释放，需要手动释放。（不过一般触发析构函数的时候，也不用手动释放了）</li></ul><h1 id="十一、对象池的设计与实现"><a href="#十一、对象池的设计与实现" class="headerlink" title="十一、对象池的设计与实现"></a>十一、对象池的设计与实现</h1><h2 id="1-对象池的设计思路"><a href="#1-对象池的设计思路" class="headerlink" title="1. 对象池的设计思路"></a>1. 对象池的设计思路</h2><ul><li><p><strong>什么是对象池</strong></p><p>对象池是一种<strong>空间换时间</strong>的技术，对象被预先创建并初始化后放入对象池中，对象提供者就能利用已有的对象来处理请求，并在不需要时归还给池子而非直接销毁它减少对象频繁创建所占用的内存空间和初始化时间</p></li><li><p><strong>对象池需要具备的四个基本函数</strong></p><p>重载new/delete函数、创建和销毁对象。</p></li><li><p><strong>对象池的优点</strong></p><ul><li><p>减少频繁创建和销毁对象带来的成本，实现对象的缓存和复用</p></li><li><p>提高了获取对象的响应速度，对实时性要求较高的程序有很大帮助</p></li></ul></li><li><p><strong>对象池的缺点</strong></p><ul><li><p>很难设定对象池的大小，如果太小则不起作用，过大又会占用内存资源过高</p></li><li><p>并发环境中, 多个线程可能同时需要获取池中对象, 进而需要在堆数据结构上进行同步或者<br>因为锁竞争而产生阻塞, 这种开销要比创建销毁对象的开销高数百倍;</p></li><li><p>由于池中对象的数量有限, 势必成为一个可伸缩性瓶颈;</p></li><li><p>所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。<br>脏对象可能带来两个问题：</p><ul><li>脏对象持有上次使用的引用，导致内存泄漏等问题；</li><li>脏对象如果下一次使用时没有做清理，可能影响程序的处理数据。</li></ul></li></ul></li><li><p><strong>对象池和内存池的差异</strong>。</p><ul><li><p>内存池主要是管理大量的内存分配和释放操作，将频繁的内存分配和释放操作合并为少量的内存池的初始化和释放操作，提高了内存分配效率。它可以避免频繁地进行内存分配，减少了内存碎片的产生，提高了程序的运行效率。内存池适用于那些需要经常分配内存的场合，比如说网络服务器、数据库等。</p></li><li><p>对象池则是一种特殊的内存池，主要用于管理大量的小对象的分配和释放操作。对象池的优点在于，它可以大幅度减少小对象的内存分配和释放操作，降低了内存碎片的产生，提高了程序的运行效率。在需要频繁地创建和销毁小对象的场合下，对象池的效果更为明显。</p></li></ul></li></ul><p>各个类的参数种类和数量不确定，该怎么用一个对象池类来创建所有类的对象池呢？答案是使用C++11的<strong>可变参数模板</strong>。</p><h2 id="2-对象池类的设计与实现-CELLObjectPool"><a href="#2-对象池类的设计与实现-CELLObjectPool" class="headerlink" title="2. 对象池类的设计与实现(CELLObjectPool)"></a>2. <strong>对象池类的设计与实现</strong>(CELLObjectPool)</h2><p>对象池内部的实现和内存池基本一样，都是先申请一大块内存空间，然后再把大内存分成许多小内存，每个小内存对应一个对象，这些小内存以链表的形式进行管理。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201231092424374.png?raw=true" alt="对象池构成"></p><p>CELLObjectPool类为对象池的具体实现，包含一个内部类NodeHeader，用于存储对象块的信息，如<strong>下一块位置、内存块编号、引用次数和是否在内存池中</strong>等。该类还包含两个主要的方法：allocObjMemory()和freeObjMemory()，分别用于申请对象内存和释放对象内存，内部使用了<strong>互斥锁</strong>来保证线程安全。</p><ul><li><strong>NodeHeader类：</strong>存储对象块的信息。</li><li>**allocObjMemory()**：申请对象内存。</li><li>**freeObjMemory()**：释放对象内存。</li><li>**initPool()**：初始化对象池。</li><li><strong>_pHeader</strong>：指向内存块的头节点。</li><li><strong>_pBuf：</strong>对象池内存缓存区地址。</li><li><strong>_mutex：</strong>互斥锁，保证线程安全。</li></ul><h2 id="3-对象池管理类的设计与实现-ObejectPoolBase"><a href="#3-对象池管理类的设计与实现-ObejectPoolBase" class="headerlink" title="3. 对象池管理类的设计与实现(ObejectPoolBase)"></a><strong>3. 对象池管理类的设计与实现(ObejectPoolBase)</strong></h2><p>内存池的管理主要是对用户提供接口，参数的传递通过可变参的模板类来实现，对new和delete操作进行封装是为了更方便的初始化对象，让使用时更加灵活；要创建不同类型的对象池，只需要继承ObjectPoolBase这个类就可以，当发现该类型对应的对象池没有初始化的时候，就会创建该对象池并且进行初始化操作，之后就可以正常分配对象。</p><p><img src="https://github.com/AutinC/EasyTcpServer/blob/main/MySocket/images/20201231092545415.png?raw=true" alt="对象池管理类构成"></p><p>ObjectPoolBase类为对象池的接口类，提供了重载new和delete操作符的方法，同时也提供了创建和销毁对象的方法。该类还包含一个<strong>静态成员变量objectPool</strong>，用于保存CELLObjectPool对象的实例，以及一个typedef类型ClassTypePool，用于表示CELLObjectPool类的实例。</p><ul><li><strong>operator new()：</strong>重载new操作符，用于申请对象内存。</li><li><strong>operator delete()：</strong>重载delete操作符，用于释放对象内存。</li><li><strong>createObject()：</strong>创建对象的方法。</li><li><strong>destroyObject()：</strong>销毁对象的方法。</li><li><strong>objectPool()：</strong>静态CELLObjectPool对象，用于保存CELLObjectPool对象的实例。</li></ul><h2 id="4-智能指针与对象池"><a href="#4-智能指针与对象池" class="headerlink" title="4. 智能指针与对象池"></a>4. 智能指针与对象池</h2><p>对象池和内存池可以一起使用，在一起使用的情况下，如果要在对象池中使用智能指针，应该特别注意new操作，因为智能指针使用的是全局的new，内存池使用的是类里面的new，在申请内存时会有差别。</p><p>如果想使用智能指针的同时用到对象池，使用shared_ptr<t> obj(new T())的形式构造，这样对shared_ptr的obj走了内存池的构造，而对象T走了对象池的构造，这样可以把指针对象和用户对象分开申请内存。</t></p><h1 id="十二、心跳检测与定时收发数据"><a href="#十二、心跳检测与定时收发数据" class="headerlink" title="十二、心跳检测与定时收发数据"></a>十二、心跳检测与定时收发数据</h1><p>做以下修改：</p><ul><li>更改服务端中，客户端对象储存的方式，由<strong>vector改为map</strong>。</li><li>改变任务队列中任务储存方式，由<strong>任务基类改为匿名函数</strong>。</li><li>加入<strong>心跳检测</strong>机制，及时剔除未响应客户端。</li><li>加入<strong>定时发送消息</strong>检测机制，及时发送缓冲区内的内容。</li></ul><h2 id="1-更改客户端存储方式"><a href="#1-更改客户端存储方式" class="headerlink" title="1. 更改客户端存储方式"></a>1. 更改客户端存储方式</h2><p>之前服务端程序储存客户端对象ClientSocket的方式是std::<strong>vector</strong><clientsocket>，在select筛选后的fd_set中使用<strong>FD_ISSET函数获取需接收报文的客户端</strong>。<br>但是FD_ISSET函数是使用<strong>for循环</strong>进行暴力检索，消耗较大，我们可以改为使用<strong>std::map::find</strong>进行检索。这样就需要把储存客户端对象的方式改为std::map。因为我们需要通过socket进行查找，所以我把<strong>std::map的键设为SOCKET，值设为客户端对象ClientSocket的指针</strong>，这样我们需要改为std::map&lt;SOCKET,ClientSocket*&gt;。<br>在改变储存数据结构后，若想获取客户端socket，则调用iter-&gt;first；若想获取客户端对象指针，则调用iter-&gt;second；获取已连接客户端数量则还是_clients.size()。<br>在更换数据结构后，通过fdRead.fd_count进行循环，由于linux下fd_set内容与windows下不一致，所以本次要分环境进行检索，代码如下：</clientsocket></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; (<span class="type">int</span>)fdRead.fd_count; n++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">auto</span> iter = _clients.<span class="built_in">find</span>(fdRead.fd_array[n]);</span><br><span class="line"><span class="keyword">if</span> (iter != _clients.<span class="built_in">end</span>())</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">RecvData</span>(iter-&gt;second))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">{</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">closesocket</span>(iter-&gt;first);</span><br><span class="line"><span class="keyword">delete</span> iter-&gt;second;</span><br><span class="line">_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">std::vector&lt;ClientSocket*&gt; ClientSocket_temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(iter-&gt;first, &amp;fdRead))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == <span class="built_in">RecvData</span>(iter-&gt;second))<span class="comment">//处理请求 客户端退出的话 </span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">{</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">}</span><br><span class="line">ClientSocket_temp.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">_clients.<span class="built_in">erase</span>(iter);<span class="comment">//移除</span></span><br><span class="line">_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> client : ClientSocket_temp)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">closesocket</span>(client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line">_clients.<span class="built_in">erase</span>(client-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line"><span class="keyword">delete</span> client;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br></pre></td></tr></tbody></table></figure><h2 id="2-更改任务队列存储方式"><a href="#2-更改任务队列存储方式" class="headerlink" title="2. 更改任务队列存储方式"></a>2. 更改任务队列存储方式</h2><p>之前通过声明了一个抽象任务基类，通过重写基类的DoTask()方法来规定如何执行任务。但是这样利用多态可以执行重写后的任务。但是对于每一个新的任务类型，都需要定义一个新类重写一次DoTask()方法，有点麻烦。所以使用C++11中新引入的<strong>匿名函数</strong>，来更改任务队列的储存方式，定义一个匿名函数类型，使任务内容可以更加灵活。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; CellTask;</span><br><span class="line"><span class="comment">//任务数据 </span></span><br><span class="line">std::list&lt;CellTask&gt;_tasks;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pTask : _tasks)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">pTask</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda式添加匿名函数</span></span><br><span class="line">_tasks.<span class="built_in">push_back</span>([pClient,pHead]() </span><br><span class="line">{</span><br><span class="line">pClient-&gt;<span class="built_in">SendData</span>(pHead);</span><br><span class="line"><span class="keyword">delete</span> pHead;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="3-加入心跳检测机制"><a href="#3-加入心跳检测机制" class="headerlink" title="3. 加入心跳检测机制"></a>3. 加入心跳检测机制</h2><p>心跳检测的前提是存在一个计时器（见第七部分第2节），通过调用 getNowMillSec 方法，返回当前时间戳。这样通过一个变量来储存上一次获取的时间戳，从而可以计算两次获取时间戳之间的时间差，从而实现计时功能。</p><p>在客户端类中定义一个心跳计时变量，并且声明两个相关方法，实现<strong>对心跳计时变量的归零与检测</strong>操作。当心跳计时器超过规定的客户端死亡时间后，<code>CheckHeart</code>方法会返回true告知该客户端已死亡。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端死亡时间 20000毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_HREAT_TIME 20000</span></span><br><span class="line"><span class="comment">//心跳计时器</span></span><br><span class="line"><span class="type">time_t</span> _dtHeart;</span><br><span class="line"><span class="comment">//计时变量归零</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientSocket::ResetDtHeart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_dtHeart = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//dt为时间差 传入两次检测之间的时间差，检测心跳计时器是否超过心跳检测的阈值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClientSocket::CheckHeart</span><span class="params">(<span class="type">time_t</span> dt)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_dtHeart += dt;</span><br><span class="line"><span class="keyword">if</span> (_dtHeart &gt;= CLIENT_HREAT_TIME)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"CheakHeart dead:%d,time=%lld\n"</span>,_sockfd,_dtHeart);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着需要在合适的函数中进行客户端的心跳检测。在子线程的 OnRun 方法中，即对客户端进行 select 操作的方法中，加入 CheckTime 方法，之后对客户端相关的检测操作均在此方法中进行。在 CheckTime 中，我们首先要获取两次 Checktime 之间的时间差，随后<strong>遍历所有客户端对象，挨个使用 CheckHeart 方法进行检测是否超时，若发现超时，则主动断开与该客户端之间的连接</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellServer::CheckTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//获取时间差</span></span><br><span class="line"><span class="type">time_t</span> nowTime = HBtimer::<span class="built_in">getNowMillSec</span>();</span><br><span class="line"><span class="type">time_t</span> dt = nowTime - _oldTime;</span><br><span class="line">_oldTime = nowTime;</span><br><span class="line"><span class="comment">//遍历所有客户端对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>();)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//检测心跳是否超时</span></span><br><span class="line"><span class="keyword">if</span> (iter-&gt;second-&gt;<span class="built_in">CheckHeart</span>(dt) == <span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (_pNetEvent)<span class="comment">//主线程中删除客户端 </span></span><br><span class="line">{</span><br><span class="line">_pNetEvent-&gt;<span class="built_in">OnNetLeave</span>(iter-&gt;second);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">closesocket</span>(iter-&gt;second-&gt;<span class="built_in">GetSockfd</span>());</span><br><span class="line"><span class="keyword">delete</span> iter-&gt;second;</span><br><span class="line">_clients.<span class="built_in">erase</span>(iter++);<span class="comment">//移除</span></span><br><span class="line">_client_change = <span class="literal">true</span>;<span class="comment">//客户端退出 需要通知系统重新录入fdset集合 </span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">iter++;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着是心跳信号，可以在<strong>每次收到客户端报文时都对心跳计时变量归零</strong>，也可以声明单独的心跳报文，当接收到此报文时，重置心跳计时变量。目前采用的方式是前者。</p><h2 id="4-加入定时发送缓存消息机制"><a href="#4-加入定时发送缓存消息机制" class="headerlink" title="4. 加入定时发送缓存消息机制"></a>4. 加入定时发送缓存消息机制</h2><p>之前仅进行了客户端消息<strong>定量发送</strong>功能，即当客户端对象发送缓冲区满后，进行消息的发送。这样当消息发送效率不够高时，很容易造成消息反馈的延迟，于是本次也实现了定时发送的功能。<br>上面实现心跳检测时，已经新建了 CellServer::CheckTime 方法，这个定时发送检测也可以放在这个方法里。思路和心跳检测大同小异，也是在客户端类中定义一个发送计时变量，并且声明两个相关方法，实现<strong>对发送计时变量的归零与检测</strong>操作。<br>当发现需要发送消息时，需要一个方法把客户端对象发送缓冲区内的内容全部发送，并且清空缓冲区(指针归零)，随后重置计时变量。该方法为 ClientSocket::SendAll。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端定时发送时间 200毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_AUTOMATIC_SEND_TIME 200</span></span><br><span class="line"><span class="comment">//定时发送计时器</span></span><br><span class="line"><span class="type">time_t</span> _dtSend;</span><br><span class="line"><span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClientSocket::ResetDtSend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_dtSend = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ClientSocket::CheckSend</span><span class="params">(<span class="type">time_t</span> dt)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_dtSend += dt;</span><br><span class="line"><span class="keyword">if</span> (_dtSend &gt;= CLIENT_AUTOMATIC_SEND_TIME)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//printf("AutomaticSend:%d,time=%lld\n", _sockfd, _dtSend);</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//发送缓冲区内全部消息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClientSocket::SendAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> ret = SOCKET_ERROR;</span><br><span class="line"><span class="keyword">if</span> (_Len_Send_buf &gt; <span class="number">0</span> &amp;&amp; SOCKET_ERROR != _sockfd)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//发送 </span></span><br><span class="line">ret = <span class="built_in">send</span>(_sockfd, (<span class="type">const</span> <span class="type">char</span>*)_Msg_Send_buf, _Len_Send_buf, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//发送后缓冲区归零 </span></span><br><span class="line">_Len_Send_buf = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//重置发送计时器</span></span><br><span class="line"><span class="built_in">ResetDtSend</span>();</span><br><span class="line"><span class="comment">//发送错误 </span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error 发送失败"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellServer::CheckTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//获取时间差</span></span><br><span class="line"><span class="type">time_t</span> nowTime = HBtimer::<span class="built_in">getNowMillSec</span>();</span><br><span class="line"><span class="type">time_t</span> dt = nowTime - _oldTime;</span><br><span class="line">_oldTime = nowTime;</span><br><span class="line"><span class="comment">//遍历所有客户端对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = _clients.<span class="built_in">begin</span>(); iter != _clients.<span class="built_in">end</span>();)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//检测是否到定时发送消息</span></span><br><span class="line"><span class="keyword">if</span> (iter-&gt;second-&gt;<span class="built_in">CheckSend</span>(dt) == <span class="literal">true</span>)</span><br><span class="line">{</span><br><span class="line">iter-&gt;second-&gt;<span class="built_in">SendAll</span>();</span><br><span class="line">iter-&gt;second-&gt;<span class="built_in">ResetDtSend</span>();</span><br><span class="line">}</span><br><span class="line">iter++;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="十三、线程退出安全优化"><a href="#十三、线程退出安全优化" class="headerlink" title="十三、线程退出安全优化"></a>十三、线程退出安全优化</h1><p>做以下修改：</p><ul><li>封装线程类，使其可以控制线程及时关闭</li><li>使得程序可以按合适的顺序正常退出，避免因退出顺序问题引发崩溃</li></ul><h2 id="1-封装线程类"><a href="#1-封装线程类" class="headerlink" title="1. 封装线程类"></a>1. 封装线程类</h2><p>为何要及时使得线程退出？因为<strong>接收、发送线程与主线程是分离的</strong>，当在主线程中析构线程类时，线程中所使用的变量遂被释放，但此时接收、发送线程可能还未从上次循环中结束，仍然在调用已被释放的变量，此时就会出现崩溃等问题。所以需要自己封装一个线程类，来实现对线程退出的控制，使得可以获得线程已经正常退出的信号，从而再安全的释放各种变量。<br>如何实现？首先新建一个bool类型的信号量，<strong>在主线程发出关闭线程信号后，使用while(1)进行阻塞</strong>。<strong>当线程退出时，更改bool信号量的状态</strong>，当while(1)中检测到信号量发生变化后，则跳出循环解除阻塞，正常向下运行释放变量。伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">主线程内：</span><br><span class="line">{</span><br><span class="line">_state = <span class="literal">false</span>;<span class="comment">//线程是否运行</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(_semaphore == <span class="literal">true</span>)<span class="comment">//查看信号量状态</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">释放变量等;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">子线程内:</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(_state)</span><br><span class="line">{</span><br><span class="line">工作;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"线程已退出\n"</span>);</span><br><span class="line">_semaphore = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上，好处是可以确保线程可以按顺序退出，使得释放变量等操作不会出错。但是坏处是这个while(1)循环会占用大量的系统资源，影响程序效率。以及可能出现信号量未能正确变化，从而陷入死循环。首先是<strong>占用资源太多的问题</strong>，我们可以引用C++11中的<strong>condition_variable条件变量</strong>。</p><ul><li><p>C++11中的<code>condition_variable</code>是一个同步原语，它允许线程在特定条件下等待。它通常与<code>std::unique_lock</code>（独占锁）一起使用，以实现线程之间的同步。</p><p><code>condition_variable</code>的主要目的是等待某些事件的发生，这些事件通常由其他线程触发。在等待期间，线程会被阻塞，直到另一个线程通知条件变量，表示该事件已经发生。</p><ul><li><code>condition_variable</code>的基本用法是：<ul><li>创建一个<code>std::condition_variable</code>对象；</li><li>创建一个<code>std::unique_lock</code>对象，用于对共享数据进行加锁；</li><li>在等待事件的线程中，调用<code>wait</code>方法，使线程进入等待状态；</li><li>在其他线程中，当某个事件发生时，调用<code>notify_one</code>或<code>notify_all</code>方法，通知等待的线程；</li><li>当线程被通知后，它将再次获取锁并检查条件，如果条件不满足，则返回步骤3，否则继续执行后续操作。</li></ul></li></ul></li></ul><p>伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span><span class="comment">//条件变量</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable _cv;</span><br><span class="line"></span><br><span class="line">主线程内：</span><br><span class="line">{</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;<span class="comment">//需上锁</span></span><br><span class="line">_state = <span class="literal">false</span>;<span class="comment">//线程是否运行</span></span><br><span class="line">_cv.<span class="built_in">wait</span>(lock);<span class="comment">//阻塞等待</span></span><br><span class="line">释放变量等;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">子线程内:</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span>(_state)</span><br><span class="line">{</span><br><span class="line">工作;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"线程已退出\n"</span>);</span><br><span class="line">_cv.<span class="built_in">notify_one</span>();<span class="comment">//唤醒</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上，阻塞资源消耗太大的问题已经得到了改善，接下来将着重于<strong>如何避免死循环状态</strong>。首先新建信号量类<code>CellSemaphore</code>，对信号量操作进行封装，使得线程类内可以直接调用信号量相关操作。结构如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CellSemaphore</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CellSemaphore</span>();</span><br><span class="line">~<span class="built_in">CellSemaphore</span>();</span><br><span class="line"><span class="comment">//开始阻塞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//等待数</span></span><br><span class="line"><span class="type">int</span> _wait = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//唤醒数</span></span><br><span class="line"><span class="type">int</span> _wakeup = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line">std::condition_variable _cv;</span><br><span class="line"><span class="comment">//锁</span></span><br><span class="line">std::mutex _mutex;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如上，CellSemaphore 封装了 wait 和 wakeup 方法，通过调用这两个方法，即可实现阻塞与唤醒。而成员变量方面，声明了一个等待计数器 wait 和一个唤醒计数器 wakeup。每当成功调用 wakeup 方法，都会使等待计数器和唤醒计数器加一；而每当成功调用 wait 方法，都会使等待计数器和唤醒计数器减一。所以正常情况下，一组操作后，两个计数器的值都为0。而由此也可以判断不同的情况，比如当调用wait方法时，唤醒计数器的值大于0，则说明之前已经进行了唤醒操作，则直接跳过阻塞即可。而当调用wakeup方法时，若等待计数器数值不正常，则也直接跳过唤醒操作。相关代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始阻塞</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellSemaphore::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (--_wait &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//阻塞开始 等待唤醒</span></span><br><span class="line">_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()-&gt;<span class="type">bool</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> _wakeup &gt; <span class="number">0</span>;</span><br><span class="line">});</span><br><span class="line">--_wakeup;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//唤醒</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellSemaphore::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (++_wait &lt;= <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">++_wakeup;</span><br><span class="line">_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由此，信号量相关的封装完成了，接下来将进行线程类相关的封装。首先，线程类中需要有一个 CellSemaphore 信号量对象以便于我们对线程的掌握。其次，线程的基础函数：<strong>启动Start()、关闭Close()、退出Exit()、是否运行isRun()<strong>需要存在。接着，是最重要的线程工作函数</strong>OnWork()<strong>。在工作函数OnWork()中，执行三个匿名函数：</strong>_onCreate、_onRun、 _onDestory</strong>，这三个匿名函数分别执行<strong>线程创建时的操作、线程运行时的操作、线程销毁时的操作</strong>。最后还需要一个锁和一个bool变量来保证数据的正常更改以及线程运行状态的判定。线程类 CellThread 结构如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CellThread</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(CellThread*)&gt; EventCall;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">(EventCall onCreate = <span class="literal">nullptr</span>, EventCall onRun = <span class="literal">nullptr</span>, EventCall onDestory = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="comment">//关闭线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//工作中退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//是否运行中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnWork</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//三个事件 匿名函数</span></span><br><span class="line">EventCall _onCreate;</span><br><span class="line">EventCall _onRun;</span><br><span class="line">EventCall _onDestory;</span><br><span class="line"><span class="comment">//改变数据时 需要加锁</span></span><br><span class="line">std::mutex _mutex;</span><br><span class="line"><span class="comment">//控制线程的终止与退出</span></span><br><span class="line">CellSemaphore _semaphore;</span><br><span class="line"><span class="comment">//线程是否启动</span></span><br><span class="line"><span class="type">bool</span> _state = <span class="literal">false</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在启动线程时，需要传入三个匿名函数(默认为空)；当关闭线程时，需要调用<code>wait()</code>方法；而当退出线程时，由于一般都是出现错误时调用该方法，所以不需要阻塞，直接停止线程即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Start</span><span class="params">(EventCall onCreate, EventCall onRun, EventCall onDestory)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!_state)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//事件赋值</span></span><br><span class="line"><span class="keyword">if</span> (onCreate)</span><br><span class="line">_onCreate = onCreate;</span><br><span class="line"><span class="keyword">if</span> (onRun)</span><br><span class="line">_onRun = onRun;</span><br><span class="line"><span class="keyword">if</span> (onDestory)</span><br><span class="line">_onDestory = onDestory;</span><br><span class="line"><span class="comment">//线程启动</span></span><br><span class="line">_state = <span class="literal">true</span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::mem_fn(&amp;CellThread::OnWork), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//关闭线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_state)</span><br><span class="line">{</span><br><span class="line">_state = <span class="literal">false</span>;</span><br><span class="line">_semaphore.<span class="built_in">wait</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//退出线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_state)</span><br><span class="line">{</span><br><span class="line">_state = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//这里的目的是退出线程 没必要阻塞等信号量</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//线程是否运行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CellThread::isRun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> _state;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OnWork 方法内按顺序依次执行三个匿名函数，当销毁阶段函数执行后，调用信号量类的唤醒操作，来告知线程已安全退出。由此，封装线程类相关操作已经完成,可以通过相关方法来更精准的操作线程。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CellThread::OnWork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//开始事件</span></span><br><span class="line"><span class="keyword">if</span> (_onCreate)</span><br><span class="line">_onCreate(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line"><span class="keyword">if</span> (_onRun)</span><br><span class="line">_onRun(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="keyword">if</span> (_onDestory)</span><br><span class="line">_onDestory(<span class="keyword">this</span>);</span><br><span class="line">_semaphore.<span class="built_in">wakeup</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-退出顺序"><a href="#2-退出顺序" class="headerlink" title="2. 退出顺序"></a>2. 退出顺序</h2><p>在上文完成线程类的封装后，对源码中的线程相关进行更换。如下，即为线程的创建与关闭操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动接收线程</span></span><br><span class="line">_thread.<span class="built_in">Start</span>(</span><br><span class="line"><span class="comment">//onCreate</span></span><br><span class="line"><span class="literal">nullptr</span>,</span><br><span class="line"><span class="comment">//onRun</span></span><br><span class="line">[<span class="keyword">this</span>](CellThread*)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">OnRun</span>(&amp;_thread);<span class="comment">//工作函数OnRun</span></span><br><span class="line">},</span><br><span class="line"><span class="comment">//onDestory</span></span><br><span class="line"><span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//关闭接收线程</span></span><br><span class="line">_thread.<span class="built_in">Close</span>();</span><br></pre></td></tr></tbody></table></figure><p>对程序退出的顺序进行规范，大制思路如下：</p><ul><li>在TcpServer(主线程)宣布程序退出时，首先<strong>对接收线程类进行析构</strong>，进入接收线程的析构函数；</li><li>在接收线程的析构函数中，首先<strong>对接收线程类中配套的发送线程类进行析构</strong>，进入发送线程的析构函数；</li><li>在发送线程的析构函数中，<strong>调用发送线程的Close()操作</strong>，在线程关闭后，释放发送线程内的相关变量；</li><li>在发送线程的析构结束后，<strong>调用接收线程的Close()操作</strong>，在线程关闭后，释放接收线程内的相关变量，随后挨个<strong>释放储存的客户端连接对象</strong>；</li><li>在释放客户端连接对象时，会进入其析构函数，进行释放相关变量以及关闭socket连接的操作；</li><li><strong>此时接收线程的析构函数完毕，若还有未释放的接收线程，则重复上述操作</strong>；</li><li>当子线程全部析构后，回到第一步主线程的退出函数中，此时执行关闭主机socket、清除环境、释放变量等操作。</li></ul><h1 id="十四、添加日志模块"><a href="#十四、添加日志模块" class="headerlink" title="十四、添加日志模块"></a>十四、添加日志模块</h1><h2 id="1-添加日志类-CELLLog"><a href="#1-添加日志类-CELLLog" class="headerlink" title="1. 添加日志类(CELLLog)"></a>1. 添加日志类(CELLLog)</h2><p>CELLLog类主要功能为记录四种类型的日志：<strong>普通信息，调试信息，警告信息和错误信息</strong>。它使用了C++11的<strong>可变参数模板，以及文件IO、系统时间</strong>等技术。</p><p>在实现上，该类是一个<strong>单例模式</strong>，使用Instance()获取唯一实例。它包含四个静态函数，分别为<strong>Info、Debug、Warring和Error</strong>，用于记录不同类型的日志。其中，Debug类型的日志只在Debug模式下记录。对于每种日志类型，都有对应的宏定义，如CELLLog_Info和CELLLog_Debug。</p><p>该类还包含一个成员变量—<strong>—CELLTaskServer _taskServer</strong>，它是一个任务队列，用于<strong>在后台线程中异步写入日志到文件中</strong>。使用 <strong>setLogPath 函数设置日志文件名、打开方式和是否使用日期作为文件名后缀，通过文件IO函数fopen打开文件，并在析构函数中自动关闭文件</strong>。</p><p>对于错误类型的日志，有额外的 <strong>PError 函数</strong>，它使用 <strong>GetLastError 和 FormatMessageA 获取Windows系统下的错误信息，使用 errno 和 strerro r获取Linux系统下的错误信息</strong>。所有的日志信息最终<strong>通过 Echo 函数异步写入日志文件</strong>中，<strong>使用EchoReal函数实现日志信息的写入</strong>。</p><p>在CELLLog类中使用<strong>单例模式</strong>确保全局访问同一个CELLLog对象，使程序中所有的日志记录即便在多线程的情况下也是顺序写入同一个文件中；使用可变参数模板实现 Info 方法的多参数打印。</p><p><strong>Info函数</strong>是一个静态成员函数，用于记录普通信息。其作用是将输入的信息（格式化字符串以及对应参数）记录到日志文件中，并在控制台输出。该函数首先获取CELLLog实例的指针，并将任务添加到任务队列中，以异步的方式执行。在任务执行时，函数会调用EchoReal函数来记录日志和输出信息。EchoReal函数的作用是将传入的信息写入日志文件中，并在控制台输出。</p><p>在实现中，Echo函数会将需要记录的信息添加到任务队列中。EchoReal函数则是对传入的信息进行处理，首先判断日志文件是否打开，如果打开了，则使用fprintf函数将日志信息写入到日志文件中。之后根据传入的参数判断是否需要在控制台输出信息，如果需要，则使用printf函数在控制台输出信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小林图解网络学习笔记</title>
      <link href="/2023/03/05/xiao-lin-tu-jie-wang-luo-xue-xi-bi-ji-01/"/>
      <url>/2023/03/05/xiao-lin-tu-jie-wang-luo-xue-xi-bi-ji-01/</url>
      
        <content type="html"><![CDATA[<h1 id="小林图解网络学习笔记"><a href="#小林图解网络学习笔记" class="headerlink" title="小林图解网络学习笔记"></a>小林图解网络学习笔记</h1><h2 id="1-TCP-IP-网络模型有哪几层？"><a href="#1-TCP-IP-网络模型有哪几层？" class="headerlink" title="1. TCP/IP 网络模型有哪几层？"></a>1. TCP/IP 网络模型有哪几层？</h2><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p>专注于为用户提供应用功能，HTTP、FTP、Telnet、DNS、SMTP等；<strong>工作在操作系统中的用户态，传输层及以下则工作在内核态</strong>；用<u>端口</u>将应用区分开来，<u>80 端口</u>通常是 Web 服务器用的，<u>22 端口</u>通常是远程登录服务器用的；浏览器中的<strong>每个标签栏都是一个独立的进程</strong>，操作系统会为这些进程分配<strong>临时的端口号</strong>。</p><h3 id="1-2-传输层"><a href="#1-2-传输层" class="headerlink" title="1.2 传输层"></a>1.2 传输层</h3><p>只需要服务好应用即可，不管具体网络传输过程；有两个传输协议，分别是 <strong>TCP 和 UDP</strong>；当传输层的数据包大小超过 <u>MSS</u>（除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度） ，就要将数据包分块，方便丢失和损坏时重传单个块，每个分块称为一个 <u>TCP 段</u>（TCP Segment*）。</p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a><strong>1.3 网络层</strong></h3><p>最常使用的是 <u>IP 协议</u>（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 <u>MTU</u>（一个网络包的最大长度，以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>；用 IP 地址给设备进行编号，IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><h4 id="知道子网掩码，该怎么计算出网络地址和主机地址呢？"><a href="#知道子网掩码，该怎么计算出网络地址和主机地址呢？" class="headerlink" title="知道子网掩码，该怎么计算出网络地址和主机地址呢？"></a>知道子网掩码，该怎么计算出网络地址和主机地址呢？</h4><ul><li>子网掩码与IP地址<strong>按位与运算</strong>得到网<strong>络号</strong></li><li>子网掩码<strong>取反后</strong>与IP地址进行进行<strong>按位与运算</strong>得到<strong>主机号</strong></li></ul><p>IP协议两个重要能力：<strong>寻址和路由</strong>；寻址作用是告诉我们去往下一个目的地该<strong>朝哪个方向走</strong>，路由则是根据下一个目的地<strong>选择路径</strong>。寻址更像在导航，路由更像在操作方向盘。</p><h3 id="1-4-网络接口层"><a href="#1-4-网络接口层" class="headerlink" title="1.4 网络接口层"></a>1.4 网络接口层</h3><p>在 IP 头部的前面加上 <u>MAC</u> 头部，并封装成<u>数据帧</u>（Data frame）发送到网络上；作在网卡这个层次，使用 MAC 地址来标识网络上的设备；通过 ARP 协议获取对方的 MAC 地址。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><h2 id="2-键入网址到网页显示，期间发生了什么？"><a href="#2-键入网址到网页显示，期间发生了什么？" class="headerlink" title="2. 键入网址到网页显示，期间发生了什么？"></a>2. 键入网址到网页显示，期间发生了什么？</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg" alt="简单的网络模型"></p><ul><li><h3 id="浏览器解析-URL"><a href="#浏览器解析-URL" class="headerlink" title="浏览器解析 URL"></a>浏览器解析 URL</h3><p><u>URL</u>实际上是请求服务器里的文件资源；没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 <code>/index.html</code> 或者 <code>/default.html</code>；</p></li><li><h3 id="浏览器生成HTTP请求信息"><a href="#浏览器生成HTTP请求信息" class="headerlink" title="浏览器生成HTTP请求信息"></a>浏览器生成HTTP请求信息</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg" alt="HTTP 的消息格式"></p></li><li><h3 id="查询服务器域名对应的-IP-地址"><a href="#查询服务器域名对应的-IP-地址" class="headerlink" title="查询服务器域名对应的 IP 地址"></a><strong>查询服务器域名对应的 IP 地址</strong></h3><p>DNS服务器保存了 Web 服务器域名与 IP 的对应关系；域名中，越靠右的位置表示其层级越高；. 根域是在最顶层，它的下一层就是 .com 顶级域，再下面是 server.com权威域；根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路；解析域名<strong>先看浏览器缓存，再看OS缓存，再看hosts文件，最后才去问本地DNS服务器</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" alt="域名解析的工作流程"></p></li><li><h3 id="操作系统协议栈包装信息"><a href="#操作系统协议栈包装信息" class="headerlink" title="操作系统协议栈包装信息"></a><strong>操作系统协议栈</strong>包装信息</h3><p>浏览器通过<strong>调用 Socket 库，来委托协议栈工作</strong>；协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，下面一半是用 IP 协议控制网络包收发操作。</p><p><strong>可靠传输TCP：HTTP 是基于 TCP</strong>；TCP头格式：源端口号+目标端口号+<strong>序号</strong>（解决包乱序的问题）+<strong>确认号</strong>（解决丢包的问题）+首部长度+保留+状态位（维护连接的状态）+<strong>窗口大小</strong>（<strong>流量控制</strong>、拥塞控制）+校验和+紧急指针+选项；三次握手目的是<strong>保证双方都有发送和接收的能力</strong>；在 Linux 可以通过 <code>netstat -napt</code> 命令查看TCP 的连接状态；</p><p>**远程定位IP:**头格式：版本+首部长度+服务类型+总长度+标识+标志+片位移+协议+TTL+首部校验和+<strong>源地址 IP</strong> + <strong>目标地址 IP</strong>+选项；当客户端有多个网卡即有多个IP，选哪个作为源地址呢？用路由表规则，将目标地址和表中每个条目的子网掩码与运算，找到与Destination相同的那个条目的IP作为源地址；</p><p><strong>两点传输MAC：</strong>头格式：<strong>发送方 MAC 地址</strong>+<strong>接收方目标 MAC 地址</strong>+协议类型；ARP广播IP获得MAC，或用ARP缓存；<strong>MAC 头部的作用就是在以太网内进行两个设备之间的包传输</strong></p></li><li><h3 id="网卡发送"><a href="#网卡发送" class="headerlink" title="网卡发送"></a>网卡发送</h3><p>将<strong>数字信息转换为电信号</strong>，<strong>网卡本身具有 MAC 地址</strong>，控制网卡要靠<strong>网卡驱动程序</strong>；网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，在其开头加上<strong>报头和起始帧分界符</strong>，在末尾加上用于检测错误的帧<strong>校验序列</strong>(FCS)；</p></li><li><h3 id="交换机转发"><a href="#交换机转发" class="headerlink" title="交换机转发"></a>交换机转发</h3><p>将<strong>电信号转换为数字信号</strong>，基于以太网设计的，俗称<strong>二层</strong>网络设备<strong>，端口不具有 MAC 地址</strong>，<strong>据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>，查不到就发给所有端口；</p></li><li><h3 id="路由器转发"><a href="#路由器转发" class="headerlink" title="路由器转发"></a><strong>路由器转发</strong></h3><p>将<strong>电信号转成数字信号</strong>，基于 IP 设计的，俗称<strong>三层</strong>网络设备，各个端口都具有 <strong>MAC 地址和 IP 地址</strong>，<strong>去掉</strong>包开头的 MAC 头部，<strong>路由表</strong>查询转发目标，即根据目的IP通过ARP定MAC，在转换为电信号通过端口发出去，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong></p></li><li><h3 id="服务器扒皮并发送响应报文"><a href="#服务器扒皮并发送响应报文" class="headerlink" title="服务器扒皮并发送响应报文"></a>服务器扒皮并发送响应报文</h3><p>TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号，把客户端需要的网页封装在 HTTP 响应报文里，穿上 TCP、IP、MAC 头部，从网卡出去，由交换机转发到路由器，路由器就把响应数据包发到了下一个路由器，直到客户端；客户端层层扒皮后给服务器渲染生成网页。</p></li></ul><h2 id="3-Linux系统如何收发网络包？"><a href="#3-Linux系统如何收发网络包？" class="headerlink" title="3. Linux系统如何收发网络包？"></a>3. Linux系统如何收发网络包？</h2><ul><li><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><strong>OSI模型</strong></p><ul><li>应用层，负责给应用程序提供统一的接口；</li><li>表示层，负责把数据转换成兼容另一个系统能识别的格式；</li><li>会话层，负责建立、管理和终止表示层实体之间的通信会话；</li><li>传输层，负责端到端的数据传输；</li><li>网络层，负责数据的路由、转发、分片；</li><li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；</li><li>物理层，负责在物理网络中传输数据帧；</li></ul><p><strong>TCP/IP 网络模型</strong></p><ul><li><p>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</p></li><li><p>传输层，负责端到端的通信，比如 TCP、UDP 等；</p></li><li><p>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</p></li><li><p>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/OSI%E4%B8%8ETCP.png" alt="img"></p></li></ul></li><li><h3 id="Linux网络协议栈"><a href="#Linux网络协议栈" class="headerlink" title="Linux网络协议栈"></a>Linux网络协议栈</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="img"></p></li><li><p>应用程序需要通过<strong>系统调用</strong>，来跟 Socket 层进行数据交互；</p></li><li><p>Socket 层的下面就是传输层、网络层和网络接口层；</p></li><li><p>最下面的一层，则是网卡驱动程序和硬件网卡设备；</p></li><li><h3 id="Linux-接收网络包的流程"><a href="#Linux-接收网络包的流程" class="headerlink" title="Linux 接收网络包的流程"></a>Linux 接收网络包的流程</h3><p><strong>网卡收包</strong>，通过 <strong>DMA</strong> 写进 <strong>Ring Buffe</strong>r，并向 CPU 发起<strong>硬件中断</strong>，当 CPU 收到硬件中断请求后，根据中断表调用已经注册的<strong>中断处理函数</strong>。硬件中断处理函数先「<strong>暂时屏蔽中断</strong>」，告诉网卡下次再收到数据包直接写内存就可以了，再发起「<strong>软中断</strong>」；内核中的 <strong>ksoftirqd 线程</strong>专门负责软中断的处理，它从 Ring Buffer 中获取一个数据帧，交给<strong>网络协议栈</strong>进行逐层处理。</p></li><li><h3 id="Linux-发送网络包的流程"><a href="#Linux-发送网络包的流程" class="headerlink" title="Linux 发送网络包的流程"></a>Linux 发送网络包的流程</h3><p>应用程序<strong>系统调用</strong> Socket 发送数据包的接口进入<strong>内核态Socket层</strong>，内核会申请一个内核态的 <strong>sk_buff 内存</strong>，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到<strong>发送缓冲区</strong>，<strong>网络协议栈</strong>从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理，TCP拷贝一个新的 sk_buff 副本往下传递，防止误触发丢失重传，触发「<strong>软中断</strong>」告诉<strong>网卡驱动程序</strong>，驱动程序会从发送队列中<strong>读取 sk_buff</strong>，将这个 sk_buff 挂到 <strong>RingBuffer</strong> 中，接着将 sk_buff 数据映射到<strong>网卡</strong>可访问的内存 <strong>DMA 区域</strong>，最后触发真实的<strong>发送</strong>，网卡设备会触发一个<strong>硬中断</strong>来释放内存，主要是<strong>释放 sk_buff 内存和清理 RingBuffer 内存</strong></p><h4 id="发送时的三次内存拷贝："><a href="#发送时的三次内存拷贝：" class="headerlink" title="发送时的三次内存拷贝："></a><em><strong>发送时的三次内存拷贝</strong></em>：</h4><ul><li>用户待发送的数据 ➡内核sk_buff 内存</li><li>传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来，传送副本；</li><li>sk_buff 大于 MTU 时，将原来的 sk_buff 拷贝为多个小的 sk_buff。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 图解网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习总结</title>
      <link href="/2023/03/02/mysql-xue-xi-zong-jie/"/>
      <url>/2023/03/02/mysql-xue-xi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-mysql基础知识"><a href="#1-mysql基础知识" class="headerlink" title="1 mysql基础知识"></a>1 mysql基础知识</h1><h2 id="1-1-基础架构"><a href="#1-1-基础架构" class="headerlink" title="1.1 基础架构"></a>1.1 基础架构</h2><p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="avatar"></p><h3 id="1-1-1-连接器"><a href="#1-1-1-连接器" class="headerlink" title="1.1.1 连接器"></a>1.1.1 连接器</h3><p>​连接器负责跟客户端建立连接、获取权限、维持和管理连接 （默认空闲连接超时时间8小时参数 wait_timeout，注意避免长连接）</p><h3 id="1-1-2-查询缓存"><a href="#1-1-2-查询缓存" class="headerlink" title="1.1.2 查询缓存"></a>1.1.2 查询缓存</h3><p>​查询请求先访问缓存(key 是查询的语句，value 是查询的结果)。命中直接返回。不推荐使用缓存，更新会把缓存清除(关闭缓存：参数 query_cache_type 设置成 DEMAND)。</p><p>MYSQL 8.0 后不支持查询缓存</p><h3 id="1-1-3-分析器"><a href="#1-1-3-分析器" class="headerlink" title="1.1.3 分析器"></a>1.1.3 分析器</h3><p>​对 SQL 语句做解析，判断sql是否正确。（先会做“词法分析”，再做“语法分析”。  ）</p><h3 id="1-1-4-优化器"><a href="#1-1-4-优化器" class="headerlink" title="1.1.4 优化器"></a>1.1.4 优化器</h3><p>​决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序。</p><h3 id="1-1-5-执行器"><a href="#1-1-5-执行器" class="headerlink" title="1.1.5 执行器"></a>1.1.5 执行器</h3><p>1.在执行之前，判断时候有执行的权限</p><p>2.命中查询缓存，在返回结果时做权限验证<br>3.查询会在优化器之前调用precheck验证权限</p><h2 id="1-2-日志系统"><a href="#1-2-日志系统" class="headerlink" title="1.2 日志系统"></a>1.2 日志系统</h2><h3 id="1-2-1-redo-log-重做日志"><a href="#1-2-1-redo-log-重做日志" class="headerlink" title="1.2.1 redo log (重做日志)"></a>1.2.1 redo log (重做日志)</h3><p>MySQL WAL (Write-Ahead Logging) 技术，先写日志，再写磁盘。保证掉电重启，数据不丢失（crash-safe）。<br><strong>redo log 是 InnoDB 引擎特有的日志。</strong><br>当记录更新时，Innodb 先记录 redo log 再更新内存，这时更新就算完成。引擎往往会在系统空闲时刷盘。</p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" style="zoom: 50%;"><p>redo log 是实现了类似环形缓冲区，一个指针 write pos 是当前记录的位置，另一个指针 checkpoint 是当前要擦除的位置，write pos 和checkpoint 之间是空闲部分。如果 write pos 快追上 checkpoint 时，代表缓冲区快满了，需要暂停刷盘。（CP’见12讲）</p><p>innodb_flush_log_at_trx_commit参数：<br>0：log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作。<br>1：每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去，该模式为系统默认。<br>2：每次事务提交时MySQL都会把log buffer的数据写入log file，但是flush(刷到磁盘)操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作。</p><h3 id="1-2-2-binlog（归档日志）"><a href="#1-2-2-binlog（归档日志）" class="headerlink" title="1.2.2 binlog（归档日志）"></a>1.2.2 binlog（归档日志）</h3><p>Server层日志。binlog 日志只能用于归档，没有crash-safe能力。</p><p>三个用途:</p><ol><li>恢复：利用binlog日志恢复数据库数据</li><li>复制：主从同步</li><li>审计：通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击</li></ol><p>常见格式：</p><table><thead><tr><th align="center">format</th><th align="center">定义</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">statement</td><td align="center">记录的是修改SQL语句</td><td align="center">日志文件小，节约IO，提高性能</td><td align="center">准确性差，对一些系统函数不能准确复制或不能复制，如now()、uuid()等</td></tr><tr><td align="center">row(推荐)</td><td align="center">记录的是每行实际数据的变更，记两条，更新前和更新后</td><td align="center">准确性强，能准确复制数据的变更</td><td align="center">日志文件大，较大的网络IO和磁盘IO</td></tr><tr><td align="center">mixed</td><td align="center">statement和row模式的混合</td><td align="center">准确性强，文件大小适中</td><td align="center">有可能发生主从不一致问题</td></tr></tbody></table><p>sync_binlog参数：<br>0：当事务提交后，Mysql仅仅是将binlog_cache中的数据写入Binlog文件，但不执行fsync之类的磁盘 同步指令通知文件系统将缓存刷新到磁盘，而让Filesystem自行决定什么时候来做同步，这个是性能最好的。<br>n：在进行n次事务提交以后，Mysql将执行一次fsync之类的磁盘同步指令，同志文件系统将Binlog文件缓存刷新到磁盘。</p><h3 id="二者的不同"><a href="#二者的不同" class="headerlink" title="二者的不同:"></a>二者的不同:</h3><p>1、redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p><p>2、redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p><p>3、redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。binlog 文件到一定大小，会切换到下一个文件。</p><h3 id="update执行过程："><a href="#update执行过程：" class="headerlink" title="update执行过程："></a><strong>update执行过程：</strong></h3><p>mysql&gt; update T set c=c+1 where ID=2;</p><img src="https://img-blog.csdnimg.cn/20181205200935425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" style="zoom:50%;"><p>两阶段提交<br>1 prepare阶段 2 写binlog 3 commit<br>当在2之前崩溃时<br>重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。<br>当在3之前崩溃<br>重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog 。</p><h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性</p><table><thead><tr><th align="center">事务隔离级别</th><th align="center">脏读</th><th>不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交（read-uncommitted）</td><td align="center">是</td><td>是</td><td align="center">是</td></tr><tr><td align="center">读提交（read-committed）</td><td align="center">否</td><td>是</td><td align="center">是</td></tr><tr><td align="center">可重复读（repeatable-read）</td><td align="center">否</td><td>否</td><td align="center">是</td></tr><tr><td align="center">串行化（serializable）</td><td align="center">否</td><td>否</td><td align="center">否</td></tr></tbody></table><p>总结：<br>RR下，事务在第一个Read操作时，会建立read-view<br>RC下，事务在每次Read操作时，都会建立read-view<br>不同业务选择不同的隔离级别。</p><p>innodb支持RC和RR隔离级别实现是用的一致性视图(consistent read view)</p><h3 id="1-3-1-回滚段"><a href="#1-3-1-回滚段" class="headerlink" title="1.3.1 回滚段"></a>1.3.1 回滚段</h3><p>rollback segment称为回滚段，每个回滚段中有1024个undo log segment。每个undo操作在记录的时候占用一个undo log segment。<br>undo log有两个作用：提供回滚和多个行版本控制(MVCC)。<br>在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。<br>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p><h3 id="1-3-2-事务隔离的实现"><a href="#1-3-2-事务隔离的实现" class="headerlink" title="1.3.2 事务隔离的实现"></a>1.3.2 事务隔离的实现</h3><p>以可重复读（RR）为例，每条记录在更新的时候都会同时记录一条回滚操作。</p><img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="avr" style="zoom:50%;"><p>不同时刻启动的事务会有不同的 read-view。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。<br>当系统里没有比这个回滚日志更早的 read-view 的时候，回滚日志会被删除。所以要避免长事务。</p><h3 id="1-3-3-事务的启动方式"><a href="#1-3-3-事务的启动方式" class="headerlink" title="1.3.3 事务的启动方式"></a>1.3.3 事务的启动方式</h3><p>1.显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</p><p>2.set autocommit=0，这个命令会将这个线程的自动提交关掉。</p><p>查询长事务：</p><p>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60;</p><h3 id="1-3-4-“快照”在-MVCC-里是怎么工作"><a href="#1-3-4-“快照”在-MVCC-里是怎么工作" class="headerlink" title="1.3.4 “快照”在 MVCC 里是怎么工作"></a>1.3.4 “快照”在 MVCC 里是怎么工作</h3><p>(1)每个事务都有一个事务ID,叫做transaction id(严格递增)<br>(2)事务在启动时,找到已提交的最大事务ID记为up_limit_id。<br>(3)事务在更新一条语句时,比如id=1改为了id=2.会把id=1和该行之前的row trx_id写到undo log里,<br>并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头<br>(4)再定一个规矩,一个事务要查看一条数据时,必须先用该事务的up_limit_id与该行的transaction id做比对,<br>如果up_limit_id&gt;=transaction id,那么可以看.如果up_limit_id&lt;transaction id,则只能去undo log里去取。去undo log查找数据的时候,也需要做比对,必须up_limit_id&gt;transaction id,才返回数据<br><img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="var"></p><p>上图中的三个虚线箭头就是undo log。</p><p>由于当前读都是先读后写,只能读当前的值,所以为当前读.会更新事务内的up_limit_id为该事务的transaction id</p><p>不同隔离级别：</p><p>对于可重复读，查询只承认在事务启动前就已经提交完成的数据<br>对于读提交，查询只承认在语句启动前就已经提交完成的数据<br>而当前读，总是读取已经提交完成的最新版本。</p><h3 id="1-3-5-为什么rr能实现可重复读而rc不能"><a href="#1-3-5-为什么rr能实现可重复读而rc不能" class="headerlink" title="1.3.5 为什么rr能实现可重复读而rc不能"></a>1.3.5 为什么rr能实现可重复读而rc不能</h3><p>(1)快照读的情况下,rr不能更新事务内的up_limit_id,<br>  而rc每次会把up_limit_id更新为快照读之前最新已提交事务的transaction id,则rc不能可重复读<br>(2)当前读的情况下,rr是利用record lock+gap lock来实现的,而rc没有gap,所以rc不能可重复读</p><h2 id="1-4-索引"><a href="#1-4-索引" class="headerlink" title="1.4 索引"></a>1.4 索引</h2><h3 id="1-4-1-常见模型"><a href="#1-4-1-常见模型" class="headerlink" title="1.4.1 常见模型"></a>1.4.1 常见模型</h3><p>哈希表：键 - 值（key-value）存储数据的结构   哈希表这种结构适用于只有等值查询的场景</p><p><img src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" alt="var"></p><p>有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))   有序数组索引只适用于静态存储引擎</p><p><img src="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" alt="var"></p><p>搜索树：二叉树  查询时间复杂度O(log(N))，更新时间复杂度O(log(N))</p><p><img src="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" alt="var"></p><h3 id="1-4-2-InnoDB-的索引模型"><a href="#1-4-2-InnoDB-的索引模型" class="headerlink" title="1.4.2 InnoDB 的索引模型"></a>1.4.2 InnoDB 的索引模型</h3><p>B+树索引模型</p><p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="var"></p><p>主键索引(聚簇索引)：</p><p>主键索引的叶子节点存的是整行数据。</p><p>非主键索引(二级索引)：</p><p>非主键索引的叶子节点内容是主键的值。通过二级索引需要扫描二级索引树，找到主键后再扫描主键索引，该过程称为<strong>回表</strong>。</p><h3 id="1-4-3-索引维护"><a href="#1-4-3-索引维护" class="headerlink" title="1.4.3 索引维护"></a>1.4.3 索引维护</h3><p>一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。</p><p>自增索引（追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂）<br>业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>二级索引的叶子节点为主键，业务字段做主键时会占大量存储空间，主键长度越小，占用的空间就越小。<br>什么时候可以使用业务字段做主键？ 只有一个索引；该索引必须是唯一索引。</p><h3 id="1-4-4-覆盖索引"><a href="#1-4-4-覆盖索引" class="headerlink" title="1.4.4 覆盖索引"></a>1.4.4 覆盖索引</h3><p>查询的值在二级索引树叶子节点上时，不需要回表；建立联合覆盖索引需要权衡利弊</p><h3 id="1-4-5-最左前缀原则"><a href="#1-4-5-最左前缀原则" class="headerlink" title="1.4.5 最左前缀原则"></a>1.4.5 最左前缀原则</h3><p>联合索引合理安排顺序，可以少维护索引，或者减少存储空间。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `geek` (</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`a`,`b`)</span>,</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  KEY `ca` (`c`,`a`),</span><br><span class="line">  KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>索引ca可以去掉，因为c和主键ab，和ca和主键ab相同。</p><h3 id="1-4-6索引下推"><a href="#1-4-6索引下推" class="headerlink" title="1.4.6索引下推"></a>1.4.6索引下推</h3><p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h3 id="1-4-7-联合索引的技巧"><a href="#1-4-7-联合索引的技巧" class="headerlink" title="1.4.7 联合索引的技巧"></a>1.4.7 联合索引的技巧</h3><p>1、覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据<br>2、最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符<br>3、联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。<br>4、索引下推：like ‘hello%’and age &gt;10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age&lt;10的数据，再进行回表查询，减少回表率，提升检索速度</p><h2 id="1-5-锁"><a href="#1-5-锁" class="headerlink" title="1.5 锁"></a>1.5 锁</h2><h3 id="1-5-1-全局锁"><a href="#1-5-1-全局锁" class="headerlink" title="1.5.1 全局锁"></a>1.5.1 全局锁</h3><p>全局锁就是对整个数据库实例加锁,全局锁的典型使用场景是，做全库逻辑备份。</p><p>FTWRL命令：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></tbody></table></figure><p>官方自带的逻辑备份工具是 mysqldump，当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。<br>但当引擎不支持事务时，只能使用FTWRL 命令了。不推荐不使用 set global readonly=true，readonly会被其他逻辑使用（比如判断主从），readonly发生异常会保持该状态。</p><h3 id="1-5-2-表锁"><a href="#1-5-2-表锁" class="headerlink" title="1.5.2 表锁"></a>1.5.2 表锁</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)；</p><p>表锁的语法是 lock tables … read/write<br>MDL不需要显式使用，在访问一个表的时候会被自动加上。<br>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>当一个长事务还没提交，进行表结构变更操作，会导致后面的事务block。当客户端有重试机制时，新起session请求，会导致库的线程很快就会爆满。</p><p>如何安全地给小表加字段？</p><p>​1.避免长事务。<br>​2.在 alter table 语句里面设定等待时间。<br>​MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name NOWAIT <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name WAIT N <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></tbody></table></figure><h3 id="1-5-3-行锁"><a href="#1-5-3-行锁" class="headerlink" title="1.5.3 行锁"></a>1.5.3 行锁</h3><p>行锁就是针对数据表中行记录的锁； MyISAM 引擎就不支持行锁，InnoDB支持的；</p><p><strong>两阶段锁：</strong></p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p><h3 id="1-5-4-死锁和死锁检测："><a href="#1-5-4-死锁和死锁检测：" class="headerlink" title="1.5.4 死锁和死锁检测："></a>1.5.4 <strong>死锁和死锁检测</strong>：</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态</p><p>1.设置超时时间，innodb_lock_wait_timeou</p><p>2.死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p><p>解决方案：</p><p>1、业务不会出现死锁时，可以临时关闭</p><p>2、在客户端控制并发</p><p>3、修改MYSQL源码，并发引入引擎之前排队</p><p>4、将一行数据改为多行，如将一个余额账户分为多个，但在数据减少操作时需考虑小于0的情况。</p><h1 id="2-常见问题"><a href="#2-常见问题" class="headerlink" title="2 常见问题"></a>2 常见问题</h1><h2 id="2-1-普通索引和唯一索引的选择"><a href="#2-1-普通索引和唯一索引的选择" class="headerlink" title="2.1 普通索引和唯一索引的选择"></a>2.1 普通索引和唯一索引的选择</h2><p><strong>查询：</strong></p><p>​a、普通索引，查到满足条件的第一个记录后，继续查找下一个记录，知道第一个不满足条件的记录<br>​b、唯一索引，由于索引唯一性，查到第一个满足条件的记录后，停止检索，但是，两者的性能差距微乎其微。因为InnoDB根据数据页来读写的。</p><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>​change buffer是持久化数据，在内存中有拷贝，也会写到磁盘上。<br>当更新数据页时，如数据页在内存中直接更新。如果不在，在不影响数据一致性的前提下，innodb会将更新操作先缓存到change buffer中，当下次查询该数据页时，执行change buffer中与该页相关的操作。该操作称为merge，除了该情况，系统后台线程也会定merge，数据库正常关闭也会merge。<br>​change buffer可以减少读磁盘，而且数据读入内存会占用buffer pool。</p><p><strong>什么条件下可以使用 change buffer 呢？</strong></p><p>对于唯一索引，更新操作都需要判断操作是否违反唯一约束，所以需要将数据都读入到内存，所以会直接更新内存。<br>所以只有普通索引会使用change buffer。<br>change buffer使用buffer pool里的内存，参数innodb_change_buffer_max_size设置为50时，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p><strong>更新：</strong></p><p>​a. 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；<br>​b. 对于普通索引来说，则是将更新记录在change buffer，语句执行就结束了。<br>所以这种情况，唯一索引会导致磁盘大量随机IO的访问（机械硬盘瓶颈）。<br>但这种情况不是绝对的，写多读少的场景change buffer记录的变更多，收益越大。常见业务模型账单类、日志类的系统。对于写完马上读取的情况，会立即触发merge，反而增加了维护change buffer的成本。<br>所以尽量选择普通索引。</p><p><u><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></u></p><h4 id="选择结论："><a href="#选择结论：" class="headerlink" title="选择结论："></a>选择结论：</h4><p>​1.业务正确性优先，业务可以保证不重复，普通索引提升效率。业务不能保证重复，就需要唯一索引保证。</p><p>​2.历史数据归档库没有唯一索引冲突，可以选择普通索引。</p><h2 id="2-2-为什么选错索引"><a href="#2-2-为什么选错索引" class="headerlink" title="2.2 为什么选错索引"></a>2.2 为什么选错索引</h2><p>平常不断地删除历史数据和新增数据的场景，mysql有可能会选错索引。</p><h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a><strong>优化器的逻辑</strong></h3><p>优化器选择索引的目的就是选择一个扫描行数最少的方案。行数越少，磁盘读取越少。<br>扫描行数不是唯一标准，优化器还会结合是否使用临时表，是否排序等因素。</p><p><strong>扫描行数怎么判断？</strong><br>真正执行语句之前，mysql不知道具体有多少条，只能根据统计信息估算。<br>这个统计信息就是索引的“区分度”。索引上不同值越多，区分度越好。而一个索引上不同值的个数称为“基数”。<br>使用show index可以查看。每行三个字段值都是一样的，但在统计信息中，基数值都不准确。</p><p><strong>mysql怎么得到索引的基数？</strong><br>    mysql采用采样统计，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。<br>参数 innodb_stats_persistent有两种不同的模式:</p><p>​设置为 on 的时候，表示统计信息会持久化存储。默认 N 是 20，M 是 10。<br>​设置为 off 的时候，表示统计信息只存储在内存中。默认 N 是 8，M 是 16。<br>​如果统计信息不对，可以使用analyze table t 命令重新统计。</p><h3 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a><strong>索引选择异常和处理</strong></h3><p>1.force index 强行选择一个索引</p><p>2.修改语句，引导 MySQL 使用我们期望的索引</p><p>3.新建索引，或者删除误用的索引</p><h2 id="2-3-怎么给字符串字段加索引"><a href="#2-3-怎么给字符串字段加索引" class="headerlink" title="2.3 怎么给字符串字段加索引"></a>2.3 怎么给字符串字段加索引</h2><ol><li><p>直接创建完整索引，这样可能比较占用空间；</p><p>这种方式最简单，如果性能没问题，我会这么创建，简单直接且存储空间的费用越来越低</p></li><li><p>mysql支持<strong>前缀索引</strong>，可以以字符串一部分作为索引。默认包含整个字符串。</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t index idx(a(6));</span><br></pre></td></tr></tbody></table></figure><p>使用前缀索引虽然可以减少存储空间，但有可能会增加回表次数。  并且前缀索引会影响覆盖索引。<br>建前缀索引前可以使用下面的sql统计一下重复数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(a,字符长度));</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><p>倒序存储</p><p>由于身份证前面的地区码都是相同的，所以存储身份证时，可以将它倒过来存。身份证后6位作为前缀索引有一定的区分度。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">'input_id_card_string'</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用hash字段</p><p>可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。<br>插入新数据，使用crc32()得到该字段填入。<br>查询语句如下：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card_crc<span class="operator">=</span>crc32(<span class="string">'input_id_card_string'</span>) <span class="keyword">and</span> id_card <span class="operator">=</span> <span class="string">'input_id_card_string'</span>；</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>另外，如果前缀后缀都重复，可以考虑去掉前缀后缀，只存中间一部分数据。</p></li></ol><h2 id="2-4-为什么sql会“抖”一下？"><a href="#2-4-为什么sql会“抖”一下？" class="headerlink" title="2.4 为什么sql会“抖”一下？"></a>2.4 为什么sql会“抖”一下？</h2><p>​mysql抖一下就是在刷脏页（flush）</p><p>​<strong>刷脏页的四个场景：</strong></p><p> （1）redo log满了 </p><p> （2）内存满了 ：</p><p>​此时需要淘汰一些数据页，有可能会淘汰脏页，就要先把脏页刷到磁盘。刷脏页一定会写盘，就保证了每个数据页有两种状态：<br>​a. 内存里的一定是正确数据。<br>​b. 内存里没有，磁盘上的一定是正确数据。</p><p> （3）mysql空闲的时候 </p><p>（4）mysql正常关闭的时候</p><h3 id="刷脏页的控制策略"><a href="#刷脏页的控制策略" class="headerlink" title="刷脏页的控制策略"></a>刷脏页的控制策略</h3><p>根据InnoDB 所在主机的 IO 能力，正确地设置innodb_io_capacity 参数，使用fio工具统计：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%;平时要多关注脏页比例，不要让它经常接近 75%。<br>脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></tbody></table></figure><p>当刷脏页时，该页边上也是脏页，也会把边上的脏页一起刷掉。而且该逻辑会一直蔓延。</p><p>参数 <strong>innodb_flush_neighbors</strong>    值为1会有上述机制，0则不会。<br>机械硬盘可能会有不错的效果，但ssd建议设置为0。<br>并且mysql 8.0 innodb_flush_neighbors 默认为0。</p><h2 id="2-5-为什么表数据删掉一半，表文件大小不变？"><a href="#2-5-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="2.5 为什么表数据删掉一半，表文件大小不变？"></a>2.5 为什么表数据删掉一半，表文件大小不变？</h2><p>mysql8.0 之前，表结构以.frm为后缀的文件里。而8.0版本允许表结构定义放在系统数据表中，因为该部分占用空间很小。<br><strong>参数 innodb_file_per_table</strong><br>    表数据既可以存在共享表空间里，也可以是单独的文件。</p><p>​OFF，表示表的数据放在系统共享表空间，也就是跟数据字典放在一起。drop table及时表删掉了，空间也不会回收。<br>​ON（5.6.6版本后默认值），表示每个innodb表数据存储在以.ibd为后缀的文件中。drop table系统会直接删除这个文件。</p><h3 id="空洞"><a href="#空洞" class="headerlink" title="空洞"></a>空洞</h3><p>空洞就是那些被标记可复用但是还没被使用的存储空间。</p><p>使用delete命令删除数据会产生空洞，标记为可复用</p><p>插入新的数据可能引起页分裂，也可能产生空洞</p><p>修改操作，有时是一种先删后插的动作也可能产生空洞</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>​可以新建一个表，将旧表中的数据一行一行读出来插入到<strong>新表</strong>中。然后以新表替换旧表。<br>可以使用 alter table A engine=InnoDB 命令来重建表。在mysql 5.5版本前，该命令流程与上述流程类似。<br>在此过程中，不能更新旧表数据</p><p>MySQL 5.6 版本开始引入的 <strong>Online DDL</strong>，对该操作流程做了优化。</p><p>​建立一个临时文件，扫描表 A 主键的所有数据页；<br>​用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；<br>​生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；<br>​临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中state3 的状态；<br>​用临时文件替换表 A 的数据文件。</p><p><img src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" alt="var"></p><p>重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。<br>如果是线上服务，要控制操作时间。如果想要比较安全的操作，推荐使用github开源的gh-ost。</p><p><strong>optimize table、analyze table和 alter table 这三种方式重建表的区别。</strong></p><p>​从 MySQL 5.6 版本开始，alter table t engine = InnoDB（也就是 recreate）默认是上图的流程；<br>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了 MDL 读锁；<br>optimize table t 等于 recreate+analyze。</p><h2 id="2-6-count-慢怎么办？"><a href="#2-6-count-慢怎么办？" class="headerlink" title="2.6 count(*)慢怎么办？"></a>2.6 count(*)慢怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><ul><li>MyISAM 引擎保存总行数，所以count很快。但如果加了where不能很快返回。</li><li>Innodb需要一行一行读出来累积计数。</li></ul><p>innodb由于多版本并发控制（MVCC）的原因，多个事务count的行数不同，所以不能保存总行数。<br>但count(*)做了优化，引擎会选择最小的普通索引树，来计数。而不是直接统计聚集索引树。</p><p><strong>用缓存系统保存计数</strong></p><p>两个问题：</p><ol><li>缓存会丢失</li><li>缓存不准确，因为缓存计数和插入数据不是原子操作，有可能在中间过程，其他事务读取了数据。</li></ol><p><strong>在数据库保存计数</strong></p><p>使用一张表保存计数，由于事务可以解决使用缓存问题。</p><h3 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h3><p>下面的讨论还是基于 InnoDB 引擎的</p><ol><li><p>count(主键 id) ，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p></li><li><p>count(1)，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p></li><li><p>count(字段)<br>a. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；<br>b. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</p></li><li><p>count(<em>)，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>) 肯定不是 null，按行累加。</p><p><strong>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>)，所以建议尽量使用 count(</em>)。</strong></p></li></ol><h2 id="2-7-“order-by”是怎么工作的？"><a href="#2-7-“order-by”是怎么工作的？" class="headerlink" title="2.7 “order by”是怎么工作的？"></a>2.7 “order by”是怎么工作的？</h2><p>1.MySQL会为每个线程分配一个内存（sort_buffer）用于排序该内存大小为sort_buffer_size<br>     1&gt;如果排序的数据量小于sort_buffer_size，排序将会在内存中完成<br>     2&gt;如果排序数据量很大，内存中无法存下这么多数据，则会使用磁盘临时文件来辅助排序，也称外部排序<br>     3&gt;在使用外部排序时，MySQL会分成好几份单独的临时文件用来存放排序后的数据，然后在将这些文件合并成一个大文件</p><p>2.mysql会通过遍历索引将满足条件的数据读取到sort_buffer，并且按照排序字段进行快速排序<br>    1&gt;如果查询的字段不包含在辅助索引中，需要按照辅助索引记录的主键返回聚集索引取出所需字段<br>    2&gt;该方式会造成随机IO，在MySQL5.6提供了MRR的机制，会将辅助索引匹配记录的主键取出来在内存中进行排序，然后在回表<br>    3&gt;按照情况建立联合索引来避免排序所带来的性能损耗，允许的情况下也可以建立覆盖索引来避免回表</p><p><strong>全字段排序</strong><br>    1.通过索引将所需的字段全部读取到sort_buffer中<br>    2.按照排序字段进行排序<br>    3.将结果集返回给客户端</p><p><img src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" alt="var"></p><p>​<strong>缺点：</strong><br>​1.造成sort_buffer中存放不下很多数据，因为除了排序字段还存放其他字段，对sort_buffer的利用效率不高<br>​2.当所需排序数据量很大时，会有很多的临时文件，排序性能也会很差</p><p>​<strong>优点</strong>：MySQL认为内存足够大时会优先选择全字段排序，因为这种方式比rowid 排序避免了一次回表操作</p><p><strong>rowid排序</strong><br>    1.通过控制排序的行数据的长度来让sort_buffer中尽可能多的存放数据，max_length_for_sort_data<br>    2.只将需要排序的字段和主键读取到sort_buffer中，并按照排序字段进行排序<br>    3.按照排序后的顺序，取id进行回表取出想要获取的数据<br>    4.将结果集返回给客户端</p><p><img src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" alt="var"></p><p>​<strong>优点：</strong>更好的利用内存的sort_buffer进行排序操作，尽量减少对磁盘的访问</p><p>​<strong>缺点：</strong>回表的操作是随机IO，会造成大量的随机读，不一定就比全字段排序减少对磁盘的访问</p><p>3.按照排序的结果返回客户所取行数</p><h2 id="2-8-如何正确地显示随机消息？"><a href="#2-8-如何正确地显示随机消息？" class="headerlink" title="2.8 如何正确地显示随机消息？"></a>2.8 如何正确地显示随机消息？</h2><p><strong>rowid</strong>:</p><ul><li><p>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p></li><li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；</p></li><li><p>MEMORY 引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。</p></li></ul><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>explain:</p><p><img src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" alt="var"></p><p>这个 Extra 的意思就是，需要临时表，并且需要在临时表上排序。<br>上一篇文章的一个结论：对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。<br><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。</strong>所以，MySQL 这时就会选择 rowid 排序。<br>上述sql的执行流程：</p><ol><li>创建一个memory引擎的临时表，第一个字段double类型，假设字段为R，第二个字段varchar(64)，记为字段W。并且这个表没有索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>接着在没有索引的内存临时表上，按字段R排序。</li><li>初始化sort_buffer。sort_buffer和临时表一直两个字段。</li><li>临时表全表扫描去取R值和位置信息（稍后解释），放入sort_buffer两个字段，此时扫描行数增加10000，变成20000。</li><li>在sort_buffer对R值排序。</li><li>排序完成取前三行，总扫描行数变成20003行。</li></ol><p><img src="https://static001.geekbang.org/resource/image/2a/fc/2abe849faa7dcad0189b61238b849ffc.png" alt="var"></p><p><strong>小结： order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p><h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>tmp_table_size限制了内存临时表的大小，默认16M。如果内存大于tmp_table_size，则会转成磁盘临时表。<br>磁盘临时表使用的引擎默认是 InnoDB，由参数 internal_tmp_disk_storage_engine 控制。</p><h2 id="2-9-SQL语句逻辑相同，性能却差异巨大？"><a href="#2-9-SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="2.9 SQL语句逻辑相同，性能却差异巨大？"></a>2.9 SQL语句逻辑相同，性能却差异巨大？</h2><h3 id="条件字段函数"><a href="#条件字段函数" class="headerlink" title="条件字段函数:"></a>条件字段函数:</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换:"></a>隐式类型转换:</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>tradeid 的字段类型是 varchar(32)，而输入的参数却是整型，所以需要做类型转换。对于优化器来说相当于：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换:"></a>隐式字符编码转换:</h3><p>两张表编码格式不一致也会导致全表查询。</p><h2 id="2-10-为什么我只查一行的语句，也执行这么慢？"><a href="#2-10-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="2.10 为什么我只查一行的语句，也执行这么慢？"></a>2.10 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a><strong>第一类：查询长时间不返回</strong></h3><p><strong>等MDL锁</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>或下面<span class="keyword">sql</span>，可以找出pid（设置 performance_schema<span class="operator">=</span><span class="keyword">on</span>，相比于设置为 off 会有 <span class="number">10</span><span class="operator">%</span> 左右的性能损失）</span><br><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits;</span><br></pre></td></tr></tbody></table></figure><p><strong>等 flush</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>该<span class="keyword">sql</span>可以查询到当前状态</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> id<span class="operator">=</span> <span class="string">'pid'</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果查到如下图所示，则表示有线程正要对表进行flush操作。</p><p><img src="https://static001.geekbang.org/resource/image/39/7e/398407014180be4146c2d088fc07357e.png" alt="var"></p><p>MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></tbody></table></figure><p><strong>等行锁</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span>table_name;</span><br></pre></td></tr></tbody></table></figure><p>KILL pid 断开连接，隐含逻辑自动回滚这个连接里面正在执行的线程，释放行锁</p><h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span><span class="number">50000</span> limit <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果字段c上没有索引，这个语句只能走id主键顺序扫描，需要扫描5万行。</p><h2 id="2-11-幻读是什么，幻读有什么问题？"><a href="#2-11-幻读是什么，幻读有什么问题？" class="headerlink" title="2.11 幻读是什么，幻读有什么问题？"></a>2.11 幻读是什么，幻读有什么问题？</h2><p><strong>幻读</strong></p><ul><li>一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。（幻读在当前读下才会出现；幻读仅专指新插入的行）</li></ul><p><strong>如何解决幻读</strong></p><p>间隙锁（Gap lock）:（两个值之间的锁）。间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。间隙锁为开区间。next-key-lock为前开后闭区间。</p><p><strong>幻读的影响：</strong></p><ul><li>对行锁语义的破坏</li><li>破坏了数据一致性</li></ul><h2 id="2-12-为什么我只改一行的语句，锁这么多？"><a href="#2-12-为什么我只改一行的语句，锁这么多？" class="headerlink" title="2.12 为什么我只改一行的语句，锁这么多？"></a>2.12 为什么我只改一行的语句，锁这么多？</h2><p>文章基于可重复读，读提交就是去掉间隙锁。<br>老师的总结，很好：<br><strong>两个“原则”、两个“优化”和一个“bug”</strong></p><ul><li><p>原则 1：加锁的基本单位是next-key lock。</p></li><li><p>原则 2：查找过程中访问到的对象才会加锁。</p></li><li><p>优化1：索引等值查询，唯一索引，行锁。</p></li><li><p>优化2：索引等值查询，向右遍历且最后一个值不满足等值条件时，next-key lock 退化为间隙锁。</p></li><li><p>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><p><strong>limit加锁</strong><br>limit删除数据时，只会扫描limit行数，不会继续扫描，所以加锁粒度更小。<br><strong>在删除数据时，尽量加limit。</strong></p></li></ul><h2 id="2-13-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#2-13-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="2.13 MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>2.13 MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>max_connections<br>wait_timeout 参数，一个线程空闲这么多秒后自动断开连接。</p><ul><li>断开占着连接不工作线程，先考虑事务外进程。<strong>服务端主动断开连接，客户端不一定能正确处理。</strong></li><li>减少连接过程的消耗，–skip-grant-tables 参数，不安全。</li></ul><h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><ul><li>索引问题<br>建索引<br>主备架构，先增加备库索引。更新前执行set sql_log_bin=off。</li><li>语句问题</li><li>qps突增问题</li></ul><h2 id="2-14-MySQL是怎么保证数据不丢的？"><a href="#2-14-MySQL是怎么保证数据不丢的？" class="headerlink" title="2.14 MySQL是怎么保证数据不丢的？"></a>2.14 MySQL是怎么保证数据不丢的？</h2><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p><h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a><strong>binlog 的写入机制</strong></h3><p>事务执行，把日志写到binlog cache，事务提交，把binlog cache写到binlog文件中，binlog不同事务分头写，所以不需要锁。<br>一个事务的binlog不能被拆开。<br>每个线程分配一个binlog cache，binlog_cache_size控制，超过这个参数要暂存磁盘。</p><p><img src="https://static001.geekbang.org/resource/image/9e/3e/9ed86644d5f39efb0efec595abb92e3e.png" alt="var"></p><p>上图说明事务提交时，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空binlog cache。<br>图中的write只是写文件系统的page cache。</p><p><strong>write 和 fsync 的时机，</strong>是由参数 sync_binlog 控制的：</p><ol><li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li><li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li><li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li></ol><h3 id="redo-log写入机制"><a href="#redo-log写入机制" class="headerlink" title="redo log写入机制"></a>redo log写入机制</h3><p><img src="https://static001.geekbang.org/resource/image/9d/d4/9d057f61d3962407f413deebc80526d4.png" alt="var"></p><p>redo log buffer不需要每次都持久化硬盘，mysql异常重启，这部分日志就会丢失。<br>未提交的事务可能会被持久化到硬盘。</p><p>关于控制刷盘的innodb_flush_log_at_trx_commit参数，在02 | 日志系统：一条SQL更新语句是如何执行的中提到过。<br>Innodb还有一个后台线程，每隔一秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的件系统的 page cache，然后调用 fsync 持久化到磁盘。</p><p>除了后台线程每秒一次的轮询，还有两个场景会让一个没有提交的事务的redo log刷盘。</p><ol><li>​当redo log buffer占用空间即将达到innodb_log_buffer_size一半时，后台线程会主动刷盘。该动作只是写到page cache。</li><li>并行事务提交时，会顺带刷盘。A事务写了一些redo log buffer，另一个事务B提交，innodb_flush_log_at_trx_commit=1，所以事务B要把redo log buffer的日志全部刷盘。这时会把事务A在redo log buffer日志一起刷盘。</li></ol><p>如果把innodb_flush_log_at_trx_commit设置成1，redo log在prepare需持久化一次，所以在15 | 答疑文章（一）：日志和索引相关问题中，提到redo log 已经prepare，并且已经写完binlog就可以异常恢复。</p><p>每秒一次后台轮询刷盘，再加上崩溃恢复的逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。<br><strong>组提交（group commit）机制</strong><br>日志逻辑序列号（log sequence number，LSN）是单调递增的，用来对应 redo log 的写入点。每次写入长度为 length 的 redo log，LSN 的值就会加上 length。<br>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log<br>如果 binlog 写完盘以后发生 crash，这时候还没给客户端答复就重启了。等客户端再重连进来，发现事务已经提交成功了，这不是 bug。</p><p><strong>数据库的 crash-safe 保证的是：</strong></p><p>如果客户端收到事务成功的消息，事务就一定持久化了；<br>如果客户端收到事务失败（比如主键冲突、回滚等）的消息，事务就一定失败了；<br>如果客户端收到“执行异常”的消息，应用需要重连后通过查询当前状态来继续后续的逻辑。此时数据库只需要保证内部（数据和日志之间，主库和备库之间）一致就可以了。</p><h2 id="2-15-MySQL是怎么保证主备一致的？"><a href="#2-15-MySQL是怎么保证主备一致的？" class="headerlink" title="2.15 MySQL是怎么保证主备一致的？"></a>2.15 MySQL是怎么保证主备一致的？</h2><h3 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h3><p><img src="https://static001.geekbang.org/resource/image/fd/10/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="var"></p><p>备库设置成read only防止双写情况方式。read only对超级权限用户无效，所以可以同步。</p><p><img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="var"></p><p>上图展示了update主从同步的过程。</p><p><strong>binlog 的三种格式对比</strong></p><p>​<strong>statement 格式</strong>下，记录到 binlog 里的是语句原文;</p><p>​<strong>row 格式</strong>的时候，binlog 里面记录了真实删除行的主键 id</p><p>​<strong>mixed 格式</strong>  </p><p>​MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式</p><h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>实际生产上使用比较多的是双 M 结构。</p><p><img src="https://static001.geekbang.org/resource/image/20/56/20ad4e163115198dc6cf372d5116c956.png" alt="var"></p><p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。<br>下面逻辑可以解决两个节点间的循环复制的问题：</p><p>规定两个库的 server id 必须不同；</p><ol><li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li><li>每个库收到主库发来的日志，判断server id是否和自己相同，相同直接丢弃日志。</li></ol><h2 id="2-16-MySQL是怎么保证高可用的？"><a href="#2-16-MySQL是怎么保证高可用的？" class="headerlink" title="2.16 MySQL是怎么保证高可用的？"></a>2.16 MySQL是怎么保证高可用的？</h2><p><strong>主备延迟</strong></p><ol><li>主库A完成事务写入binlog，这个时刻记为T1；</li><li>之后传给备库B，备库接受完binlog的时刻记为T2；</li><li>备库B执行完这个事务记为T3。<ul><li>所谓主备延迟，就是同一个事务T3-T1。</li><li>在备库执行show slave status 命令，seconds_behind_master显示了当前备库延迟，精度秒。</li></ul></li></ol><p><strong>延迟来源：</strong></p><ol><li>为了省钱，备库机器较差。</li><li>备库常用来读，查询压力大。一般可以这样处理：一主多从，或者通过binlog输出到外部系统，比如Hadoop。</li><li>大事务，因为主库上必须等事务执行完成才会写入binlog。</li><li>大表DDL。</li><li>主备延迟的一个大方向原因，备库的并行复制能力。</li></ol><h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><p>优先考虑。<br>在上图双M结果下，从状态1到状态2切换的详细过程：</p><ol><li>判断备库B现在的seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li><li>把主库A改成只读状态，即把readonly 设置成true；</li><li>判断备库 B 的 seconds_behind_master的值，直到这个值变成 0 为止；</li><li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false；</li><li>把业务请求切到备库 B。<br>上述切换流程，一般由专门的HA系统完成，但会存在一段时间都不可用时间。</li></ol><h3 id="可靠性异常切换"><a href="#可靠性异常切换" class="headerlink" title="可靠性异常切换"></a>可靠性异常切换</h3><p>假设，主库A和备库B主备延迟30分钟，这时A掉电，HA系统要切换B作为主库。<br><img src="https://img-blog.csdnimg.cn/20190126190150658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这时必须等到备库B seconds_behind_master=0 之后，才能切换。</p><h2 id="2-17-备库为什么会延迟好几个小时？"><a href="#2-17-备库为什么会延迟好几个小时？" class="headerlink" title="2.17 备库为什么会延迟好几个小时？"></a>2.17 备库为什么会延迟好几个小时？</h2><p>主备复制的流程图在24 | MySQL是怎么保证主备一致的提过了。<br>备库通过sql_thread更新数据，5.6版本之前只支持单线程复制，所以主库并发高、TPS高会出现严重的主备延迟。</p><p><img src="https://static001.geekbang.org/resource/image/bc/45/bcf75aa3b0f496699fd7885426bc6245.png" alt="var"></p><p>上图为改进的多线程复制模型，coordinator为原来的sql_thread，但不再直接更新数据，只负责中转日志和分发事务。worker数量由参数 slave_parallel_workers 决定（32核推荐配置8~16）。<br><strong>coordinator分发需满足两个基本要求：</strong></p><ol><li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</li><li>同一个同一个事务不能被拆开，必须放到同一个worker 中。</li></ol><p><strong>并行复制策略</strong></p><ol><li>按库分发，hash库名到一个worker 中，MySQL 5.6 版本的并行复制策略。</li><li>按表分发，需将相同表hash到一个worker 中。</li><li>按行分发，按“库名 + 表名 + 唯一索引 a 的名字 +a 的值”hash到一个worker 中。<br>MariaDB 利用了redo log 组提交 (group commit)特性，因为能在一组中提交，一定不会修改同一行。</li></ol><p>MySQL 5.7 并行复制策略由参数 slave-parallel-type 来控制，配置成DATABASE使用5.6版本的策略，LOGICAL_CLOCK使用MariaDB 的策略，但进行了优化（针对两阶段提交）。</p><p>MySQL 5.7.22 新增了一个并行复制策略，基于 WRITESET 的并行复制。</p><p>ps：复制策略比较复杂，只是记录一下。</p><h2 id="2-18-读写分离有哪些坑？"><a href="#2-18-读写分离有哪些坑？" class="headerlink" title="2.18 读写分离有哪些坑？"></a>2.18 读写分离有哪些坑？</h2><p>带 proxy 的读写分离架构</p><p><img src="https://static001.geekbang.org/resource/image/1b/45/1b1ea74a48e1a16409e9b4d02172b945.jpg" alt="var"></p><p><strong>强制走主库方案</strong><br>对于一些需要拿到实时结果的请求，分发到主库上。但对一些都需要实时结果的金融业务，就需要放弃读写分离。</p><p><strong>sleep方案</strong><br>延迟几秒再去读从库，但超过这个时间的同步还是拿不到最新的数据。</p><p><strong>判断主备无延迟方案</strong><br>判断show slave status 结果里的 seconds_behind_master 参数的值是否等于0，但该值精度为秒。<br>对比位点确保主备无延迟，Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。<br>对比 GTID 集合确保主备无延迟，Retrieved_Gtid_Set、Executed_Gtid_Set是否相同。、</p><p>上述方案，只会判断从库已经收到的事务，是否执行完，但对于一些主库已执行，但从库还没收到的情况，还是存在主备延迟。<br><strong>配合 semi-sync</strong><br>要解决这个问题，就要引入半同步复制，也就是semi-sync replication。</p><ol><li>事务提交的时候，主库把 binlog 发给从库；</li><li>从库收到 binlog 以后，发回给主库一个 ack，表示收收到；</li><li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。<br>但一主多从的情况主库只要收到一个从库返回ack，就会提交事务。所以在查询其他从库时，可能还是会存在主备延迟。<br>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</li></ol><p><strong>等主库位点方案</strong></p><p>实际上并不需要等待主备完全同步，其实从库查询trx1时只需要该事务完成就可以返回：</p><ol><li><p>它是在从库执行的；</p></li><li><p>参数 file 和 pos 指的是主库上的文件名和位置；</p></li><li><p>timeout 可选，设置为正整数 N 表示这个函数最多等待N 秒。</p><p>这个会返回一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。除了正常返回之外，还会返回：</p></li><li><p>如果执行期间，备库同步线程发生异常，则返回 NULL；</p></li><li><p>如果等待超过 N 秒，就返回 -1；</p></li><li><p>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</p></li></ol><p><strong>所以可以这么判断：</strong></p><ol><li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的File 和 Position；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select master_pos_wait(File, Position, 1)；</li><li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。<br>所以可能存在将流量打到主库的情况，所以需要做好主库限流策略。</li></ol><h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><ol><li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li><li>超时返回 1。</li></ol><p>MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p><ol><li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li><li>选定一个从库执行查询语句；</li><li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li><li>如果返回值是 0，则在这个从库执行查询语句；</li><li>否则，到主库执行查询语句。</li></ol><h2 id="2-19-如何判断一个数据库是不是出问题了"><a href="#2-19-如何判断一个数据库是不是出问题了" class="headerlink" title="2.19 如何判断一个数据库是不是出问题了"></a>2.19 如何判断一个数据库是不是出问题了</h2><p><strong>select 1 判断</strong><br>当前并发查询数超过innodb_thread_concurrency时， select 1会返回，但执行查询命令时会等待。<br>该参数默认值是0，表示不限制并发查询数，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。不是并发连接数。</p><p><strong>查表判断</strong><br>在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.health_check; </span><br></pre></td></tr></tbody></table></figure><p>但有其他一个问题，更新事务要写 binlog，binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p><p><strong>更新判断</strong><br>常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。但备库不能写同一行，所以需要使用多行，id为server_id。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mysql.health_check <span class="keyword">set</span> t_modified<span class="operator">=</span>now();</span><br></pre></td></tr></tbody></table></figure><p>但有可能，机器的I/O已经100%，但刚好健康检查的sql拿到了资源，成功返回了。</p><p><strong>内部统计</strong><br>关于磁盘利用率100%的问题。<br>MySQL 5.6 版本以后提供的 performance_schema 库，就在 file_summary_by_event_name 表里统计了每次 IO 请求的时间。</p><p>老师比较倾向的方案，是优先考虑 update 系统表，，然后再配合增加检测 performance_schema的信息。</p><h2 id="2-20-误删数据后除了跑路，还能怎么办？"><a href="#2-20-误删数据后除了跑路，还能怎么办？" class="headerlink" title="2.20 误删数据后除了跑路，还能怎么办？"></a>2.20 误删数据后除了跑路，还能怎么办？</h2><p><strong>误删行</strong><br>binlog_format=row 和 binlog_row_image=FULL 可以使用Flashback回放。<br>不建议直接在主库使用，应该在备库执行，然后再将确认过的临时库的数据，恢复回主库。</p><p><strong>误删库 / 表</strong><br>取全量备份，和全量备份时间点之后的binlog恢复。但mysqlbinlog不够快。<br>一个加速的方法，将全量备份恢复的临时实例，设置为线上备库的从库。</p><p><strong>延迟复制备库</strong><br>MySQL 5.6 版本引入，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有N 秒的延迟。</p><h2 id="2-21-为什么还有kill不掉的语句？"><a href="#2-21-为什么还有kill不掉的语句？" class="headerlink" title="2.21 为什么还有kill不掉的语句？"></a>2.21 为什么还有kill不掉的语句？</h2><p>kill query + 线程 id：表示终止这个线程中正在执行的语句；<br>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</p><p>mysql kill命令不是直接终止线程。</p><p>把 session 的运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；<br>给 session 的执行线程发一个信号。有些session 由于锁在等待，信号让session 退出等待来处理THD::KILL_QUERY 状态。<br>mysql处理过程中有许多埋点，这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑。</p><p>如果碰到一个被 killed 的事务一直处于回滚状态，尽量不要重启，因为重启之后该做的回滚动作还是不能少的，所以从恢复速度的角度来说，应该让它自己结束。如果这个语句可能会占用别的锁，或者由于占用 IO 资源过多，从而影响到了别的语句执行的话，就需要先做主备切换，切到新主库提供服务。<strong>避免大事务</strong></p><h2 id="2-22-我查这么多数据，会不会把数据库内存打爆？"><a href="#2-22-我查这么多数据，会不会把数据库内存打爆？" class="headerlink" title="2.22 我查这么多数据，会不会把数据库内存打爆？"></a>2.22 我查这么多数据，会不会把数据库内存打爆？</h2><p><strong>全表扫描对 server 层的影响</strong></p><p><img src="https://static001.geekbang.org/resource/image/a0/bd/a027c300d7dde8cea4fad8f34b670ebd.jpg"></p><p>net_buffer由参数 net_buffer_length 定义的，默认是 16k。<br>mysql是遍读遍发的，所以当net_buffer写满的时候就需要等待。使用show processlist可以看到state=“Sending to client”。<br>mysql还要一个state=“Sending data”，它的意思只是“正在执行”。<br><strong>全表扫描对 InnoDB 的影响</strong><br>介绍 WAL 机制时，分析了Buffer Pool 加速更新的作用。Buffer Pool 还有一个更重要的作用，就是加速查询。<br>执行 show engine innodb status可以查看一个系统当前的 BP 命中率。<br>InnoDB Buffer Pool 的大小是由参数 innodb_buffer_pool_size 确定的，一般建议设置成可用物理内存的 60%~80%。</p><p>InnoDB 内存管理用的是最近最少使用 (LRU) 算法，这个算法的核心就是淘汰最久未使用的数据。<br>如果在查询历史数据使用这个算法，会导致很多请求会从磁盘读取数据。所以mysql对LRU算法进行了改进。<br><img src="https://static001.geekbang.org/resource/image/21/28/21f64a6799645b1410ed40d016139828.png"></p><p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。</p><ol><li><p>访问数据页P3，在young区所以把它移到链表同步。</p></li><li><p>如果访问不存在的数据，则把链表尾部数据淘汰，但把新数据页Px放在LRU_old处。</p></li><li><p>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：</p><p>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；</p><p>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。<br>1s由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</p></li></ol><h2 id="2-23-到底可不可以使用join？"><a href="#2-23-到底可不可以使用join？" class="headerlink" title="2.23 到底可不可以使用join？"></a>2.23 到底可不可以使用join？</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> idata;</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a><strong>Index Nested-Loop Join</strong></h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.a);</span><br></pre></td></tr></tbody></table></figure><p>t1 是驱动表，t2 是被驱动表。</p><p><img src="https://static001.geekbang.org/resource/image/4b/90/4b9cb0e0b83618e01c9bfde44a0ea990.png"></p><ol><li>从表 t1 中读入一行数据 R；</li><li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li><li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li></ol><p>t1只有100行，所有一共扫描200行。<br>如果执行select * from t1，再执行select * from t2 where a=$R.a。虽然都可以走索引，也只扫描200行。但需要执行101行sql。<br>如果可以走索引：</p><ol><li>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</li><li>如果使用 join 语句的话，需要让小表做驱动表。</li></ol><h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><p>如果驱动表用不上索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></tbody></table></figure><p>因为t2.b没有索引，所以需要全表扫描。总共需扫描100*1000行。</p><p>MySQL 没有使用 Simple Nested-Loop Join 算法，而是使用了“Block Nested-Loop Join”算法，简称BNL。</p><h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p><img src="https://static001.geekbang.org/resource/image/15/73/15ae4f17c46bf71e8349a8f2ef70d573.jpg"></p><ol><li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select <em>，因此是把整个表 t1 放入了内存；</em></li><li><em>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。<br>虽然都会扫描100</em>1000行，但BNL是内存判断，所以会快一点。</li></ol><p>不使用索引字段 join 的 explain 结果</p><p><img src="https://static001.geekbang.org/resource/image/67/e1/676921fa0883e9463dd34fb2bc5e87e1.png"></p><p><strong>小结</strong></p><ol><li>如果可以使用被驱动表的索引，join 语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用 BNL 算法，这样的语句就尽量不要使用；</li><li>在使用 join 的时候，应该让小表做驱动表。<br>如果被驱动表是个大表，会把冷数据的page加入到buffer pool，并且BNL要扫描多次，两次扫描的时间可能会超过1秒，使上节提到的分代LRU优化失效，把热点数据从buffer pool中淘汰掉，影响正常业务的查询效率。</li></ol><h2 id="2-24-join语句怎么优化？"><a href="#2-24-join语句怎么优化？" class="headerlink" title="2.24 join语句怎么优化？"></a>2.24 join语句怎么优化？</h2><h3 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h3><p>回忆一下回表。回表是指，InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键 id 的值到主键索引上去查整行数据的过程。<br>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的。</p><p><img src="https://static001.geekbang.org/resource/image/d5/c7/d502fbaea7cac6f815c626b078da86c7.jpg" alt="123"></p><p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。<br>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。<br>MRR 优化的设计思路：</p><ol><li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li><li>将 read_rnd_buffer 中的 id 进行递增排序；</li><li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li></ol><p>read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制。如果想要稳定地使用 MRR 优化的话，需要设置set optimizer_switch=“mrr_cost_based=off”，如果不设置，优化器会判断消耗，倾向于不使用MRR。</p><h3 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h3><p>MySQL 在 5.6 版本后开始引入的 Batched Key Acess(BKA) 算法了。其实就是对 NLJ 算法的优化。<br>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。<br>BKA 算法就是缓存多行传给其他表，流程如下：<br><img src="https://static001.geekbang.org/resource/image/68/88/682370c5640244fa3474d26cc3bc0388.png"></p><p>启动BKA：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span>;</span><br></pre></td></tr></tbody></table></figure><p>BNL 算法的性能问题<br>上篇文章末尾说了，如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到LRU 链表头部。<br>为了减少这种影响，可以考虑增大join_buffer_size 的值，减少对被驱动表的扫描次数。</p><p>优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法。<br>还可以考虑使用临时表。使用临时表的大致思路是：</p><ol><li><p>把表 t2 中满足条件的数据放在临时表 tmp_t 中；</p></li><li><p>为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；</p></li><li><p>让表 t1 和 tmp_t 做 join 操作。<br><strong>sql如下：</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> temp_t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(b))engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> b<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">&lt;=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b<span class="operator">=</span>temp_t.b);</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="扩展-hash-join"><a href="#扩展-hash-join" class="headerlink" title="扩展 -hash join"></a><strong>扩展 -hash join</strong></h3><p>mysql目前还没有hash索引，MariaDB支持。<br>所以可以自己实现在业务端。实现流程大致如下：</p><ol><li>select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构；</li><li>select * from t2 where b&gt;=1 and b&lt;=2000; 获取表 t2 中满足条件的 2000 行数据。</li><li>把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li></ol><p>这个过程会比临时表方案的执行速度还要快一些。</p><h2 id="2-25-为什么临时表可以重名？"><a href="#2-25-为什么临时表可以重名？" class="headerlink" title="2.25 为什么临时表可以重名？"></a>2.25 为什么临时表可以重名？</h2><p>上节提到了临时表。<br>如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。<br><strong>临时表的特点：</strong></p><ol><li>临时表只能被创建它的 session 访问，对其他线程不可见。所以在这个 session 结束的时候，会自动删除临时表。</li><li>临时表可以与普通表同名（还是不要这么做）。</li><li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li><li>show tables 命令不显示临时表。</li></ol><p><strong>临时表的应用</strong><br>分表分库跨库查询,分库分表系统都有一个中间层 proxy，如果 sql 能够直接确定某个分表，这种情况是最理想的。<br>但如果涉及到跨库，一般有两种方式</p><ol><li>在 proxy 层的进程代码中实现排序，但对 proxy 的功能和性能要求较高。</li><li>把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。如果每个分库的计算量都不饱和，那么直接可以在把临时表放到某个分库上</li></ol><p><strong>为什么临时表可以重名？</strong><br>MySQL 要给临时 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。<br>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。可以使用 select @@tmpdir 命令，来显示实例的临时文件目录。<br>表中数据存放：</p><ol><li>MySQL5.6 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</li><li>MySQL5.7版本开始引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li></ol><p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key</p><ol><li>一个普通表的 table_def_key 的值是由“库名+ 表名”得到。</li><li>临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</li></ol><p><strong>临时表和主备复制</strong><br>      如果当前的 binlog_format=row，那么跟临时表有关的语句，就不会记录到 binlog 里。<br>      binlog_format=statment/mixed 的时候，binlog 中才会记录临时表的操作。<br>      这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 DROP TEMPORARY TABLE 传给执行。</p><h2 id="2-26-什么时候会使用内部临时表？"><a href="#2-26-什么时候会使用内部临时表？" class="headerlink" title="2.26 什么时候会使用内部临时表？"></a>2.26 什么时候会使用内部临时表？</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行这条语句</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> id <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><p>这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p><p>下图是这个语句的 explain 结果。</p><p><img src="https://static001.geekbang.org/resource/image/40/4e/402cbdef84eef8f1b42201c6ec4bad4e.png"></p><ul><li>第二行key=PRIMARY，说明第二个子句用到了索引 id</li><li>第三行 Extra 字段，说明 UNION 时使用了临时表 (Using temporary)</li></ul><p><strong>执行流程：</strong></p><ol><li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</li><li>执行第一个子查询，得到 1000 这个值，并存入临时表中。</li><li>执行第二个子查询：拿到第一个1000，但已存在存入失败，拿到第二个999，存入成功。</li><li>从临时表中按行取出数据（1000和999两行），返回结果，并删除临时表。<br>如果把上面这个语句中的 union 改成 union all的话，就不需要“去重”。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</li></ol><h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><p>另外一个常见的使用临时表的例子是 group by，我们来看一下这个语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></tbody></table></figure><p>这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果如下：</p><p><img src="https://static001.geekbang.org/resource/image/3d/98/3d1cb94589b6b3c4bb57b0bdfa385d98.png"></p><ol><li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li><li>Using temporary，表示使用了临时表；</li><li>Using filesort，表示需要排序。</li></ol><p><strong>执行流程：</strong></p><ol><li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li><li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；如果临时表中没有主键为 x 的行，就插入一个记录 (x,1)，如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</li><li>遍历完成后，再根据字段 m 做排序（内存临时表的排序 17 篇文章有），得到结果集返回给客户端。</li></ol><p>如果不需要排序则直接取内存临时表的数据。</p><p>但内存临时表的大小是有限制的，参数 tmp_table_size 就是控制这个内存大小的，默认是 16M。如果内存不够则使用磁盘临时表。</p><h3 id="group-by-优化方法"><a href="#group-by-优化方法" class="headerlink" title="group by 优化方法"></a><strong>group by 优化方法</strong></h3><p><strong>索引</strong><br>假设有个这样的数据结构：</p><p><img src="https://static001.geekbang.org/resource/image/5c/19/5c4a581c324c1f6702f9a2c70acddd19.jpg"></p><p>如果可以确保输入的数据是有序的，那么计算 group by 的时候，就只需要从左到右，顺序扫描，依次累加。</p><p>当碰到第一个 1 的时候，已经知道累积了 X 个 0，结果集里的第一行就是 (0,X);<br>当碰到第一个 2 的时候，已经知道累积了 Y 个 1，结果集里的第二行就是 (1,Y);<br>InnoDB 的索引，就可以满足这个输入有序的条件。</p><p><strong>直接排序</strong><br>如果临时表数据量特别大，可让 MySQL 直接走磁盘临时表，在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint）。<br>MySQL 的优化器会直接用数组来存，而不是B+ 树存储。这样</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_BIG_RESULT id<span class="operator">%</span><span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></tbody></table></figure><p><strong>执行流程：</strong></p><ol><li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li><li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li><li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ol><p>总结：<br>MySQL 什么时候会使用内部临时表？</p><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果</li><li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li><li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li></ol><h3 id="group-by使用的指导原则："><a href="#group-by使用的指导原则：" class="headerlink" title="group by使用的指导原则："></a><strong>group by使用的指导原则：</strong></h3><ol><li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li><li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li><li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li><li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li></ol><h2 id="2-27-都说InnoDB好，那还要不要使用Memory引擎？"><a href="#2-27-都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="2.27 都说InnoDB好，那还要不要使用Memory引擎？"></a>2.27 都说InnoDB好，那还要不要使用Memory引擎？</h2><h3 id="内存表的数据组织结构"><a href="#内存表的数据组织结构" class="headerlink" title="内存表的数据组织结构"></a>内存表的数据组织结构</h3><p>表 t1 使用 Memory 引擎， 表 t2 使用InnoDB 引擎。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>Memory;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://static001.geekbang.org/resource/image/3f/e6/3fb1100b6e3390357d4efff0ba4765e6.png"></p><p>可以看到两个引擎顺序不一致。<br>InnoDB 表的数据就放在主键索引树上，主键索引是 B+ 树。<br>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。</p><p>内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。主键 id 是 hash 索引，可以看到索引上的 key 并不是有序的。<br>在内存表 t1 中，执行 select * 按数组顺序全表扫描。因此，0 就是最后一个被读到。</p><p><img src="https://static001.geekbang.org/resource/image/dd/84/dde03e92074cecba4154d30cd16a9684.jpg"></p><p><strong>所以InnoDB 和 Memory 引擎的数据组织方式是不同的：</strong></p><ol><li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li><li>Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li></ol><p><strong>两个引擎的一些典型不同：</strong></p><ol><li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li><li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li><li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li><li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li><li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li></ol><p>由于内存表的这些特性，每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用。<br>内存表 t1 的这个主键索引是哈希索引，因此如果执行范围查询是用不上主键索引的，需要走全表扫描。</p><h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p>内存表也是支 B-Tree 索引的</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index a_btree_index <span class="keyword">using</span> btree (id);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20190323155045583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4Y2MxMzE0,size_16,color_FFFFFF,t_70"></p><p>不建议你在生产环境上使用内存表<br>这里的原因主要包括<strong>两个方面：</strong></p><ol><li>内存表的锁<br>内存表不支持行锁，只支持表锁。</li><li>数据持久性问题<br>数据库重启的时候，所有的内存表都会被清空。<br>主从模式，从库掉电重启收到主库请求会找不到行。双主模式下，一台掉电重启会发送delete到另一台清空数据。</li></ol><p>第 35 和 36 篇说到的用户临时表。在数据量可控，不会耗费过多内存的情况下，你可以考虑使用内存表</p><h2 id="2-28-自增主键为什么不是连续的？"><a href="#2-28-自增主键为什么不是连续的？" class="headerlink" title="2.28 自增主键为什么不是连续的？"></a>2.28 自增主键为什么不是连续的？</h2><p><strong>不同的引擎对于自增值的保存策略不同。</strong></p><ul><li>MyISAM 引擎的自增值保存在数据文件中。</li><li>InnoDB 引擎保存在内存里，MySQL 8.0 版本后才有自增值持久化能力，记录在redo log中。MySQL 5.7 及之前的版本，每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。</li></ul><p><strong>自增值修改机制</strong></p><p>如果字段 id 被定义为 AUTO_INCREMENT</p><ol><li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li><li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li></ol><p>假设，某次要插入的值是 X，当前的自增值是 Y。</p><ol><li>如果 X&lt;Y，那么这个表的自增值不变；</li><li>如果&gt;=Y，就需要把当前自增值修改为新的自增值。</li></ol><p>新的自增值生成算法是：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。（双主架构可以设置一个库的自增id都是奇数，另一个都是偶数）。</p><p><strong>自增值的修改时机</strong><br>自增值会在插入数据之前自增。<br>所以唯一键冲突是导致自增主键 id 不连续的第一种原因。类似，事务回滚也会产生类似的现象。</p><p><strong>自增锁的优化</strong><br>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p><ol><li>0,语句执行结束后才释放锁；</li><li>1,普通 insert 语句，自增锁在申请之后就马上释放；类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li><li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请自增主键的动作都是申请后就释放锁。</li></ol><p>生产上，如果有insert … select、replace … select 和 load data 语句，这种批量插入数据的场景时，建议设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row。<br>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。所以如果多申请了id也会导致自增主键 id 不连续。</p><p>普通insert语句，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p><h2 id="2-29-怎么最快地复制一张表？"><a href="#2-29-怎么最快地复制一张表？" class="headerlink" title="2.29 怎么最快地复制一张表？"></a>2.29 怎么最快地复制一张表？</h2><p>如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用 insert … select 语句即可实现。<br>表结构：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create database db1;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line">create table t(id int primary key, a int, b int, index(a))engine=innodb;</span><br><span class="line">delimiter ;;</span><br><span class="line">  create procedure idata()</span><br><span class="line">  begin</span><br><span class="line">    declare i int;</span><br><span class="line">    set i=1;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      insert into t values(i,i,i);</span><br><span class="line">      set i=i+1;</span><br><span class="line">    end while;</span><br><span class="line">  end;;</span><br><span class="line">delimiter ;</span><br><span class="line">call idata();</span><br><span class="line"></span><br><span class="line">create database db2;</span><br><span class="line">create table db2.t like db1.t</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="mysqldump-方法"><a href="#mysqldump-方法" class="headerlink" title="mysqldump 方法"></a>mysqldump 方法</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="comment">--add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>导出结果</p><p><img src="https://static001.geekbang.org/resource/image/8a/de/8acdcefcaf5c9940570bf7e8f73dbdde.png"></p><h3 id="导出-CSV-文件"><a href="#导出-CSV-文件" class="headerlink" title="导出 CSV 文件"></a>导出 CSV 文件</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>导出</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.t <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">'/server_tmp/t.csv'</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>导入</span><br><span class="line">load data infile <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></tbody></table></figure><p><strong>物理拷贝方法</strong><br>在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。<br>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r：</p><ol><li>执行 create table r like t，创建一个相同表结构的空表；</li><li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li><li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li><li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li><li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li><li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li></ol><h2 id="2-30-grant之后要跟着flush-privileges吗？"><a href="#2-30-grant之后要跟着flush-privileges吗？" class="headerlink" title="2.30 grant之后要跟着flush privileges吗？"></a>2.30 grant之后要跟着flush privileges吗？</h2><p>先创建一个用户：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'ua'</span>@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'pa'</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>这条命令做了两个动作：</strong></p><ol><li><p>磁盘上，往 mysql.user 表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是 N；</p></li><li><p>内存里，往数组 acl_users 里插入一个 acl_user 对象，这个对象的 access 字段值为 0。<br><strong>全局权限</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 增加权限</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 取消权限</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">'ua'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>db 权限</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure><p>grant 操作对于已经存在的连接的影响，在全局权限和基于 db 的权限效果是不同的。如果当前会话已经处于某一个 db 里面， use 这个库的时候拿到的库权限会保存在会话变量中，所以 revoke 会不生效。</p><p><strong>表权限和列权限</strong><br>表权限定义存放在表 mysql.tables_priv 中，列权限定义存放在表 mysql.columns_priv 中。这两类权限，组合起来存放在内存的 hash 结构 column_priv_hash 中。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db1.t1(id <span class="type">int</span>, a <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.t1 <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(id), <span class="keyword">INSERT</span> (id,a) <span class="keyword">ON</span> mydb.mytbl <span class="keyword">TO</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure><h3 id="flush-privileges-使用场景"><a href="#flush-privileges-使用场景" class="headerlink" title="flush privileges 使用场景"></a><strong>flush privileges 使用场景</strong></h3><p>正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令，因为会同时刷新内存数据。<br>但当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态。这种不一致往往是由不规范的操作导致的，比如直接用 DML 语句操作系统权限表。</p><h2 id="2-31-要不要使用分区表？"><a href="#2-31-要不要使用分区表？" class="headerlink" title="2.31 要不要使用分区表？"></a>2.31 要不要使用分区表？</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `ftime` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY (`ftime`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2017</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>) ENGINE <span class="operator">=</span> InnoDB,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> LESS THAN MAXVALUE ENGINE <span class="operator">=</span> InnoDB);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">'2017-4-1'</span>,<span class="number">1</span>),(<span class="string">'2018-4-1'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>磁盘文件</p><p><img src="https://static001.geekbang.org/resource/image/06/f5/06f041129783533de9c75580f9decdf5.png"></p><ol><li>对于引擎层来说，这是 4 个表；</li><li>对于 Server 层来说，这是 1 个表。</li></ol><h3 id="分区表的引擎层行为"><a href="#分区表的引擎层行为" class="headerlink" title="分区表的引擎层行为"></a>分区表的引擎层行为</h3><p><img src="https://static001.geekbang.org/resource/image/d2/c7/d28d6ab873bd8337d88812d45b9266c7.png"></p><p><img src="https://static001.geekbang.org/resource/image/92/5c/92f63aba0b24adefac7316c75463b95c.jpg"></p><p>由于分区表的规则，session A 的 select 语句其实只操作了分区 p_2018。<br>如果是MyISAM则锁表p_2018 。</p><p><strong>手动分表和分区表有什么区别</strong><br>分区表和手工分表，一个是由 server 层来决定使用哪个分区，一个是由应用层代码来决定使用哪个分表。因此，从引擎层看，这两种方式也是没有差别的。<br>主要区别在server 层上，分区表一个被广为诟病的问题：打开表的行为。</p><p><strong>分区策略</strong><br>MyISAM 引擎每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。MySQL 启动的时候，open_files_limit 参数使用的是默认值 1024，如果超过上限将报错。InnoDB 引擎的话，并不会出现这个问题。</p><p><strong>分区表的 server 层行为</strong><br>如果从 server 层看的话，一个分区表就只是一个表。</p><p>虽然 session B 只需要操作 p_2107 这个分区，但是由于 session A 持有整个表 t 的 MDL 锁，就导致了 session B 的 alter 语句被堵住。</p><p><strong>分区表的应用场景</strong><br>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。<br>按照时间分区的分区表，就可以直接通过 alter tablet drop partition …这个语法删掉分区，从而删掉过期的历史数据。</p><h2 id="2-32-自增id用完怎么办？"><a href="#2-32-自增id用完怎么办？" class="headerlink" title="2.32 自增id用完怎么办？"></a>2.32 自增id用完怎么办？</h2><h3 id="表定义自增值-id"><a href="#表定义自增值-id" class="headerlink" title="表定义自增值 id"></a>表定义自增值 id</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> unsigned auto_increment <span class="keyword">primary</span> key) auto_increment<span class="operator">=</span><span class="number">4294967295</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 成功插入一行 <span class="number">4294967295</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="comment">/* CREATE TABLE `t` (</span></span><br><span class="line"><span class="comment">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Duplicate entry <span class="string">'4294967295'</span> <span class="keyword">for</span> key <span class="string">'PRIMARY'</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>主键冲突，如果 4 个字节无符号整型 (unsigned int) 不够用的情况下，可以使用 8 个字节的 bigint unsigned。</p><h3 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h3><p>如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。<br>如果到达上限后，再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0，然后继续循环。所以会导致覆盖数据。</p><h3 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h3><p>redo log 和 binlog 相配合的时候，它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。<br>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。<br>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是唯一的。<br>不过 global_query_id 达到上限后，会继续从 0 开始计数，由于 global_query_id 为8个字节，所以一般不会出现到达上限的情况。</p><h3 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h3><p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid ，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。<br>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。<br>InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。<br>对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。<br>但是对于只读事务，InnoDB 并不会分配 trx_id。</p><p>max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能到达上限，然后从 0 开始的情况。然后就会导致脏读。但只存在理论上，如果一个 MySQL 实例的 TPS 是每秒 50 万，持续这个压力的话，在 17.8 年后，就会出现这个情况。</p><h3 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h3><p>show processlist 里面的第一列，就是 thread_id。<br>系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。<br>thread_id_counter 定义的大小是 4 个字节，到达上限则从0开始。</p><h1 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3.常见命令"></a>3.常见命令</h1><h2 id="3-1-重新统计索引信息"><a href="#3-1-重新统计索引信息" class="headerlink" title="3.1 重新统计索引信息"></a>3.1 重新统计索引信息</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-2-查询长事务超过60秒"><a href="#3-2-查询长事务超过60秒" class="headerlink" title="3.2 查询长事务超过60秒"></a>3.2 查询长事务超过60秒</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-3-重建表"><a href="#3-3-重建表" class="headerlink" title="3.3 重建表"></a>3.3 重建表</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> A engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></tbody></table></figure><h2 id="3-4-查看索引基数"><a href="#3-4-查看索引基数" class="headerlink" title="3.4 查看索引基数"></a>3.4 查看索引基数</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> INDEX <span class="keyword">from</span> t;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++其他21-36</title>
      <link href="/2023/02/28/c-qi-ta-21-36/"/>
      <url>/2023/02/28/c-qi-ta-21-36/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之其余问题</h1><h2 id="21、什么情况会自动生成默认构造函数？"><a href="#21、什么情况会自动生成默认构造函数？" class="headerlink" title="21、什么情况会自动生成默认构造函数？"></a>21、什么情况会自动生成默认构造函数？</h2><ol><li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。</li></ol><p>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</p><p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</p><ol start="2"><li><p>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</p></li><li><p>带有一个虚函数的类</p></li><li><p>带有一个虚基类的类</p></li><li><p>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p></li></ol><p id="抽象基类为什么不能创建对象"></p><h2 id="22、抽象基类为什么不能创建对象？"><a href="#22、抽象基类为什么不能创建对象？" class="headerlink" title="22、抽象基类为什么不能创建对象？"></a>22、抽象基类为什么不能创建对象？</h2><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p><p>1、抽象类的定义：<br>   称带有纯虚函数的类为抽象类。</p><p>2、抽象类的作用：<br>   抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p><p>3、  抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p><p>抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。</p><p>4、纯虚函数定义<br> 纯虚函数是一种特殊的虚函数，它的一般格式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt; 　{ 　<span class="keyword">virtual</span> &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>; 　… 　}; </span><br></pre></td></tr></tbody></table></figure><p> 　　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br> 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p><p> 5、纯虚函数引入原因<br>  1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。<br>  2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。<br> 　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。<br> 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.</p><p>6、相似概念<br> 1、多态性</p><p>指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。<br> 　a.编译时多态性：通过重载函数实现<br> 　b.运行时多态性：通过虚函数实现。<br> 2、虚函数<br> 　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。<br> 3、抽象类<br> 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</p><p id="模板类和模板函数的区别是什么"></p><h2 id="23、模板类和模板函数的区别是什么？"><a href="#23、模板类和模板函数的区别是什么？" class="headerlink" title="23、模板类和模板函数的区别是什么？"></a>23、模板类和模板函数的区别是什么？</h2><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指</p><p>定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加&lt;T&gt;，而函数模板不必</p><p id="多继承的优缺点作为一个开发者怎么看待多继承"></p><h2 id="24、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#24、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="24、多继承的优缺点，作为一个开发者怎么看待多继承"></a>24、多继承的优缺点，作为一个开发者怎么看待多继承</h2><ol><li><p>C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</p></li><li><p>多重继承的优点很明显，就是对象可以调用多个基类中的接口；</p></li><li><p>如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性</p></li><li><p>加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。</p></li><li><p>使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。</p></li></ol><p id="模板和实现可不可以不写在一个文件里面为什么"></p><h2 id="25、模板和实现可不可以不写在一个文件里面？为什么？"><a href="#25、模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="25、模板和实现可不可以不写在一个文件里面？为什么？"></a>25、模板和实现可不可以不写在一个文件里面？为什么？</h2><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p><p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br> 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p><p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><p id="将字符串helloworld从开始到打印到屏幕上的全过程"></p><h2 id="26、将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#26、将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="26、将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>26、将字符串“hello world”从开始到打印到屏幕上的全过程?</h2><p>1.用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p><p>2．操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p><p>3．操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p><p>4．操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</p><p>5．执行helloworld程序的第一条指令，发生缺页异常</p><p>6．操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p><p>7．helloword程序执行puts函数（系统调用），在显示器上写一字符串</p><p>8．操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</p><p>9．操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</p><p>10．视频硬件将像素转换成显示器可接收和一组控制数据信号</p><p>11．显示器解释信号，激发液晶屏</p><p>12．OK，我们在屏幕上看到了HelloWorld</p><p id="为什么拷贝构造函数必须传引用不能传值"></p><h2 id="27、为什么拷贝构造函数必须传引用不能传值？"><a href="#27、为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="27、为什么拷贝构造函数必须传引用不能传值？"></a>27、为什么拷贝构造函数必须传引用不能传值？</h2><ol><li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li><li>参数传递过程到底发生了什么？<br> 将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！<br>a 值传递:<br> 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；<br> 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li></ol><p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p><p>b 引用传递:<br>   无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br> 上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p><p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p><p id="静态函数能定义为虚函数吗长函数呢"></p><h2 id="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"><a href="#28、静态函数能定义为虚函数吗？常函数呢？说说你的理解" class="headerlink" title="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"></a>28、静态函数能定义为虚函数吗？常函数呢？说说你的理解</h2><p>1、static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p><p>2、静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p><p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p><p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function。</p><p id="虚函数的代价"></p><h2 id="29、虚函数的代价是什么？"><a href="#29、虚函数的代价是什么？" class="headerlink" title="29、虚函数的代价是什么？"></a>29、虚函数的代价是什么？</h2><ol><li><p>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；</p></li><li><p>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；</p></li><li><p>不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数。</p></li></ol><p id="说一说你了解到的移动构造函数"></p><h2 id="30、说一说你了解到的移动构造函数？"><a href="#30、说一说你了解到的移动构造函数？" class="headerlink" title="30、说一说你了解到的移动构造函数？"></a>30、说一说你了解到的移动构造函数？</h2><ol><li><p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li><li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</p></li><li><p>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</p></li><li><p>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p></li><li></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Example6</span> (Example6&amp;&amp; x) : <span class="built_in">ptr</span>(x.ptr) </span><br><span class="line">  {</span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line">  {</span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line">   ptr = x.ptr;</span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="什么时候合成构造函数都说一说你知道的都说一下"></p><h2 id="31、-什么情况下会合成构造函数？都说一说，你知道的都说一下"><a href="#31、-什么情况下会合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="31、 什么情况下会合成构造函数？都说一说，你知道的都说一下"></a>31、 什么情况下会合成构造函数？都说一说，你知道的都说一下</h2><ol><li><p>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</p></li><li><p>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</p></li><li><p>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</p></li><li><p>带有一个虚基类的类</p></li></ol><p> 还有一点需要注意的是：</p><ol><li><p>并不是任何没有构造函数的类都会合成一个构造函数</p></li><li><p>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</p></li></ol><p id="那什么时候需要合成拷贝构造函数呢"></p><h2 id="32、那什么时候需要合成拷贝构造函数呢？"><a href="#32、那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="32、那什么时候需要合成拷贝构造函数呢？"></a>32、那什么时候需要合成拷贝构造函数呢？</h2><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p><ol><li><p>对一个对象做显示的初始化操作，X xx = x;</p></li><li><p>当对象被当做参数交给某个函数时；</p></li><li><p>当函数传回一个类对象时；</p></li><li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p></li><li><p>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</p></li><li><p>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</p></li><li><p>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</p></li></ol><p id="构造函数的执行顺序是什么"></p><h2 id="33、构造函数的执行顺序是什么？"><a href="#33、构造函数的执行顺序是什么？" class="headerlink" title="33、构造函数的执行顺序是什么？"></a>33、构造函数的执行顺序是什么？</h2><ol><li><p>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</p></li><li><p>对象的vptr被初始化；</p></li><li><p>如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；</p></li><li><p>执行程序员所提供的代码；</p></li></ol><p id="一个类中的全部构造函数的扩展过程是什么"></p><h2 id="34、一个类中的全部构造函数的扩展过程是什么？"><a href="#34、一个类中的全部构造函数的扩展过程是什么？" class="headerlink" title="34、一个类中的全部构造函数的扩展过程是什么？"></a>34、一个类中的全部构造函数的扩展过程是什么？</h2><ol><li><p>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</p></li><li><p>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</p></li><li><p>如果class有虚表，那么它必须被设定初值；</p></li><li><p>所有上一层的基类构造函数必须被调用；</p></li><li><p>所有虚基类的构造函数必须被调用。</p></li></ol><p id="哪些函数不能是虚函数把你知道的都说一说"></p><h2 id="35、哪些函数不能是虚函数？把你知道的都说一说"><a href="#35、哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="35、哪些函数不能是虚函数？把你知道的都说一说"></a>35、哪些函数不能是虚函数？把你知道的都说一说</h2><ol><li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p></li><li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p></li><li><p>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p></li><li><p>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p></li><li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p></li></ol><p id="什么是纯虚函数与虚函数的区别"></p><h2 id="36、什么是纯虚函数，与虚函数的区别"><a href="#36、什么是纯虚函数，与虚函数的区别" class="headerlink" title="36、什么是纯虚函数，与虚函数的区别"></a>36、什么是纯虚函数，与虚函数的区别</h2><p><strong>虚函数和纯虚函数区别</strong>？</p><ul><li><p>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</p></li><li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</p></li></ul><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。</p><p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p><p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"普通虚函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"子类实现的纯虚函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Base* b = <span class="keyword">new</span> Son;</span><br><span class="line">b-&gt;<span class="built_in">fun1</span>(); <span class="comment">//普通虚函数</span></span><br><span class="line">b-&gt;<span class="built_in">fun2</span>(); <span class="comment">//子类实现的纯虚函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="reference"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote><p>《C++中的虚函数》<a href="https://blog.csdn.net/wuchuanpingstone/article/details/6742465">https://blog.csdn.net/wuchuanpingstone/article/details/6742465</a></p><p>《C++虚函数简介》<a href="https://blog.csdn.net/xiaoyanilw/article/details/108575035">https://blog.csdn.net/xiaoyanilw/article/details/108575035</a></p><p>《C++ Map用法》<a href="https://blog.csdn.net/sevenjoin/article/details/81943864">https://blog.csdn.net/sevenjoin/article/details/81943864</a></p><p>《C++中堆（heap）和栈(stack)的区别》：<a href="https://blog.csdn.net/qq_34175893/article/details/83502412">https://blog.csdn.net/qq_34175893/article/details/83502412</a></p><p>《虚函数表存放在哪里》：<a href="https://blog.csdn.net/u013270326/article/details/82830656">https://blog.csdn.net/u013270326/article/details/82830656</a></p><p>《<a href="https://www.cnblogs.com/ITziyuan/p/9487760.md">C语言与C++有什么区别？</a>》<a href="https://www.cnblogs.com/ITziyuan/p/9487760.md">https://www.cnblogs.com/ITziyuan/p/9487760.md</a></p><p>《C++和java的区别和联系》：<a href="https://www.cnblogs.com/tanrong/p/8503202.md">https://www.cnblogs.com/tanrong/p/8503202.md</a></p><p>《struct结构在C和C++中的区别》：<a href="https://blog.csdn.net/mm_hh/article/details/70456240">https://blog.csdn.net/mm_hh/article/details/70456240</a></p><p>《C++ 顶层const与底层const总结》：<a href="https://www.jianshu.com/p/fbbcf11100f6">https://www.jianshu.com/p/fbbcf11100f6</a></p><p>《C++的顶层const和底层const浅析》：<a href="https://blog.csdn.net/qq_37059483/article/details/78811231">https://blog.csdn.net/qq_37059483/article/details/78811231</a></p><p>《C++:override和final》：<a href="https://www.cnblogs.com/whlook/p/6501918.md">https://www.cnblogs.com/whlook/p/6501918.md</a></p><p>C++的直接初始化与复制初始化的区别：<a href="https://blog.csdn.net/qq936836/article/details/83450218">https://blog.csdn.net/qq936836/article/details/83450218</a></p><p>《extern “C”的功能和用法研究》：<a href="https://blog.csdn.net/sss_369/article/details/84060561">https://blog.csdn.net/sss_369/article/details/84060561</a></p><p>《类和函数模板特例化》：<a href="https://blog.csdn.net/wang664626482/article/details/52372789">https://blog.csdn.net/wang664626482/article/details/52372789</a></p><p>《C++实现多态的原理》：<a href="https://blog.csdn.net/qq_37954088/article/details/79947898">https://blog.csdn.net/qq_37954088/article/details/79947898</a></p><p>《浅谈C++中的几种构造函数》：<a href="https://blog.csdn.net/zxc024000/article/details/51153743">https://blog.csdn.net/zxc024000/article/details/51153743</a></p><p>《C++面试题之浅拷贝和深拷贝的区别》：<a href="https://blog.csdn.net/caoshangpa/article/details/79226270">https://blog.csdn.net/caoshangpa/article/details/79226270</a></p><p>《构造函数、析构函数、虚函数可否内联，有何意义》：<a href="https://www.cnblogs.com/helloweworld/archive/2013/06/14/3136705.md">https://www.cnblogs.com/helloweworld/archive/2013/06/14/3136705.md</a></p><p>《auto和decltype的用法总结》：<a href="https://www.cnblogs.com/XiangfeiAi/p/4451904.md">https://www.cnblogs.com/XiangfeiAi/p/4451904.md</a></p><p>《C++11新特性中auto 和 decltype 区别和联系》：<a href="https://www.jb51.net/article/103666.htm">https://www.jb51.net/article/103666.htm</a></p><p>《写程序判断系统是大端序还是小端序》：<a href="https://www.cnblogs.com/zhoudayang/p/5985563.md">https://www.cnblogs.com/zhoudayang/p/5985563.md</a></p><p>《C++拷贝构造函数详解》：<a href="https://www.cnblogs.com/alantu2018/p/8459250.md">https://www.cnblogs.com/alantu2018/p/8459250.md</a></p><p>《【C++】几种类型的new介绍》：<a href="https://www.jianshu.com/p/9b57e769c3cb">https://www.jianshu.com/p/9b57e769c3cb</a></p><p>《NULL和nullptr区别》：<a href="https://blog.csdn.net/qq_39380590/article/details/82563571">https://blog.csdn.net/qq_39380590/article/details/82563571</a></p><p>《C/C++内存管理详解》：<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p><p>《C++异常处理（try catch throw）完全攻略》：<a href="http://c.biancheng.net/view/422.md">http://c.biancheng.net/view/422.md</a></p><p>《C++STL 》<a href="https://www.bilibili.com/video/BV1db411q7B8?p=12">https://www.bilibili.com/video/BV1db411q7B8?p=12</a> </p><p>《C++内存管理》<a href="https://www.bilibili.com/video/BV1Kb411B7N8?p=25">https://www.bilibili.com/video/BV1Kb411B7N8?p=25</a></p><p>《C++中的 trivial destructor》：<a href="https://blog.csdn.net/wudishine/article/details/12307611">https://blog.csdn.net/wudishine/article/details/12307611</a></p><p>《C++封装继承多态总结》：<a href="https://blog.csdn.net/IOT_SHUN/article/details/79674293">https://blog.csdn.net/IOT_SHUN/article/details/79674293</a></p><p>《C++类对象成员变量和函数内存分配的问题》：<a href="https://blog.csdn.net/z2664836046/article/details/78967313">https://blog.csdn.net/z2664836046/article/details/78967313</a></p><p>《为什么用成员初始化列表会快一些？》：<a href="https://blog.csdn.net/JackZhang_123/article/details/82590368">https://blog.csdn.net/JackZhang_123/article/details/82590368</a></p><p>《为什么C++不能有虚构造函数，却可以有虚析构函数》：<a href="https://dwz.cn/lnfW9H6m">https://dwz.cn/lnfW9H6m</a></p><p>《构造函数或者析构函数中调用虚函数会怎么样？》：<a href="https://dwz.cn/TaJTJONX">https://dwz.cn/TaJTJONX</a></p><p>《智能指针的原理及实现》：<a href="https://blog.csdn.net/lizhentao0707/article/details/81156384">https://blog.csdn.net/lizhentao0707/article/details/81156384</a></p><p>《C++构造函数的default和delete》：<a href="https://blog.csdn.net/u010591680/article/details/71101737">https://blog.csdn.net/u010591680/article/details/71101737</a></p><p>《C/C++函数调用过程分析》：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.md">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.md</a></p><p>《C/C++函数调用的压栈模型》：<a href="https://blog.csdn.net/m0_37717595/article/details/80368411">https://blog.csdn.net/m0_37717595/article/details/80368411</a></p><p>《C++临时变量不能作为函数的返回值？》：<a href="https://www.wandouip.com/t5i204349/">https://www.wandouip.com/t5i204349/</a></p><p>《C++中this指针的用法详解》<a href="http://blog.chinaunix.net/uid-21411227-id-1826942.md">http://blog.chinaunix.net/uid-21411227-id-1826942.md</a></p><p>《C++ 智能指针（及循环引用问题）》：<a href="https://blog.csdn.net/m0_37968340/article/details/76737395">https://blog.csdn.net/m0_37968340/article/details/76737395</a></p><p>《C++中的静态绑定和动态绑定》：<a href="https://www.cnblogs.com/lizhenghn/p/3657717.md">https://www.cnblogs.com/lizhenghn/p/3657717.md</a></p><p>《C++经典面试题》：<a href="https://www.cnblogs.com/yjd_hycf_space/p/7495640.md">https://www.cnblogs.com/yjd_hycf_space/p/7495640.md</a></p><p>《C++ 虚函数表解析》：<a href="https://blog.csdn.net/haoel/article/details/1948051/">https://blog.csdn.net/haoel/article/details/1948051/</a></p><p>《操作系统（三）》：<a href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5">https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5</a></p><p>《互斥锁、读写锁、自旋锁、条件变量的特点总结》：<a href="https://blog.csdn.net/RUN32875094/article/details/80169978">https://blog.csdn.net/RUN32875094/article/details/80169978</a></p><p>《c++右值引用以及使用》：<a href="https://www.cnblogs.com/likaiming/p/9045642.md">https://www.cnblogs.com/likaiming/p/9045642.md</a></p><p>《从4行代码看右值引用》：<a href="https://www.cnblogs.com/likaiming/p/9029908.md">https://www.cnblogs.com/likaiming/p/9029908.md</a></p><p>《Free的前世今生》<a href="https://blog.csdn.net/YMY_me/article/details/811801">https://blog.csdn.net/YMY_me/article/details/811801</a></p><p>《友元函数和友元类》：<a href="https://www.cnblogs.com/zhuguanhao/p/6286145.md">https://www.cnblogs.com/zhuguanhao/p/6286145.md</a></p><p>《程序员求职宝典》王道论坛</p><p>《STL源码解析》侯捷</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++其他1-20</title>
      <link href="/2023/02/27/c-qi-ta-1-20/"/>
      <url>/2023/02/27/c-qi-ta-1-20/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之其余问题</h1><p id="如何实现"></p><h2 id="1、C-的多态如何实现"><a href="#1、C-的多态如何实现" class="headerlink" title="1、C++的多态如何实现"></a>1、C++的多态如何实现</h2><p>C++的多态性，<strong>一言以蔽之</strong>就是：</p><p>在基类的函数前加上<strong>virtual</strong>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">" Base::func()"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">" Son1::func()"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base{</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Base* base = <span class="keyword">new</span> Son1;</span><br><span class="line">base-&gt;<span class="built_in">fun</span>();</span><br><span class="line">base = <span class="keyword">new</span> Son2;</span><br><span class="line">base-&gt;<span class="built_in">fun</span>();</span><br><span class="line"><span class="keyword">delete</span> base;</span><br><span class="line">base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// Son1::func()</span></span><br><span class="line"><span class="comment">// Base::func()</span></span><br></pre></td></tr></tbody></table></figure><p>例子中，Base为基类，其中的函数为虚函数。</p><p>子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？</p><p>这里需要引出虚表和虚基表指针的概念。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022619.png"></p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022551.png"></p><p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p><p><strong>（1）</strong>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</p><p><strong>（2）</strong>编译器会在每个对象的前四个字节中保存一个虚表指针，即<strong>vptr</strong>，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p><p><strong>（3）</strong>所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p><strong>（4）</strong>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p><p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p><p id="为什么析构函数一般写成虚函数"></p><h2 id="2、为什么析构函数一般写成虚函数"><a href="#2、为什么析构函数一般写成虚函数" class="headerlink" title="2、为什么析构函数一般写成虚函数"></a>2、为什么析构函数一般写成虚函数</h2><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p><p>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent construct function"</span>  &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">~<span class="built_in">Parent</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent destructor function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Son construct function"</span>  &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">~<span class="built_in">Son</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Son destructor function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></tbody></table></figure><p>将基类的析构函数声明为虚函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Parent</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent construct function"</span>  &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Parent</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Parent destructor function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Son construct function"</span>  &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">~<span class="built_in">Son</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"Son destructor function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Son destructor function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></tbody></table></figure><p>但存在一种特例，在<code>CRTP</code>模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应<br>该声明为虚函数，因为这种继承方式，不需要虚函数表。</p><blockquote><p id="构造函数能否声明为虚函数或者纯虚函数析构函数呢"></p></blockquote><h2 id="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h2><p>析构函数：</p><ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li><li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul><p>构造函数：</p><ul><li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li><li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li></ul><blockquote><p id="基类的虚函数表存放在内存的什么区虚表指针vptr的初始化时间"></p></blockquote><h2 id="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h2><p>首先整理一下虚函数表的特征：</p><ul><li><p>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</p></li><li><p>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</p></li><li><p>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</p></li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</p><p>虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p><p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区</p><p>C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong> </p><p id="模板函数和模板类的特例化"></p><h2 id="5、模板函数和模板类的特例化"><a href="#5、模板函数和模板类的特例化" class="headerlink" title="5、模板函数和模板类的特例化"></a>5、模板函数和模板类的特例化</h2><p><strong>引入原因</strong></p><p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p><p><strong>定义</strong></p><p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p><p><strong>（1）模板函数特例化</strong></p><p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1,<span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v1,<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>本质</strong></p><p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p><p><strong>注意</strong></p><p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p><p><strong>（2）类模板特例化</strong></p><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;sales_data&gt;</span><br><span class="line">{</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(sales_data&amp; s)</span></span>;</span><br><span class="line"><span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line"><span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>类模板的部分特例化</strong></p><p>不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><p><strong>特例化类中的部分成员</strong></p><p><strong>可以特例化类中的部分成员函数而不是整个类</strong>，举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"我是int型特例化"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></tbody></table></figure><p id="构造函数析构函数虚函数可否声明为内联函数"></p><h2 id="6、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#6、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="6、构造函数、析构函数、虚函数可否声明为内联函数"></a>6、构造函数、析构函数、虚函数可否声明为内联函数</h2><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><blockquote><p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率<br>举个例子：</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"inline construct()"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">inline</span> ~<span class="built_in">A</span>() {</span><br><span class="line">cout &lt;&lt; <span class="string">"inline destruct()"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">virtualFun</span><span class="params">()</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"inline virtual function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">virtualFun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//inline construct()</span></span><br><span class="line"><span class="comment">//inline virtual function</span></span><br><span class="line"><span class="comment">//inline destruct()</span></span><br></pre></td></tr></tbody></table></figure><p><strong>构造函数和析构函数声明为内联函数是没有意义的</strong></p><p>《Effective C++》中所阐述的是：<strong>将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简</strong>。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p> <strong>将虚函数声明为inline，要分情况讨论</strong></p><p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p><p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p><p><strong>综上</strong>，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。</p><p id="你知道底层怎么实现的"></p><h2 id="7、C-模板是什么，你知道底层怎么实现的？"><a href="#7、C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="7、C++模板是什么，你知道底层怎么实现的？"></a>7、C++模板是什么，你知道底层怎么实现的？</h2><ol><li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p></li><li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p></li></ol><p id="构造函数为什么不能为虚函数析构函数为什么要虚函数"></p><h2 id="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h2><p><strong>1、 从存储空间角度，</strong>虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。</p><p>问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p><p><strong>2、 从使用角度，</strong>虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。</p><p>构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。</p><p>所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p><p><strong>3、构造函数不须要是虚函数，也不同意是虚函数，</strong>由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p><p><strong>4、从实现上看，</strong>vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</p><p><strong>5、当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。</strong></p><p>因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。</p><p>并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。</p><p>VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。</p><p>因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。</p><p>直接的讲，C++中基类采用virtual虚析构函数是<strong>为了防止内存泄漏。</strong></p><p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p><p>所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><p id="析构函数的作用如何起作用"></p><h2 id="9、析构函数的作用，如何起作用？"><a href="#9、析构函数的作用，如何起作用？" class="headerlink" title="9、析构函数的作用，如何起作用？"></a>9、析构函数的作用，如何起作用？</h2><ol><li>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</li></ol><p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。 </p><ol start="2"><li>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</li></ol><p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。</p><p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p><p id="构造函数和析构函数可以调用虚函数吗为什么"></p><h2 id="10、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#10、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="10、构造函数和析构函数可以调用虚函数吗，为什么"></a>10、构造函数和析构函数可以调用虚函数吗，为什么</h2><ol><li><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；</p></li><li><p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p></li><li><p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</p></li><li><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p></li></ol><p id="构造函数析构函数的执行顺序构造函数和拷贝构造的内部都干了啥"></p><h2 id="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h2><p><strong>1)     构造函数顺序</strong></p><p>①   基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p><p>②   成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p><p>③   派生类构造函数。</p><p><strong>2)     析构函数顺序</strong></p><p>①   调用派生类的析构函数；</p><p>②   调用成员类对象的析构函数；</p><p>③   调用基类的析构函数。</p><p id="虚析构函数的作用父类的析构函数是否要设置为虚函数"></p><h2 id="12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><a href="#12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？" class="headerlink" title="12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"></a>12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？</h2><ol><li>C++中基类采用virtual虚析构函数是为了防止内存泄漏。</li></ol><p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</p><p>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</p><p>那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p><p>所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><ol start="2"><li>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</li></ol><p>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。</p><p id="构造函数析构函数可否抛出异常"></p><h2 id="13、构造函数析构函数可否抛出异常"><a href="#13、构造函数析构函数可否抛出异常" class="headerlink" title="13、构造函数析构函数可否抛出异常"></a>13、构造函数析构函数可否抛出异常</h2><ol><li>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</li></ol><p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p><ol start="2"><li><p>用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p></li><li><p>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</p></li><li><p>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p></li></ol><p id="构造函数一般不定义为虚函数的原因"></p><h2 id="14、构造函数一般不定义为虚函数的原因"><a href="#14、构造函数一般不定义为虚函数的原因" class="headerlink" title="14、构造函数一般不定义为虚函数的原因"></a>14、构造函数一般不定义为虚函数的原因</h2><p>（1）创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型</p><p>（2）虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了</p><p>（3）虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数</p><p>（4）析构函数一般都要声明为虚函数，这个应该是老生常谈了，这里不再赘述</p><p id="类什么时候会析构"></p><h2 id="15、类什么时候会析构？"><a href="#15、类什么时候会析构？" class="headerlink" title="15、类什么时候会析构？"></a>15、类什么时候会析构？</h2><ol><li><p>对象生命周期结束，被销毁时；</p></li><li><p>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</p></li><li><p>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p></li></ol><p in="构造函数或者析构函数中可以调用"></p><h2 id="16、构造函数或者析构函数中可以调用虚函数吗"><a href="#16、构造函数或者析构函数中可以调用虚函数吗" class="headerlink" title="16、构造函数或者析构函数中可以调用虚函数吗"></a>16、构造函数或者析构函数中可以调用虚函数吗</h2><p>简要结论：</p><ul><li>从语法上讲，调用完全没有问题。</li><li>但是从效果上看，往往不能达到需要的目的。</li></ul><blockquote><p>《Effective C++》的解释是：<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。<br>举个例子：</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">Function</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base::Fuction"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">{</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">Function</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"A::Function"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">{</span><br><span class="line"><span class="built_in">Function</span>();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Base* a = <span class="keyword">new</span> Base;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">cout &lt;&lt; <span class="string">"-------------------------"</span> &lt;&lt;endl;</span><br><span class="line">Base* b = <span class="keyword">new</span> A;<span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">delete</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//A::Function</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br></pre></td></tr></tbody></table></figure><p>语句1讲道理应该体现多态性，执行类A中的构造和析构函数，从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数，析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免</p><p id="构造函数的几种关键字"></p><h2 id="17、构造函数的几种关键字"><a href="#17、构造函数的几种关键字" class="headerlink" title="17、构造函数的几种关键字"></a>17、构造函数的几种关键字</h2><p><strong>default</strong></p><p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">const</span> <span class="type">char</span>* pstr) : _str(pstr){}</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>(){}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string _str;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句2</span></span><br><span class="line">   cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Hello World</span></span><br></pre></td></tr></tbody></table></figure><p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p><p><strong>delete</strong></p><p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>(){}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句1</span></span><br><span class="line">   cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p><p><strong>0</strong></p><p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</p><blockquote><p>update1:感谢微信好友“猿六”指出错误，已修正！</p></blockquote><p id="赋值操作符的区别"></p><h2 id="18、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#18、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="18、构造函数、拷贝构造函数和赋值操作符的区别"></a>18、构造函数、拷贝构造函数和赋值操作符的区别</h2><p><strong>构造函数</strong></p><p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p><p><strong>拷贝构造函数</strong></p><p>对象不存在，但是使用别的已经存在的对象来进行初始化</p><p><strong>赋值运算符</strong></p><p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"我是构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"我是拷贝构造函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"我是赋值操作符"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">A</span>() {};</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">A a1; <span class="comment">//调用构造函数</span></span><br><span class="line">A a2 = a1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">a2 = a1; <span class="comment">//调用赋值操作符</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//我是构造函数</span></span><br><span class="line"><span class="comment">//我是拷贝构造函数</span></span><br><span class="line"><span class="comment">//我是赋值操作符</span></span><br></pre></td></tr></tbody></table></figure><p id="拷贝构造函数和赋值运算符重载的区别"></p><h2 id="19、拷贝构造函数和赋值运算符重载的区别？"><a href="#19、拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="19、拷贝构造函数和赋值运算符重载的区别？"></a>19、拷贝构造函数和赋值运算符重载的区别？</h2><ul><li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li><li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li><li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li><li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作</span></span><br></pre></td></tr></tbody></table></figure></li></ul><p>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</p><p id="什么是虚拟继承"></p><h2 id="20、什么是虚拟继承"><a href="#20、什么是虚拟继承" class="headerlink" title="20、什么是虚拟继承"></a>20、什么是虚拟继承</h2><p>由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C{};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof(A)："</span> &lt;&lt; <span class="keyword">sizeof</span> A &lt;&lt;endl; <span class="comment">// 1，空对象，只有一个占位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof(B)："</span> &lt;&lt; <span class="keyword">sizeof</span> B &lt;&lt;endl; <span class="comment">// 4，一个bptr指针，省去占位,不需要对齐</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof(C)："</span> &lt;&lt; <span class="keyword">sizeof</span> C &lt;&lt;endl; <span class="comment">// 4，一个bptr指针，省去占位,不需要对齐</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"sizeof(D)："</span> &lt;&lt; <span class="keyword">sizeof</span> D &lt;&lt;endl; <span class="comment">// 8，两个bptr，省去占位,不需要对齐</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码所体现的关系是，B和C虚拟继承A，D又公有继承B和C，这种方式是一种<strong>菱形继承或者钻石继承</strong>，可以用如下图来表示</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220025114.png"></p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022397.png"></p><p><strong>虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</strong>虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。</p><p id="什么情况会自动生成默认构造函数"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL21-38</title>
      <link href="/2023/02/26/c-stl21-38/"/>
      <url>/2023/02/26/c-stl21-38/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之STL模板库</h1><p id="allocatordeallocator"></p><h2 id="21、STL中的allocator、deallocator"><a href="#21、STL中的allocator、deallocator" class="headerlink" title="21、STL中的allocator、deallocator"></a>21、STL中的allocator、deallocator</h2><ol><li><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p></li><li><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p></li><li><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p></li><li><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p></li></ol><p id="hashmap扩容发生什么"></p><h2 id="22、STL中hash-table扩容发生什么？"><a href="#22、STL中hash-table扩容发生什么？" class="headerlink" title="22、STL中hash table扩容发生什么？"></a>22、STL中hash table扩容发生什么？</h2><ol><li><p>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</p></li><li><p>向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</p></li></ol><p id="常见容器性质总结"></p><h2 id="23、常见容器性质总结？"><a href="#23、常见容器性质总结？" class="headerlink" title="23、常见容器性质总结？"></a>23、常见容器性质总结？</h2><p>1.vector    底层数据结构为数组 ，支持快速随机访问</p><p>2.list       底层数据结构为双向链表，支持快速增删</p><p>3.deque    底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack    底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue   底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue   的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set          底层数据结构为红黑树，有序，不重复</p><p>8.multiset      底层数据结构为红黑树，有序，可重复 </p><p>9.map         底层数据结构为红黑树，有序，不重复</p><p>10.multimap  底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set   底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复 </p><p>13.unordered_map   底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复 </p><p id="vector的增加删除都是怎么做的为什么是或者是倍"></p><h2 id="24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？"><a href="#24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？" class="headerlink" title="24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？"></a>24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？</h2><ol><li><p>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p></li><li><p>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</p></li><li><p>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</p></li><li><p>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p></li></ol><p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p><ol><li><p>考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</p></li><li><p>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间： </p></li><li><p>向量容器vector的成员函数pop_back()可以删除最后一个元素.</p></li><li><p>而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。</p></li><li><p>还可以采用通用算法remove()来删除vector容器中的元素.</p></li><li><p>不同的是：采用remove一般情况下不会改变容器的大小，而pop_back()与erase()等成员函数会改变容器的大小。</p></li></ol><p id="每种容器对应的迭代器"></p><h2 id="25、说一下STL每种容器对应的迭代器"><a href="#25、说一下STL每种容器对应的迭代器" class="headerlink" title="25、说一下STL每种容器对应的迭代器"></a>25、说一下STL每种容器对应的迭代器</h2><table><thead><tr><th>容器</th><th>迭代器</th></tr></thead><tbody><tr><td>vector、deque</td><td>随机访问迭代器</td></tr><tr><td>stack、queue、priority_queue</td><td>无</td></tr><tr><td>list、(multi)set/map</td><td>双向迭代器</td></tr><tr><td>unordered_(multi)set/map、forward_list</td><td>前向迭代器</td></tr></tbody></table><p id="迭代器失效的情况有哪些"></p><h2 id="26、STL中迭代器失效的情况有哪些？"><a href="#26、STL中迭代器失效的情况有哪些？" class="headerlink" title="26、STL中迭代器失效的情况有哪些？"></a>26、STL中迭代器失效的情况有哪些？</h2><p>以vector为例：</p><p><strong>插入元素：</strong></p><p>1、尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</p><p>2、中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</p><p><strong>删除元素：</strong></p><p>尾后删除：只有尾迭代失效。</p><p>中间删除：删除位置之后所有迭代失效。</p><p> deque 和 vector 的情况类似, </p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器; </p><p>map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++); </p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效. </p><p id="vector的实现"></p><h2 id="27、STL中vector的实现"><a href="#27、STL中vector的实现" class="headerlink" title="27、STL中vector的实现"></a>27、STL中vector的实现</h2><p>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数），源码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> size_type len  = old_size + <span class="built_in">max</span>(old_size, n);</span><br></pre></td></tr></tbody></table></figure><p> Vector扩容倍数与平台有关，在Win +  VS 下是 1.5倍，在 Linux + GCC 下是 2 倍 </p><p>测试代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//在Linux + GCC下</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//4</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在 win 10 + VS2019下</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//3</span></span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//6</span></span><br><span class="line">     </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p><p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响</p><p id="slist的实现"></p><h2 id="28、STL中slist的实现"><a href="#28、STL中slist的实现" class="headerlink" title="28、STL中slist的实现"></a>28、STL中slist的实现</h2><p>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</p><p>slist的单向迭代器如下图所示：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205071953335.png"></p><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allco</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">static</span> list_node* <span class="built_in">create_node</span>(<span class="type">const</span> value_type&amp; x){}<span class="comment">//配置空间、构造元素</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="built_in">destroy_node</span>(list_node* node){}<span class="comment">//析构函数、释放空间</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list_node_base head; <span class="comment">//头部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span></span>{}<span class="comment">//交换两个slist，只需要换head即可</span></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>{} <span class="comment">//取头部元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value&amp; x)</span></span>{}<span class="comment">//头部插入元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>{}<span class="comment">//从头部取走元素</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite1 = fl.<span class="built_in">begin</span>();</span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt;::iterator ite2 = fl.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span>(;ite1 != ite2; ++ite1)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; *ite1 &lt;&lt;<span class="string">" "</span>; <span class="comment">// 5 6 2 3 1</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">ite1 = <span class="built_in">find</span>(fl.<span class="built_in">begin</span>(), fl.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">//寻找2的位置</span></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.<span class="built_in">insert_after</span>(ite1, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">" "</span>;  <span class="comment">//5 6 2 99 3 1</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">ite1 = <span class="built_in">find</span>(fl.<span class="built_in">begin</span>(), fl.<span class="built_in">end</span>(), <span class="number">6</span>); <span class="comment">//寻找6的位置</span></span><br><span class="line"><span class="keyword">if</span> (ite1 != ite2)</span><br><span class="line">fl.<span class="built_in">erase_after</span>(ite1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : fl)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">" "</span>;  <span class="comment">//5 6 99 3 1</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++ 11中出现，它与slist的区别是没有size()方法。</p><p id="list的实现"></p><h2 id="29、STL中list的实现"><a href="#29、STL中list的实现" class="headerlink" title="29、STL中list的实现"></a>29、STL中list的实现</h2><p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</p><p>list节点的结构见如下源码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span>{</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。<br>此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构<br>list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间<br>由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作，这里不再详细阐述。</p><p id="deque的实现"></p>## 30、STL中的deque的实现vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205071953980.png)deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回dequedeque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性deque的数据结构如下：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">itertator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021322.png)deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示。deque的迭代器数据结构如下：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">    T* cur;<span class="comment">//迭代器所指缓冲区当前的元素</span></span><br><span class="line">    T* first;<span class="comment">//迭代器所指缓冲区第一个元素</span></span><br><span class="line">    T* last;<span class="comment">//迭代器所指缓冲区最后一个元素</span></span><br><span class="line">    map_pointer node;<span class="comment">//指向map中的node</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021453.png)deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。<p id="stack和queue的实现"></p>## 31、STL中stack和queue的实现**stack**stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021348.png)stack这种单向开口的数据结构很容易由**双向开口的deque和list**形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>{<span class="keyword">return</span> c.<span class="built_in">empty</span>();}</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>{<span class="keyword">return</span> c.<span class="built_in">size</span>();}</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> c.<span class="built_in">back</span>();}</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>{<span class="keyword">return</span> c.<span class="built_in">back</span>();}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>{c.<span class="built_in">push_back</span>(x);}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>{c.<span class="built_in">pop_back</span>();}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非containerstack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。**queue**queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021436.png)类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>{<span class="keyword">return</span> c.<span class="built_in">empty</span>();}</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>{<span class="keyword">return</span> c.<span class="built_in">size</span>();}</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> c.<span class="built_in">front</span>();}</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>{<span class="keyword">return</span> c.<span class="built_in">front</span>();}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>{c.<span class="built_in">push_back</span>(x);}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>{c.<span class="built_in">pop_front</span>();}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。<p id="heap的实现"></p>## 32、STL中的heap的实现heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021792.png)完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于$i$处，其左节点必定位于$2i$处，右节点位于$2i+1$处，父节点位于$i/2$（向下取整）处。这种以array表示tree的方式称为隐式表述法。因此我们可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，用vector代替array是一个不错的选择。那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。**push_heap插入算法**由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举个例子如下图：![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022842.png)新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足max heap的性质，如果了解大根堆的话，这个原理跟大根堆的调整过程是一样的。**pop_heap算法**heap的pop操作实际弹出的是根节点吗，但在heap内部执行pop_heap时，只是将其移动到vector的最后位置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶节点为止，这个过程称为percolate down（下溯）。举个例子：![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022993.png)根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。**sort算法**一言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。**make_heap算法**将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。代码实测：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = { <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line"><span class="built_in">make_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//以vector为底层容器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>; <span class="comment">// 6 4 5 3 1 0 2</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">push_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>; <span class="comment">// 7 6 5 4 1 0 2 3</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">pop_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>; <span class="comment">// 6 4 5 3 1 0 2</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>; <span class="comment">// 0 1 2 3 4 5 6</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="priorityqueue的实现"></p><h2 id="33、STL中的priority-queue的实现"><a href="#33、STL中的priority-queue的实现" class="headerlink" title="33、STL中的priority_queue的实现"></a>33、STL中的priority_queue的实现</h2><p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022333.png"></p><p>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。关键的源码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Squence</span> = vector&lt;T&gt;, </span><br><span class="line"><span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_tyoe&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> c.<span class="built_in">empty</span>();}</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> c.<span class="built_in">size</span>();}</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> c.<span class="built_in">front</span>()}</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> value_type&amp; x)</span><br><span class="line">    {</span><br><span class="line">        c.<span class="built_in">push_heap</span>(x);</span><br><span class="line">        <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp);</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> ia[<span class="number">9</span>] = {<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span> };</span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq</span><span class="params">(ia, ia + <span class="number">9</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; pq.<span class="built_in">size</span>() &lt;&lt;endl;  <span class="comment">// 9</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pq.<span class="built_in">size</span>(); i++)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">" "</span>; <span class="comment">// 8 8 8 8 8 8 8 8 8</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">' '</span>;<span class="comment">// 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="set的实现"></p><h2 id="34、STL中set的实现？"><a href="#34、STL中set的实现？" class="headerlink" title="34、STL中set的实现？"></a>34、STL中set的实现？</h2><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p><p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p><p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p><p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p><ul><li>每个节点不是红色就是黑色</li><li>根结点为黑色</li><li>如果节点为红色，其子节点必为黑</li><li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li></ul><p>关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">5</span>] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> };</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>); <span class="comment">//再插入一个3</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator b = s.<span class="built_in">begin</span>();</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator e = s.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; b != e; ++b)</span><br><span class="line">cout &lt;&lt; *b &lt;&lt; <span class="string">" "</span>; <span class="comment">// 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">b = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (b != s.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">"5 found"</span> &lt;&lt; endl; <span class="comment">// 5 found</span></span><br><span class="line">b = s.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (b != s.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">"2 found"</span> &lt;&lt; endl; <span class="comment">// 2 found</span></span><br><span class="line">b = s.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (b == s.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">"1 not found"</span> &lt;&lt; endl; <span class="comment">// 1 not found</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。 </p><p id="map的实现"></p><h2 id="35、STL中map的实现"><a href="#35、STL中map的实现" class="headerlink" title="35、STL中map的实现"></a>35、STL中map的实现</h2><p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p><p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator</p><p>标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的架构如下图所示</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022980.png"></p><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; maps;</span><br><span class="line">    <span class="comment">//插入若干元素</span></span><br><span class="line">maps[<span class="string">"jack"</span>] = <span class="number">1</span>;</span><br><span class="line">maps[<span class="string">"jane"</span>] = <span class="number">2</span>;</span><br><span class="line">maps[<span class="string">"july"</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//以pair形式插入</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">"david"</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">maps.<span class="built_in">insert</span>(p);</span><br><span class="line"><span class="comment">//迭代输出元素</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator iter = maps.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; iter != maps.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">"--"</span>; <span class="comment">//david 4--jack 1--jane 2--july 3--</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//使用subscipt操作取实值</span></span><br><span class="line"><span class="type">int</span> num = maps[<span class="string">"july"</span>];</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//查找某key</span></span><br><span class="line">iter = maps.<span class="built_in">find</span>(<span class="string">"jane"</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != maps.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; iter-&gt;second &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//修改实值</span></span><br><span class="line">iter-&gt;second = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> num2 = maps[<span class="string">"jane"</span>]; <span class="comment">// 100</span></span><br><span class="line">cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maps[<span class="string">"abc"</span>] = <span class="number">1</span>; <span class="comment">//左值运用int num = masp["abd"]; //右值运用</span></span><br></pre></td></tr></tbody></table></figure><p>无论如何，subscript操作符都会先根据键值找出实值，源码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k){</span><br><span class="line">    <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">}...</span><br></pre></td></tr></tbody></table></figure><p>代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">value_type</span>(k, <span class="built_in">T</span>());</span><br></pre></td></tr></tbody></table></figure><p>再将这个对象插入到map中，并返回一个pair：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(value_type(k, T()))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first; <span class="comment">//迭代器</span></span><br><span class="line">*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first); <span class="comment">//解引用</span></span><br><span class="line">(*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second; <span class="comment">//取出实值</span></span><br></pre></td></tr></tbody></table></figure><p>由于这个实值是以引用方式传递，因此作为左值或者右值都可以</p><p id="set和map的区别multimap和multiset的区别"></p><h2 id="36、set和map的区别，multimap和multiset的区别"><a href="#36、set和map的区别，multimap和multiset的区别" class="headerlink" title="36、set和map的区别，multimap和multiset的区别"></a>36、set和map的区别，multimap和multiset的区别</h2><p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素</p><p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p><p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 。</p><p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p><p><strong>红黑树概念</strong></p><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><p>1、它是二叉排序树（继承二叉排序树特显）：</p><ul><li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。 </p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。 </p><ul><li>左、右子树也分别为二叉排序树。</li></ul><p>2、它满足如下几点要求： </p><ul><li><p>树中所有节点非红即黑。 </p></li><li><p>根节点必为黑节点。 </p></li><li><p>红节点的子节点必为黑（黑节点子节点可为黑）。 </p></li><li><p>从根到NULL的任何路径上黑结点数相同。</p></li></ul><p>3、查找时间一定可以控制在O(logn)。</p></li></ul><p id="unorderedmap和map的区别和应用场景"></p><h2 id="37、STL中unordered-map和map的区别和应用场景"><a href="#37、STL中unordered-map和map的区别和应用场景" class="headerlink" title="37、STL中unordered_map和map的区别和应用场景"></a>37、STL中unordered_map和map的区别和应用场景</h2><p>  map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p><p>  unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</p><p>  从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p><p id="hashtable中解决冲突有哪些方法"></p><h2 id="38、hashtable中解决冲突有哪些方法？"><a href="#38、hashtable中解决冲突有哪些方法？" class="headerlink" title="38、hashtable中解决冲突有哪些方法？"></a>38、hashtable中解决冲突有哪些方法？</h2><p>  <strong>记住前三个：</strong></p><p>  线性探测</p><p>  使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p><p>  <strong>开链</strong></p><p>  每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p><p>  <strong>再散列</strong></p><p>  发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p><p>  <strong>二次探测</strong></p><p>  使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p><p>  <strong>公共溢出区</strong></p><p>  一旦hash函数计算的结果相同，就放入公共溢出区</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL1-20</title>
      <link href="/2023/02/25/c-stl1-20/"/>
      <url>/2023/02/25/c-stl1-20/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之STL模板库</h1><h2 id="1、什么是STL？"><a href="#1、什么是STL？" class="headerlink" title="1、什么是STL？"></a>1、什么是STL？</h2><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul><p id="解释一下什么是trivialdestructor"></p><h2 id="2、解释一下什么是trivial-destructor"><a href="#2、解释一下什么是trivial-destructor" class="headerlink" title="2、解释一下什么是trivial destructor"></a>2、解释一下什么是trivial destructor</h2><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p><p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数<strong>如果申请了新的空间一定要显式的释放，否则会造成内存泄露</strong></p><p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？</p><p>《STL源码解析》中给出的说明是:</p><p>首先利用value_type()获取所指对象的型别，再利用__type_traits&lt;T&gt;判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数。</p><p>也就是说，在实际的应用当中，STL库提供了相关的判断方法**__type_traits**，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p><p id="使用智能指针管理内存资源"></p><h2 id="3、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#3、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="3、使用智能指针管理内存资源，RAII是怎么回事？"></a>3、使用智能指针管理内存资源，RAII是怎么回事？</h2><ol><li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</li></ol><p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><ol start="2"><li>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</li></ol><p>有了智能指针，代码中几乎不需要再出现delete了。</p><p id="迭代器itit哪个好为什么"></p><h2 id="4、迭代器：-it、it-哪个好，为什么"><a href="#4、迭代器：-it、it-哪个好，为什么" class="headerlink" title="4、迭代器：++it、it++哪个好，为什么"></a>4、迭代器：++it、it++哪个好，为什么</h2><ol><li>前置返回一个引用，后置返回一个对象</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ++i实现代码为：</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line">{</span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)                 </span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p id="说一下左值引用和右值引用"></p><h2 id="5、说一下C-左值引用和右值引用"><a href="#5、说一下C-左值引用和右值引用" class="headerlink" title="5、说一下C++左值引用和右值引用"></a>5、说一下C++左值引用和右值引用</h2><p>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。 </p><ol><li><p>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p></li><li><p>C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p></li><li><p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p></li><li><p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p></li></ol><p><strong>左值和右值</strong></p><p>左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p><p><strong>左值引用和右值引用</strong></p><p>左值引用：传统的C++中引用被称为左值引用</p><p>右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</p><p><strong>右值引用的特点：</strong></p><ul><li>特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</li><li>特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</li><li>特点3：T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;  <span class="comment">//b是左值引用</span></span><br><span class="line"><span class="type">int</span>&amp; c = <span class="number">10</span>;  <span class="comment">//错误，c是左值不能使用右值初始化</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">//正确，右值引用用右值初始化</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; e = a;  <span class="comment">//错误，e是右值引用不能使用左值初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; f = a; <span class="comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; g = <span class="number">10</span>;<span class="comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; h = <span class="number">10</span>; <span class="comment">//正确，右值常引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; aa = h;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span>&amp; i = <span class="built_in">getInt</span>();  <span class="comment">//错误，i是左值引用不能使用临时变量（右值）初始化</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; j = <span class="built_in">getInt</span>();  <span class="comment">//正确，函数返回值是右值</span></span><br><span class="line"><span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">//此时fun函数的参数t是右值</span></span><br><span class="line"><span class="built_in">fun</span>(a); <span class="comment">//此时fun函数的参数t是左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="hashtable的实现"></p><h2 id="6、STL中hashtable的实现？"><a href="#6、STL中hashtable的实现？" class="headerlink" title="6、STL中hashtable的实现？"></a>6、STL中hashtable的实现？</h2><p>STL中的hashtable使用的是<strong>开链法</strong>解决hash冲突问题，如下图所示。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035271.png"></p><p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p><p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</p><p id="简单说一下traits技法"></p><h2 id="7、简单说一下traits技法"><a href="#7、简单说一下traits技法" class="headerlink" title="7、简单说一下traits技法"></a>7、简单说一下traits技法</h2><p>traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p><p><strong>iterator_traits</strong></p><p>被称为<strong>特性萃取机</strong>，能够方便的让外界获取以下5种型别：</p><ul><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：三两句说不清楚，建议看书</li></ul><p><strong>type_traits</strong></p><p>关注的是型别的<strong>特性</strong>，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></tbody></table></figure><p>由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span>{};<span class="keyword">struct</span> <span class="title class_">__false_type</span>{};</span><br></pre></td></tr></tbody></table></figure><p>这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得</p><p>当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt;{</span><br><span class="line"><span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line"><span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line"><span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p id="的两级空间配置器"></p><h2 id="8、STL的两级空间配置器"><a href="#8、STL的两级空间配置器" class="headerlink" title="8、STL的两级空间配置器"></a>8、STL的两级空间配置器</h2><p>1、首先明白为什么需要二级空间配置器？</p><p>我们知道动态开辟内存时，要在堆上申请，但若是我们需要</p><p>频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；</p><p>每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；</p><p>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p><p>于是就设置了二级空间配置器，<strong>当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p><p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</p><h3 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h3><p> <strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：</p><p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p><p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p><p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035143.png"></p><h3 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h3><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035104.png"></p><p>1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p><p>2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：<br>（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。<br>（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。<br>（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。<br>3、内存池为空，申请内存<br>此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。<br>4、malloc没有成功<br>在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p><p>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</p><p>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p><p>2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p><h3 id="一级分配器"><a href="#一级分配器" class="headerlink" title="一级分配器"></a>一级分配器</h3><p>GC4.9之后就没有第一级了，只有第二级</p><h3 id="二级分配器"><a href="#二级分配器" class="headerlink" title="二级分配器"></a>二级分配器</h3><p>——default_alloc_template 剖析</p><p>有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）</p><p>allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc  2*20个块）去内存池去拿或者重新分配。不为空的话</p><p id="vector与list的区别与应用怎么找某vector或者list的倒数第二个元素"></p><h2 id="9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h2><ol><li>vector数据结构<br> vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</li></ol><p>另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</p><p>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</p><ol start="2"><li>list数据结构<br> list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</li></ol><p>区别：</p><ul><li>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。</li><li>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</li><li>从遍历上来说，list是单向的，vector是双向的。</li><li>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</li></ul><ol start="3"><li></li></ol><p>int mySize = vec.size();vec.at(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历：</p><p id="vector删除其中的元素迭代器如何变化"></p><h2 id="10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</h2><p>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</p><p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p><p> resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">resize</span><span class="params">(size_type __new_size, <span class="type">const</span> _Tp&amp; __x)</span> {</span><br><span class="line">      <span class="keyword">if</span> (__new_size &lt; size()) </span><br><span class="line">            erase(begin() + __new_size, end());</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">            insert(end(), __new_size - size(), __x);</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p>1、空的vector对象，size()和capacity()都为0</p><p>2、当空间大小不足时，新分配的空间大小为原空间大小的2倍。</p><p>3、使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</p><p>4、当reserve()分配的空间比原空间小时，是不会引起重新分配的。</p><p>5、resize()函数只改变容器的元素数目，未改变容器大小。</p><p>6、用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</p><p> 不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p><p>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</p><p>使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。</p><p> 对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p><blockquote><p id="如何释放空间"></p></blockquote><h2 id="11、Vector如何释放空间"><a href="#11、Vector如何释放空间" class="headerlink" title="11、Vector如何释放空间?"></a>11、Vector如何释放空间?</h2><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p><p>如果需要空间动态缩小，可以考虑使用deque。</p><p>如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(Vec).<span class="built_in">swap</span>(Vec); <span class="comment">//将Vec中多余内存清除； </span></span><br><span class="line"><span class="built_in">vector</span>().<span class="built_in">swap</span>(Vec); <span class="comment">//清空Vec的全部内存；</span></span><br></pre></td></tr></tbody></table></figure><p>实例</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span> <span class="params">(<span class="number">100</span>,<span class="number">100</span>)</span></span>;   <span class="comment">// three ints with a value of 100</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.size(): "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.capasity(): "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec).<span class="built_in">swap</span>(vec); <span class="comment">//清空vec中多余的空间，相当于vec.shrink_to_fit();</span></span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.size(): "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.capasity(): "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(vec); <span class="comment">//清空vec的全部空间</span></span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.size(): "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">"vec.capasity(): "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">    vec.size(): 102</span></span><br><span class="line"><span class="comment">    vec.capasity(): 200</span></span><br><span class="line"><span class="comment">    vec.size(): 102</span></span><br><span class="line"><span class="comment">    vec.capasity(): 102</span></span><br><span class="line"><span class="comment">    vec.size(): 0</span></span><br><span class="line"><span class="comment">    vec.capasity(): 0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p id="容器内部删除一个元素"></p><h2 id="12、容器内部删除一个元素"><a href="#12、容器内部删除一个元素" class="headerlink" title="12、容器内部删除一个元素"></a>12、容器内部删除一个元素</h2><ol><li>顺序容器（序列式容器，比如vector、deque）</li></ol><p>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p><p>It = c.erase(it);</p><ol start="2"><li>关联容器(关联式容器，比如map、set、multimap、multiset等)</li></ol><p>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p><p>c.erase(it++)</p><p id="迭代器如何实现"></p><h2 id="13、STL迭代器如何实现"><a href="#13、STL迭代器如何实现" class="headerlink" title="13、STL迭代器如何实现"></a>13、STL迭代器如何实现</h2><p>1、 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p><p>2、 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p><p>3、最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p><p id="set是怎么实现的红黑树"></p><h2 id="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h2><ol><li><p>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn时间内完成，因此可以完成高效的插入删除；</p></li><li><p>在这里我们定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</p></li><li><p>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</p></li></ol><p id="如何在共享内存上使用标准库"></p><h2 id="15、如何在共享内存上使用STL标准库？"><a href="#15、如何在共享内存上使用STL标准库？" class="headerlink" title="15、如何在共享内存上使用STL标准库？"></a>15、如何在共享内存上使用STL标准库？</h2><ol><li>想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。</li></ol><p>我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。</p><p>当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。</p><p>一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</p><ol start="2"><li>假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？</li></ol><p>一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。</p><p>进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。</p><p id="map插入方式有哪几种"></p><h2 id="16、map插入方式有哪几种？"><a href="#16、map插入方式有哪几种？" class="headerlink" title="16、map插入方式有哪几种？"></a>16、map插入方式有哪几种？</h2><ol><li>用insert函数插入pair数据，</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">"student_one"</span>)); </span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>用insert函数插入value_type数据</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">"student_one"</span>));</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>在insert函数中使用make_pair()函数</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"student_one"</span>)); </span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>用数组方式插入数据</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">"student_one"</span>; </span><br></pre></td></tr></tbody></table></figure><p id="hashmap如何解决冲突以及扩容"></p><h2 id="17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"></a>17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h2><ol><li><p>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，</p></li><li><p>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p></li><li><p>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，</p></li><li><p>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</p></li><li><p>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</p></li><li><p>unordered_map的底层实现是hash_table;</p></li><li><p>hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</p></li><li><p><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</p></li><li><p>**扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p></li></ol><p id="vector越界访问下标map越界访问下标vector删除元素时会不会释放空间"></p><h2 id="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h2><ol><li><p>通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</p></li><li><p>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</p></li><li><p>erase()函数，只能删除内容，不能改变容量大小;</p></li></ol><p>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</p><blockquote><p id="map中与find的区别"></p></blockquote><h2 id="19、map中-与find的区别？"><a href="#19、map中-与find的区别？" class="headerlink" title="19、map中[]与find的区别？"></a>19、map中[]与find的区别？</h2><ol><li><p>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p></li><li><p>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p></li></ol><p id="list与queue之间的区别"></p><h2 id="20、-STL中list与queue之间的区别"><a href="#20、-STL中list与queue之间的区别" class="headerlink" title="20、 STL中list与queue之间的区别"></a>20、 STL中list与queue之间的区别</h2><ol><li><p>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</p></li><li><p>list插入操作和结合才做都不会造成原有的list迭代器失效;</p></li><li><p>list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</p></li><li><p>list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</p></li><li><p>deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；</p></li><li><p>deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</p></li></ol><p id="allocatordeallocator"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性1-10</title>
      <link href="/2023/02/23/c-11-xin-te-xing-1-10/"/>
      <url>/2023/02/23/c-11-xin-te-xing-1-10/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++11新标准</h1><h2 id="1、C-11有哪些新特性？"><a href="#1、C-11有哪些新特性？" class="headerlink" title="1、C++ 11有哪些新特性？"></a>1、C++ 11有哪些新特性？</h2><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li></ul><ul><li>…</li></ul><p id="autodecltype和decltypeauto的用法"></p><h2 id="2、auto、decltype和decltype-auto-的用法"><a href="#2、auto、decltype和decltype-auto-的用法" class="headerlink" title="2、auto、decltype和decltype(auto)的用法"></a>2、auto、decltype和decltype(auto)的用法</h2><p><strong>（1）auto</strong></p><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p><p><strong>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</strong></p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以k的类型是const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（2）decltype</strong></p><p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，<strong>它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>{<span class="keyword">return</span> <span class="number">0</span>};</span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（3）decltype(auto)</strong></p><p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号右边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></tbody></table></figure><p id="nullptr区别"></p><h2 id="3、C-中NULL和nullptr区别"><a href="#3、C-中NULL和nullptr区别" class="headerlink" title="3、C++中NULL和nullptr区别"></a>3、C++中NULL和nullptr区别</h2><p>算是为了与C语言进行兼容而定义的一个问题吧</p><p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。</p><p>在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"char*"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span> </span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"int"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">fun</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></tbody></table></figure><p>那么<strong>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</strong></p><p>nullptr的一种实现方式如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">nullptr_t</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span>{ <span class="keyword">return</span> <span class="number">0</span>; }</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="type">const</span> { <span class="keyword">return</span> <span class="number">0</span>; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">} <span class="literal">nullptr</span> = {};</span><br></pre></td></tr></tbody></table></figure><p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，<strong>另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。</strong>但nullptr仍然存在一定问题，例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout&lt;&lt; <span class="string">"char* p"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout&lt;&lt; <span class="string">"int* p"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout&lt;&lt; <span class="string">"int p"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">fun</span>((<span class="type">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line"><span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br></pre></td></tr></tbody></table></figure><p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p><p id="智能指针的原理、常用的智能指针及实现"></p><h2 id="4、智能指针的原理、常用的智能指针及实现"><a href="#4、智能指针的原理、常用的智能指针及实现" class="headerlink" title="4、智能指针的原理、常用的智能指针及实现"></a>4、智能指针的原理、常用的智能指针及实现</h2><p><strong>原理</strong></p><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p><p><strong>常用的智能指针</strong></p><p><strong>(1) shared_ptr</strong> </p><p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 </p><ul><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li><li>每次创建类的新对象时，初始化指针并将引用计数置为1</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li><li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li></ul><p><strong>(2) unique_ptr</strong> </p><p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p><p><strong>(3) weak_ptr</strong> </p><p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p><p><strong>(4) auto_ptr</strong> </p><p> 主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p><p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p><p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p><p><strong>智能指针shared_ptr代码实现：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SharedPtr</span>(T* ptr = <span class="literal">NULL</span>):_ptr(ptr), _pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">{}</span><br><span class="line"><span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount){</span><br><span class="line">(*_pcount)++;</span><br><span class="line">}</span><br><span class="line">SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&amp; s){</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (--(*(<span class="keyword">this</span>-&gt;_pcount)) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_pcount;</span><br><span class="line">}</span><br><span class="line">_ptr = s._ptr;</span><br><span class="line">_pcount = s._pcount;</span><br><span class="line">*(_pcount)++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">}</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">SharedPtr</span>()</span><br><span class="line">{</span><br><span class="line">--(*(<span class="keyword">this</span>-&gt;_pcount));</span><br><span class="line"><span class="keyword">if</span> (*(<span class="keyword">this</span>-&gt;_pcount) == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">_ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">_pcount = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">int</span>* _pcount;<span class="comment">//指向引用计数的指针</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p id="说一说你了解的关于lambda函数的全部知识"></p><h2 id="5、说一说你了解的关于lambda函数的全部知识"><a href="#5、说一说你了解的关于lambda函数的全部知识" class="headerlink" title="5、说一说你了解的关于lambda函数的全部知识"></a>5、说一说你了解的关于lambda函数的全部知识</h2><ol><li><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p></li><li><p>每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p></li><li><p>lambda表达式的语法定义如下：</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type {statement};</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</li></ol><p id="智能指针的作用"></p><h2 id="6、智能指针的作用"><a href="#6、智能指针的作用" class="headerlink" title="6、智能指针的作用"></a>6、智能指针的作用</h2><ol><li><p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p></li><li><p>智能指针在C++11版本之后提供，包含在头文件&lt;memory&gt;中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p></li><li><p>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr&lt;int&gt; p4 = new int(1);的写法是错误的</p></li></ol><p>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</p><ol start="4"><li><p>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p></li><li><p>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p></li><li><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.</p></li></ol><p id="说说你了解的autoptr作用"></p><h2 id="7、说说你了解的auto-ptr作用"><a href="#7、说说你了解的auto-ptr作用" class="headerlink" title="7、说说你了解的auto_ptr作用"></a>7、说说你了解的auto_ptr作用</h2><ol><li><p>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</p></li><li><p>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr&lt;Type&gt;类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</p></li><li><p>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</p></li><li><p>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</p></li><li><p>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</p></li><li><p>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</p></li><li><p>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</p></li><li><p>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</p></li></ol><p id="智能指针的循环引用"></p><h2 id="8、智能指针的循环引用"><a href="#8、智能指针的循环引用" class="headerlink" title="8、智能指针的循环引用"></a>8、智能指针的循环引用</h2><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">:_pPre(<span class="literal">NULL</span>)</span><br><span class="line">, _pNext(<span class="literal">NULL</span>)</span><br><span class="line">, _value(value)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"Node()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"~Node()"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">T _value;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">"sp1.use_count:"</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"sp2.use_count:"</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">sp1-&gt;_pNext = sp2; <span class="comment">//sp2的引用+1</span></span><br><span class="line">sp2-&gt;_pPre = sp1; <span class="comment">//sp1的引用+1</span></span><br><span class="line">cout &lt;&lt; <span class="string">"sp1.use_count:"</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"sp2.use_count:"</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">Funtest</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//sp1.use_count:1</span></span><br><span class="line"><span class="comment">//sp2.use_count:1</span></span><br><span class="line"><span class="comment">//sp1.use_count:2</span></span><br><span class="line"><span class="comment">//sp2.use_count:2</span></span><br></pre></td></tr></tbody></table></figure><p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</p><p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p><blockquote><p id="手写实现智能指针类需要实现哪些函数"></p></blockquote><h2 id="9、手写实现智能指针类需要实现哪些函数？"><a href="#9、手写实现智能指针类需要实现哪些函数？" class="headerlink" title="9、手写实现智能指针类需要实现哪些函数？"></a>9、手写实现智能指针类需要实现哪些函数？</h2><ol><li>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</li></ol><p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p><p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p><ol start="2"><li>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；</li></ol><p id="智能指针出现循环引用怎么解决"></p><h2 id="10、智能指针出现循环引用怎么解决？"><a href="#10、智能指针出现循环引用怎么解决？" class="headerlink" title="10、智能指针出现循环引用怎么解决？"></a>10、智能指针出现循环引用怎么解决？</h2><p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存管理1-15</title>
      <link href="/2023/02/23/c-nei-cun-guan-li-1-15/"/>
      <url>/2023/02/23/c-nei-cun-guan-li-1-15/</url>
      
        <content type="html"><![CDATA[<ul><li><h1 align="center">C++内存管理</h1><p id="类的对象存储空间"></p><h2 id="1、类的对象存储空间？"><a href="#1、类的对象存储空间？" class="headerlink" title="1、类的对象存储空间？"></a>1、类的对象存储空间？</h2><ul><li><p>非静态成员的数据类型大小之和。</p></li><li><p>编译器加入的额外成员变量（如指向虚函数表的指针）。</p></li><li><p>为了边缘对齐优化加入的padding。</p></li></ul><p> 空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0. </p><p id="简要说明内存分区"></p><h2 id="2、简要说明C-的内存分区"><a href="#2、简要说明C-的内存分区" class="headerlink" title="2、简要说明C++的内存分区"></a>2、简要说明C++的内存分区</h2><p>C++中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。</p><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p><p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。</p><p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p><p><strong>代码区</strong>：存放函数体的二进制代码</p><p id="什么是内存池如何实现"></p><h2 id="3、什么是内存池，如何实现"><a href="#3、什么是内存池，如何实现" class="headerlink" title="3、什么是内存池，如何实现"></a>3、什么是内存池，如何实现</h2><p>内存池（Memory Pool） 是一种<strong>内存分配</strong>方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><p>《STL源码剖析》中的内存池实现机制**：</p><p><strong>allocate 包装 malloc，deallocate包装free</strong></p><p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小。</p><ol><li>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</li><li>客户端之后有有内存需求，想申请（20*64bytes）的空间，这时内存池只有（20*32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也.</li><li>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</li><li>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</li></ol><p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。</p><p>内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。 </p><p><strong>其实最开始GC2.9之前</strong></p><p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p><p>operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p><p>GC2.9下的alloc函数的一个比较好的分配器的实现规则如下：</p><p>维护一条0-15号的一共16条链表，其中 0 号表示8 bytes ，1 号表示 16 bytes，2 号表示 24 bytes。。。。而15 号表示 16* 8 = 128 bytes。</p><p>如果在申请内存时，申请内存的大小并不是8的倍数（比如2、4、7、9、18这样不是8的倍数），那就找刚好能满足内存大小的链表。比如想申请 12 个大小，那就按照 16 来处理，也就是找 1 号链表了；想申请 20 ，距离它最近的就是 24 了，那就找 2 号链表。</p><p>只许比所要申请的内容大，不许小！</p><p><strong>但是现在GC4.9及其之后</strong> 也还有 alloc 函数，只不过已经变成_pool_alloc这个名字了，名字已经改了，也不再是默认的了。</p><p>你需要自己手动去指定它可以自己指定，比如</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string,__gnu_cxx::pool_alloc&lt;string&gt;&gt; vec;</span><br></pre></td></tr></tbody></table></figure><p>这样来使用它，等于兜兜转转又回到以前那种对malloc和free的包装形式了。</p><p id="可以说一下你了解的内存管理吗"></p><h2 id="4、可以说一下你了解的C-得内存管理吗？"><a href="#4、可以说一下你了解的C-得内存管理吗？" class="headerlink" title="4、可以说一下你了解的C++得内存管理吗？"></a>4、可以说一下你了解的C++得内存管理吗？</h2><p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p><ul><li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li><li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li><li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li><li>代码区，存放程序的二进制代码</li></ul><p id="数据成员和成员函数内存分布情况"></p><h2 id="5、C-中类的数据成员和成员函数内存分布情况"><a href="#5、C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="5、C++中类的数据成员和成员函数内存分布情况"></a>5、C++中类的数据成员和成员函数内存分布情况</h2><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。 类分为成员变量和成员函数，我们先来讨论成员变量。 </p><p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">23</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Person</span>(){}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">"对象地址："</span>&lt;&lt; &amp;p &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"age地址："</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"对象大小："</span>&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"age大小："</span>&lt;&lt; <span class="built_in">sizeof</span>(p.age) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//对象地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//age地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//对象大小：4</span></span><br><span class="line"><span class="comment">//age大小：4</span></span><br></pre></td></tr></tbody></table></figure><p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p><p>要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。 </p><p>我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。</p><p>就像我前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p><p id="关于指针你知道什么全说出来"></p><h2 id="6、关于this指针你知道什么？全说出来"><a href="#6、关于this指针你知道什么？全说出来" class="headerlink" title="6、关于this指针你知道什么？全说出来"></a>6、关于this指针你知道什么？全说出来</h2><ul><li><p>this指针是类的指针，指向对象的首地址。</p></li><li><p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p></li><li><p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p></li></ul><p><strong>this指针的用处</strong></p><p>一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p><p><strong>this指针的使用</strong></p><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p><p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p><p><strong>类的this指针有以下特点</strong></p><p>(1）<strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T * const this</strong></p><p>如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{<span class="keyword">public</span>:<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span>{}};</span><br></pre></td></tr></tbody></table></figure><p>其中，<strong>func</strong>的原型在编译器看来应该是：</p><p>  <strong>int func(A * const this,int p);</strong></p><p>（2）由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a;a.<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//此处，编译器将会编译成：A::func(&amp;a,10);</span></span><br></pre></td></tr></tbody></table></figure><p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p><p id="几个this指针的易混问题"></p><h2 id="7、几个this指针的易混问题"><a href="#7、几个this指针的易混问题" class="headerlink" title="7、几个this指针的易混问题"></a>7、几个this指针的易混问题</h2><h3 id="A-this指针是什么时候创建的？"><a href="#A-this指针是什么时候创建的？" class="headerlink" title="A. this指针是什么时候创建的？"></a>A. this指针是什么时候创建的？</h3><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p><p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p><h3 id="B-this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#B-this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="B. this指针存放在何处？堆、栈、全局变量，还是其他？"></a>B. this指针存放在何处？堆、栈、全局变量，还是其他？</h3><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p><h3 id="C-this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><a href="#C-this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？" class="headerlink" title="C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"></a>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h3><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p><p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p><h3 id="D-this指针是如何访问类中的变量的？"><a href="#D-this指针是如何访问类中的变量的？" class="headerlink" title="D. this指针是如何访问类中的变量的？"></a>D. this指针是如何访问类中的变量的？</h3><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p><p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p><p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p><h3 id="E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h3><p><strong>this指针只有在成员函数中才有定义。</strong>因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p><h3 id="F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h3><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p><blockquote><p id="内存泄漏的后果如何监测解决方法"></p></blockquote><h2 id="8、-内存泄漏的后果？如何监测？解决方法？"><a href="#8、-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="8、 内存泄漏的后果？如何监测？解决方法？"></a>8、 内存泄漏的后果？如何监测？解决方法？</h2><p><strong>1)  内存泄漏</strong></p><p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</p><p><strong>2)  后果</strong></p><p>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；</p><p><strong>3)  如何排除</strong></p><p>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；</p><p>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</p><p><strong>4)  解决方法</strong></p><p>智能指针。</p><p><strong>5)  检查、定位内存泄漏</strong></p><p>检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：</p><p>输出这样的格式{453}normal block at 0x02432CA8,868 bytes long</p><p>被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。</p><p>定位代码位置</p><p>在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include &lt;crtdbg.h&gt;</p><p id="在成员函数中调用deletethis会出现什么问题对象还可以使用吗"></p><h2 id="9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h2><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><p id="为什么是不可预期的问题"></p><h2 id="10、为什么是不可预期的问题？"><a href="#10、为什么是不可预期的问题？" class="headerlink" title="10、为什么是不可预期的问题？"></a>10、为什么是不可预期的问题？</h2><p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p><p id="如果在类的析构函数中调用deletethis会发生什么"></p><h2 id="11、-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#11、-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="11、 如果在类的析构函数中调用delete this，会发生什么？"></a>11、 如果在类的析构函数中调用delete this，会发生什么？</h2><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p><p id="你知道空类的大小是多少吗"></p><h2 id="12、你知道空类的大小是多少吗？"><a href="#12、你知道空类的大小是多少吗？" class="headerlink" title="12、你知道空类的大小是多少吗？"></a>12、你知道空类的大小是多少吗？</h2><ol><li><p>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</p></li><li><p>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</p></li><li><p>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</p></li><li><p>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</p></li></ol><p id="请说一下以下几种情况下下面几个类的大小各是多少"></p><h2 id="13、请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#13、请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="13、请说一下以下几种情况下，下面几个类的大小各是多少？"></a>13、请说一下以下几种情况下，下面几个类的大小各是多少？</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p><p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> { <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>{} };</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> { <span class="type">static</span> <span class="type">int</span> a; };</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> { <span class="type">int</span> a; };</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> { <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; };;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p><p id="this指针调用成员变量时堆栈会发生什么变化"></p><h2 id="14、this指针调用成员变量时，堆栈会发生什么变化？"><a href="#14、this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="14、this指针调用成员变量时，堆栈会发生什么变化？"></a>14、this指针调用成员变量时，堆栈会发生什么变化？</h2><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p><p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p><p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p><p id="大小受哪些因素"></p><h2 id="15、类对象的大小受哪些因素影响？"><a href="#15、类对象的大小受哪些因素影响？" class="headerlink" title="15、类对象的大小受哪些因素影响？"></a>15、类对象的大小受哪些因素影响？</h2><ol><li><p>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p></li><li><p>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p></li><li><p>虚函数的话，会在类对象插入vptr指针，加上指针大小；</p></li><li><p>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法121-140</title>
      <link href="/2023/02/20/c-ji-chu-yu-fa-121-140/"/>
      <url>/2023/02/20/c-ji-chu-yu-fa-121-140/</url>
      
        <content type="html"><![CDATA[<h2 id="121、static-cast比C语言中的转换强在哪里？"><a href="#121、static-cast比C语言中的转换强在哪里？" class="headerlink" title="121、static_cast比C语言中的转换强在哪里？"></a>121、static_cast比C语言中的转换强在哪里？</h2><ol><li><p>更加安全；</p></li><li><p>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</p></li></ol><p id="成员函数里memset"></p><h2 id="122、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#122、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="122、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>122、成员函数里memset(this,0,sizeof(*this))会发生什么</h2><ol><li><p>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</p></li><li><p>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</p></li><li><p>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</p></li></ol><p id="你知道回调函数吗"></p><h2 id="123、你知道回调函数吗？它的作用？"><a href="#123、你知道回调函数吗？它的作用？" class="headerlink" title="123、你知道回调函数吗？它的作用？"></a>123、你知道回调函数吗？它的作用？</h2><ol><li><p>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</p></li><li><p>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</p></li><li><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</p></li><li><p>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p></li></ol><p id="什么是一致性哈希"></p><h2 id="124、什么是一致性哈希？"><a href="#124、什么是一致性哈希？" class="headerlink" title="124、什么是一致性哈希？"></a>124、什么是一致性哈希？</h2><p><strong>一致性哈希</strong></p><p>一致性哈希是一种哈希算法，就是<strong>在移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系</strong></p><p>尽可能少的改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以先想想，真实情况如何处理</p><p>一致性哈希将整个哈希值空间组<strong>织成一个虚拟的圆环</strong>，假设哈希函数的值空间为0~2^32-1，整个哈希空间环如下左图所示</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212342491.png"></p><p>一致性hash的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-object4在环上的分布图</p><p><strong>结点和数据映射</strong></p><p>假如有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-nodeC</p><p>现在有一批的数据object1-object4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，可以沿着顺时针方向寻找，找到一个结点（服务器）则将数据存在这个结点上，这样数据和结点就产生了一对一的关联，如下图所示：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343455.png"></p><p><strong>移除结点</strong></p><p>如果一台服务器出现问题，如上图中的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可，下左图</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343330.png"></p><p><strong>添加结点</strong></p><p>如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，见上右图</p><p><strong>虚拟结点</strong></p><p>假设仅有2台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1和nodeA2，nodeC变成：nodeC1和nodeC2，映射情况变成如下：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343034.png"></p><p>这样数据分布就均衡多了，平衡性有了很大的提高</p><p id="从代码到可执行程序经历了什么"></p><h2 id="125、C-从代码到可执行程序经历了什么？"><a href="#125、C-从代码到可执行程序经历了什么？" class="headerlink" title="125、C++从代码到可执行程序经历了什么？"></a>125、C++从代码到可执行程序经历了什么？</h2><h3 id="（1）预编译"><a href="#（1）预编译" class="headerlink" title="（1）预编译"></a>（1）预编译</h3><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p><ol><li><p>删除所有的#define，展开所有的宏定义。</p></li><li><p>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li><li><p>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他<br>文件。</p></li><li><p>删除所有的注释，“//”和“/**/”。</p></li><li><p>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重<br>复引用。</p></li><li><p>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是<br>能够显示行号。</p></li></ol><h3 id="（2）编译"><a href="#（2）编译" class="headerlink" title="（2）编译"></a>（2）编译</h3><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应<br>的汇编代码文件。</p><ol><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分<br>割成一系列的记号。</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的<br>语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进<br>行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定<br>的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言<br>表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移<br>来替代乘法运算、删除多余的指令等。</li></ol><h3 id="（3）汇编"><a href="#（3）汇编" class="headerlink" title="（3）汇编"></a>（3）汇编</h3><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没<br>有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过<br>来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux<br>下)、xxx.obj(Window下)。</p><h3 id="（4）链接"><a href="#（4）链接" class="headerlink" title="（4）链接"></a>（4）链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链<br>接：</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库<br>中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个<br>目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，<br>在执行的时候运行速度快。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形<br>成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副<br>本，而是这多个程序在执行时共享同一份副本；</p><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运<br>行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损<br>失。</p><p id="什么友元函数必须在类内部声明"></p><h2 id="126、为什么友元函数必须在类内部声明？"><a href="#126、为什么友元函数必须在类内部声明？" class="headerlink" title="126、为什么友元函数必须在类内部声明？"></a>126、为什么友元函数必须在类内部声明？</h2><p>因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。</p><p>有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。</p><p><strong>勘误</strong></p><p>本题问题表达有误，实际上：</p><p>友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。</p><p>只有友元工厂才必须用到类内声明友元函数。</p><blockquote><p>感谢微信好友“江河”提出原则性错误，感谢勘误-2021.06.28</p></blockquote><p id="友元函数和友元类的基本情况"></p><h2 id="127、友元函数和友元类的基本情况"><a href="#127、友元函数和友元类的基本情况" class="headerlink" title="127、友元函数和友元类的基本情况"></a>127、友元函数和友元类的基本情况</h2><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p><p>1）友元函数</p><p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p><p>2）友元类</p><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>{ a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用友元类时注意： </p><p>(1) 友元关系不能被继承。 </p><p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p><p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><p id="用西语言实现西加加的继承"></p><h2 id="128、用C语言实现C-的继承"><a href="#128、用C语言实现C-的继承" class="headerlink" title="128、用C语言实现C++的继承"></a>128、用C语言实现C++的继承</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//C++中的继承与多态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//C++中的多态:通过虚函数实现</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    cout&lt;&lt;<span class="string">"A:fun()"</span>&lt;&lt;endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A     <span class="comment">//C++中的继承:B类公有继承A类</span></span><br><span class="line">{</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">   cout&lt;&lt;<span class="string">"B:fun()"</span>&lt;&lt;endl;</span><br><span class="line">  }</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="comment">//C语言模拟C++的继承与多态</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FUN)</span><span class="params">()</span></span>;   <span class="comment">//定义一个函数指针来实现对成员函数的继承</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_A</span>    <span class="comment">//父类</span></span><br><span class="line">{</span><br><span class="line">  FUN _fun;  <span class="comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span></span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_B</span>     <span class="comment">//子类</span></span><br><span class="line">{</span><br><span class="line">  _A _a_;   <span class="comment">//在子类中定义一个基类的对象即可实现对父类的继承</span></span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line">};</span><br><span class="line"><span class="type">void</span> _fA()    <span class="comment">//父类的同名函数</span></span><br><span class="line">{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"_A:_fun()\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> _fB()    <span class="comment">//子类的同名函数</span></span><br><span class="line">{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"_B:_fun()\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">//测试C++中的继承与多态</span></span><br><span class="line">  A a;  <span class="comment">//定义一个父类对象a</span></span><br><span class="line">  B b;  <span class="comment">//定义一个子类对象b</span></span><br><span class="line"> </span><br><span class="line">  A* p1 = &amp;a;  <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">//调用父类的同名函数</span></span><br><span class="line">  p1 = &amp;b;   <span class="comment">//让父类指针指向子类的对象</span></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">//调用子类的同名函数</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//C语言模拟继承与多态的测试</span></span><br><span class="line">  _A _a;  <span class="comment">//定义一个父类对象_a</span></span><br><span class="line">  _B _b;  <span class="comment">//定义一个子类对象_b</span></span><br><span class="line">  _a._fun = _fA;    <span class="comment">//父类的对象调用父类的同名函数</span></span><br><span class="line">  _b._a_._fun = _fB;  <span class="comment">//子类的对象调用子类的同名函数</span></span><br><span class="line">  _A* p2 = &amp;_a;  <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line">  p2-&gt;_fun();   <span class="comment">//调用父类的同名函数</span></span><br><span class="line">  p2 = (_A*)&amp;_b; <span class="comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span></span><br><span class="line">  p2-&gt;_fun();   <span class="comment">//调用子类的同名函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="动态编译与静态编译"></p><h2 id="129、动态编译与静态编译"><a href="#129、动态编译与静态编译" class="headerlink" title="129、动态编译与静态编译"></a>129、动态编译与静态编译</h2><ol><li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p></li><li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p></li></ol><p id="程序的编译过程"></p><h2 id="130、hello-c-程序的编译过程"><a href="#130、hello-c-程序的编译过程" class="headerlink" title="130、hello.c 程序的编译过程"></a>130、hello.c 程序的编译过程</h2><p>以下是一个 hello.c 程序：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></tbody></table></figure><p>这个过程大致如下：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343505.png"></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h3 id="静态链接-1"><a href="#静态链接-1" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343130.png"></p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h3 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343182.png"></p><p><strong>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</strong></p><ol><li>预处理</li></ol><p>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。</p><ol start="2"><li>编译阶段</li></ol><p>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p><ol start="3"><li>汇编过程</li></ol><p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p><ol start="4"><li>链接阶段</li></ol><p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p><p id="介绍一下几种典型的锁"></p><h2 id="131、介绍一下几种典型的锁"><a href="#131、介绍一下几种典型的锁" class="headerlink" title="131、介绍一下几种典型的锁"></a>131、介绍一下几种典型的锁</h2><p><strong>读写锁</strong></p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><p><strong>互斥锁</strong></p><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><p><strong>条件变量</strong></p><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p><p><strong>自旋锁</strong></p><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><p id="delete和delete区别"></p><h2 id="132、delete和delete-区别？"><a href="#132、delete和delete-区别？" class="headerlink" title="132、delete和delete[]区别？"></a>132、delete和delete[]区别？</h2><ul><li><p>delete只会调用一次析构函数。</p></li><li><p>delete[]会调用数组中每个元素的析构函数。</p></li></ul><p id="为什么不能把所有的函数写成内联函数"></p><h2 id="133、为什么不能把所有的函数写成内联函数"><a href="#133、为什么不能把所有的函数写成内联函数" class="headerlink" title="133、为什么不能把所有的函数写成内联函数?"></a>133、为什么不能把所有的函数写成内联函数?</h2><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p><ul><li><p>函数体内的代码比较长，将导致内存消耗代价</p></li><li><p>函数体内有循环，函数执行时间要比函数调用开销大</p></li></ul><p id="为什么西加加没有垃圾回收机制"></p><h2 id="134、为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#134、为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="134、为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>134、为什么C++没有垃圾回收机制？这点跟Java不太一样。</h2><ul><li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法101-120</title>
      <link href="/2023/02/17/c-ji-chu-yu-fa-101-120/"/>
      <url>/2023/02/17/c-ji-chu-yu-fa-101-120/</url>
      
        <content type="html"><![CDATA[<p id="程序在执行时的内存结构你了解吗"></p><h2 id="101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h2><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p><p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p><p id="volatile关键字的作用"></p><h2 id="102、volatile关键字的作用？"><a href="#102、volatile关键字的作用？" class="headerlink" title="102、volatile关键字的作用？"></a>102、volatile关键字的作用？</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>volatile用在如下的几个地方： </p><ol><li>中断服务程序中修改的供其它程序检测的变量需要加volatile； </li><li>多任务环境下各任务间共享的标志应该加volatile； </li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li></ol><p id="如果有一个空类它会默认添加哪些函数"></p><h2 id="103、如果有一个空类，它会默认添加哪些函数？"><a href="#103、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="103、如果有一个空类，它会默认添加哪些函数？"></a>103、如果有一个空类，它会默认添加哪些函数？</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)  <span class="built_in">Empty</span>(); <span class="comment">// 缺省构造函数//</span></span><br><span class="line"><span class="number">2</span>)  <span class="built_in">Empty</span>( <span class="type">const</span> Empty&amp; ); <span class="comment">// 拷贝构造函数//</span></span><br><span class="line"><span class="number">3</span>)  ~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数//</span></span><br><span class="line"><span class="number">4</span>)  Empty&amp; <span class="keyword">operator</span>=( <span class="type">const</span> Empty&amp; ); <span class="comment">// 赋值运算符//</span></span><br></pre></td></tr></tbody></table></figure><p id="西加加中标准库是什么"></p><h2 id="104、C-中标准库是什么？"><a href="#104、C-中标准库是什么？" class="headerlink" title="104、C++中标准库是什么？"></a>104、C++中标准库是什么？</h2><ol><li>C++ 标准库可以分为两部分：</li></ol><p>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p><p>面向对象类库： 这个库是类及其相关函数的集合。</p><ol start="2"><li><p>输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p></li><li><p>标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p></li></ol><p id="你知道之间的关系是什么吗"></p><h2 id="105、你知道const-char-与string之间的关系是什么吗？"><a href="#105、你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="105、你知道const char* 与string之间的关系是什么吗？"></a>105、你知道const char* 与string之间的关系是什么吗？</h2><ol><li><p>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p></li><li><p>三者的转化关系如下所示：</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a)  string转<span class="type">const</span> <span class="type">char</span>* </span><br><span class="line">string s = “abc”; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>(); </span><br><span class="line">b)  <span class="type">const</span> <span class="type">char</span>* 转string，直接赋值即可 </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>; </span><br><span class="line">c)  string 转<span class="type">char</span>* </span><br><span class="line"> string s = “abc”; </span><br><span class="line"> <span class="type">char</span>* c; </span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>(); </span><br><span class="line"> c = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>]; </span><br><span class="line"> <span class="built_in">strcpy</span>(c,s.<span class="built_in">c_str</span>()); </span><br><span class="line">d)  <span class="type">char</span>* 转string </span><br><span class="line"> <span class="type">char</span>* c = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c)</span></span>; </span><br><span class="line">e)  <span class="type">const</span> <span class="type">char</span>* 转<span class="type">char</span>* </span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* cpc = “abc”; </span><br><span class="line"> <span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line"> <span class="built_in">strcpy</span>(pc,cpc);</span><br><span class="line">f)  <span class="type">char</span>* 转<span class="type">const</span> <span class="type">char</span>*，直接赋值即可 </span><br><span class="line"> <span class="type">char</span>* pc = “abc”; </span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></tbody></table></figure><p id="你什么情况用指针当参数，什么时候用引用，为什么"></p><h2 id="106、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#106、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="106、你什么情况用指针当参数，什么时候用引用，为什么？"></a>106、你什么情况用指针当参数，什么时候用引用，为什么？</h2><ol><li>使用引用参数的主要原因有两个：</li></ol><p>程序员能修改调用函数中的数据对象</p><p>通过传递引用而不是整个数据–对象，可以提高程序的运行速度 </p><ol start="2"><li>一般的原则：<br> 对于使用引用的值而不做修改的函数：</li></ol><p>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</p><p>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</p><p>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</p><p>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</p><ol start="3"><li>对于修改函数中数据的函数：</li></ol><p>如果数据是内置数据类型，则使用指针</p><p>如果数据对象是结构，则使用引用或者指针</p><p>如果数据是类对象，则使用引用</p><p>也有一种说法认为：“如果数据对象是数组，则只能使用指针”，这是不对的，比如</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T (&amp;a)[N])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a[] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p id="你知道静态绑定和动态绑定吗"></p><h2 id="107、你知道静态绑定和动态绑定吗？讲讲？"><a href="#107、你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="107、你知道静态绑定和动态绑定吗？讲讲？"></a>107、你知道静态绑定和动态绑定吗？讲讲？</h2><ol><li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p></li><li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p></li><li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)</p></li><li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)</p></li></ol><p id="如何设计一个类计算子类的个数"></p><h2 id="108、如何设计一个计算仅单个子类的对象个数？"><a href="#108、如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="108、如何设计一个计算仅单个子类的对象个数？"></a>108、如何设计一个计算仅单个子类的对象个数？</h2><p>1、为类设计一个static静态变量count作为计数器；</p><p>2、类定义结束后初始化count;</p><p>3、在构造函数中对count进行+1;</p><p>4、 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p><p>5、设计赋值构造函数，在进行赋值函数中对count+1操作；</p><p>6、在析构函数中对count进行-1；</p><p id="怎么快速定位错误出现的地方"></p><h2 id="109、怎么快速定位错误出现的地方"><a href="#109、怎么快速定位错误出现的地方" class="headerlink" title="109、怎么快速定位错误出现的地方?"></a>109、怎么快速定位错误出现的地方?</h2><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p><p>2、对于复杂的模板错误，最好使用生成输出窗口。</p><p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p><p id="成员初始化列表会在什么时候用到"></p><h2 id="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#110、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>110、成员初始化列表会在什么时候用到？它的调用过程是什么？</h2><ol><li><p>当初始化一个引用成员变量时；</p></li><li><p>初始化一个const成员变量时；</p></li><li><p>当调用一个基类的构造函数，而构造函数拥有一组参数时；</p></li><li><p>当调用一个成员类的构造函数，而他拥有一组参数；</p></li><li><p>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</p></li></ol><p id="在进行函数参数以及返回值传递时，可以使用引用或者值传递"></p><h2 id="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</h2><p>对比值传递，引用传参的好处：</p><p>1）在函数内部可以对此参数进行修改</p><p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p><p>但是有以下的限制：</p><p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p><p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p><p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p><p id="sprintf与memcpy这三个函数的不同之处"></p><h2 id="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#112、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</h2><ol><li>操作对象不同</li></ol><p>①   strcpy的两个操作对象均为字符串 </p><p>②   sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 </p><p>③   memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p><ol start="2"><li>执行效率不同</li></ol><p>memcpy最高，strcpy次之，sprintf的效率最低。</p><ol start="3"><li>实现功能不同</li></ol><p>①   strcpy主要实现字符串变量间的拷贝 </p><p>②   sprintf主要实现其他数据类型格式到字符串的转化 </p><p>③   memcpy主要是内存块间的拷贝。</p><p id="将引用作为函数参数有哪些好处"></p><h2 id="113、将引用作为函数参数有哪些好处？"><a href="#113、将引用作为函数参数有哪些好处？" class="headerlink" title="113、将引用作为函数参数有哪些好处？"></a>113、将引用作为函数参数有哪些好处？</h2><ol><li>传递引用给函数与传递指针的效果是一样的。</li></ol><p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p><ol start="2"><li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li></ol><p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p><p>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><ol start="3"><li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</li></ol><p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p><p id="你知道数组和指针的区别吗"></p><h2 id="114、你知道数组和指针的区别吗？"><a href="#114、你知道数组和指针的区别吗？" class="headerlink" title="114、你知道数组和指针的区别吗？"></a>114、你知道数组和指针的区别吗？</h2><ol><li><p>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；</p></li><li><p>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</p></li><li><p>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p></li><li><p>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</p></li><li><p>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</p></li></ol><p id="如何阻止一个类被实例化"></p><h2 id="115、如何阻止一个类被实例化？有哪些方法？"><a href="#115、如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="115、如何阻止一个类被实例化？有哪些方法？"></a>115、如何阻止一个类被实例化？有哪些方法？</h2><ol><li><p>将类定义为抽象基类或者将构造函数声明为private；</p></li><li><p>不允许类外部创建类对象，只能在类内部创建对象</p></li></ol><p id="如何禁止程序自动生成拷贝构造函数"></p><h2 id="116、-如何禁止程序自动生成拷贝构造函数？"><a href="#116、-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="116、 如何禁止程序自动生成拷贝构造函数？"></a>116、 如何禁止程序自动生成拷贝构造函数？</h2><ol><li><p>为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。</p></li><li><p>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；</p></li><li><p>针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。</p></li></ol><p id="你知道的八个和瑞丽丝的区别是什么吗"></p><h2 id="117、你知道Debug和Release的区别是什么吗？"><a href="#117、你知道Debug和Release的区别是什么吗？" class="headerlink" title="117、你知道Debug和Release的区别是什么吗？"></a>117、你知道Debug和Release的区别是什么吗？</h2><ol><li><p>调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息； </p></li><li><p>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</p></li><li><p>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p></li></ol><p id="main函数的返回值有什么值得考究之处吗"></p><h2 id="118、main函数的返回值有什么值得考究之处吗？"><a href="#118、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="118、main函数的返回值有什么值得考究之处吗？"></a>118、main函数的返回值有什么值得考究之处吗？</h2><p>程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p><p>main（int args, char **argv） 参数的传递。参数的处理，一般会调用getopt（）函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</p><p id="写一个比较大小的模板函数"></p><h2 id="119、模板会写吗？写一个比较大小的模板函数"><a href="#119、模板会写吗？写一个比较大小的模板函数" class="headerlink" title="119、模板会写吗？写一个比较大小的模板函数"></a>119、模板会写吗？写一个比较大小的模板函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="comment">//函数模板 </span></span><br><span class="line"><span class="function">type1 <span class="title">Max</span><span class="params">(type1 a,type2 b)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">   <span class="keyword">return</span> a &gt; b ? a : b; </span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>{ </span><br><span class="line">  cout&lt;&lt;<span class="string">"Max = "</span>&lt;&lt;<span class="built_in">Max</span>(<span class="number">5.5</span>,<span class="string">'a'</span>)&lt;&lt;endl; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a &gt; b 这一步是会报错的。</p><p>这个时候往往需要对于 &gt; 号进行重载，这代码量瞬间上来了。</p><p id="strcpy函数和strncpy函数的区别"></p><h2 id="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>120、strcpy函数和strncpy函数的区别？哪个函数更安全？</h2><ol><li>函数原型</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><ul><li>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。 </li><li>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</li></ul></li><li><ul><li>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’ </li><li>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’ </li><li>如果指定长&gt;目标长，运行时错误 ；</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之基础语法81-100</title>
      <link href="/2023/02/14/c-ji-chu-yu-fa-81-100/"/>
      <url>/2023/02/14/c-ji-chu-yu-fa-81-100/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之基础语法</h1><h2 id="81、知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#81、知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="81、知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</h2><p><strong>一：继承</strong></p><p>继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p><p>继承的缺点有以下几点：</p><p>①：父类的内部细节对子类是可见的。</p><p>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p><p><strong>二：组合</strong></p><p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p><p>组合的优点：</p><p>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</p><p>②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</p><p>③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p><p>组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。</p><p id="函数指针函数指针"></p><h2 id="82、函数指针？"><a href="#82、函数指针？" class="headerlink" title="82、函数指针？"></a>82、函数指针？</h2><p><strong>1)  什么是函数指针?</strong></p><p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p><p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p><p><strong>2)  函数指针的声明方法</strong></p><p>int (*pf)(const int&amp;, const int&amp;); (1)</p><p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p><p>int *pf(const int&amp;, const int&amp;); (2)</p><p>而这声明了一个函数pf，其返回类型为int *， 带有两个const int&amp;参数。</p><p><strong>3)  为什么有函数指针</strong></p><p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p><p><strong>4)  一个函数名就是一个指针，它指向函数的代码。</strong></p><p>一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p><p><strong>5)  两种方法赋值：</strong></p><p>指针名 = 函数名；  指针名 = &amp;函数名</p><p id="说一说你理解的内存对齐以及原因"></p><h2 id="83、说一说你理解的内存对齐以及原因"><a href="#83、说一说你理解的内存对齐以及原因" class="headerlink" title="83、说一说你理解的内存对齐以及原因"></a>83、说一说你理解的内存对齐以及原因</h2><p>1、 分配内存的顺序是按照声明的顺序。</p><p>2、 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</p><p>3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍。</p><p>添加了#pragma pack(n)后规则就变成了下面这样：</p><p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p><p>2、 整体大小要是n和最大变量大小中较小值的整数倍</p><p>3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p><p id="结构体变量比较是否相等"></p><h2 id="84、-结构体变量比较是否相等"><a href="#84、-结构体变量比较是否相等" class="headerlink" title="84、 结构体变量比较是否相等"></a>84、 结构体变量比较是否相等</h2><ol><li>重载了 “==” 操作符</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> {</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> foo&amp; rhs) *<span class="comment">//* *操作运算符重载*</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">return</span>( a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>元素的话，一个个比；</p></li><li><p>指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；</p></li></ol><p id="函数调用过程栈的变化返回值和参数变量哪个先入栈"></p><h2 id="85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h2><p> 1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调    </p><pre><code>   函数所需要的参数压入栈;</code></pre><p> 2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作</p><pre><code>   隐含在call指令中);</code></pre><p> 3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前</p><pre><code>  被调函数的栈底地址(mov ebp,esp);</code></pre><p> 4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的</p><pre><code>  顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</code></pre><p id="defineconsttypedefinline的使用方法"></p><h2 id="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#86、define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>86、define、const、typedef、inline的使用方法？他们之间有什么区别？</h2><p>一、const与#define的区别：</p><ol><li><p>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</p></li><li><p>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</p></li><li><p>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</p></li><li><p>define预处理后，占用代码段空间，const占用数据段空间；</p></li><li><p>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p></li><li><p>define独特功能，比如可以用来防止文件重复引用。</p></li></ol><p>二、#define和别名typedef的区别</p><ol><li><p>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p></li><li><p>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p></li><li><p>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</p></li></ol><p>三、  define与inline的区别</p><ol><li><p>#define是关键字，inline是函数；</p></li><li><p>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p></li><li><p>inline函数有类型检查，相比宏定义比较安全；</p></li></ol><p id="你知道printf函数的实现原理是什么吗"></p><h2 id="87、你知道printf函数的实现原理是什么吗？"><a href="#87、你知道printf函数的实现原理是什么吗？" class="headerlink" title="87、你知道printf函数的实现原理是什么吗？"></a>87、你知道printf函数的实现原理是什么吗？</h2><p>在C/C++中，对函数参数的扫描是从后向前的。</p><p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p><p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p><p id="为什么模板类一般都是放在一个h文件中"></p><h2 id="88、为什么模板类一般都是放在一个h文件中"><a href="#88、为什么模板类一般都是放在一个h文件中" class="headerlink" title="88、为什么模板类一般都是放在一个h文件中"></a>88、为什么模板类一般都是放在一个h文件中</h2><ol><li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li></ol><p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><ol start="2"><li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li></ol><p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p><p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p><p id="类成员的访问权限和继承权限问题"></p><h2 id="89、C-中类成员的访问权限和继承权限问题"><a href="#89、C-中类成员的访问权限和继承权限问题" class="headerlink" title="89、C++中类成员的访问权限和继承权限问题"></a>89、C++中类成员的访问权限和继承权限问题</h2><ol><li>三种访问权限</li></ol><p>①   public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被  访问，在类外也是可以被访问的，是类对外提供的可访问接口；</p><p>②   private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p><p>③   protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p><ol start="2"><li>三种继承方式</li></ol><p>①   若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</p><p>②  若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</p><p>③  若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p><p id="cout和printf有什么区别"></p><h2 id="90、cout和printf有什么区别？"><a href="#90、cout和printf有什么区别？" class="headerlink" title="90、cout和printf有什么区别？"></a>90、cout和printf有什么区别？</h2><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p><p>输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p><p>cout是有缓冲输出:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">"abc "</span> &lt; &lt;endl; </span><br><span class="line">或cout &lt; &lt; <span class="string">"abc\n "</span>; cout &lt; &lt;flush; 这两个才是一样的.</span><br></pre></td></tr></tbody></table></figure><p> flush立即强迫缓冲输出。</p><p>printf是行缓冲输出，不是无缓冲输出。</p><p id="你知道重载运算符吗"></p><h2 id="91、你知道重载运算符吗？"><a href="#91、你知道重载运算符吗？" class="headerlink" title="91、你知道重载运算符吗？"></a>91、你知道重载运算符吗？</h2><p>1、 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</p><p>2、  两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</p><p>3、 引入运算符重载，是为了实现类的多态性；</p><p>4、 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</p><p>5、 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</p><p>6、 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</p><p>7、 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</p><p id="当程序中有函数重载时，函数的匹配原则和顺序是什么"></p><h2 id="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#92、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</h2><ol><li><p>名字查找</p></li><li><p>确定候选函数</p></li><li><p>寻找最佳匹配</p></li></ol><p id="定义和声明的区别"></p><h2 id="93、定义和声明的区别"><a href="#93、定义和声明的区别" class="headerlink" title="93、定义和声明的区别"></a>93、定义和声明的区别</h2><p> <strong>如果是指变量的声明和定义：</strong><br> 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p><p><strong>如果是指函数的声明和定义：</strong><br> 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br> 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p><p id="全局变量和static变量的区别"></p><h2 id="94、全局变量和static变量的区别"><a href="#94、全局变量和static变量的区别" class="headerlink" title="94、全局变量和static变量的区别"></a>94、全局变量和static变量的区别</h2><p>1、全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。</p><p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</p><p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</p><p>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p><p>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p><p>2.static函数与普通函数有什么区别？<br> static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p><p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。<br> static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p><p id="静态成员与普通成员的区别是什么"></p><h2 id="95、-静态成员与普通成员的区别是什么？"><a href="#95、-静态成员与普通成员的区别是什么？" class="headerlink" title="95、 静态成员与普通成员的区别是什么？"></a>95、 静态成员与普通成员的区别是什么？</h2><ol><li>生命周期</li></ol><p>静态成员变量从类被加载开始到类被卸载，一直存在；</p><p>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p><ol start="2"><li>共享方式</li></ol><p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p><ol start="3"><li>定义位置</li></ol><p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p><ol start="4"><li>初始化位置</li></ol><p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p><ol start="5"><li>默认实参</li></ol><p>可以使用静态成员变量作为默认实参，</p><p id="说一下你理解的ifdefendif代表着什么"></p><h2 id="96、说一下你理解的-ifdef-endif代表着什么？"><a href="#96、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="96、说一下你理解的 ifdef   endif代表着什么？"></a>96、说一下你理解的 ifdef   endif代表着什么？</h2><ol><li><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。 </p></li><li><p>条件编译命令最常见的形式为：</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line">程序段<span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br> 其中#else部分也可以没有，即： </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</li></ol><p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p><p id="隐式转换，如何消除隐式转换"></p><h2 id="97、隐式转换，如何消除隐式转换？"><a href="#97、隐式转换，如何消除隐式转换？" class="headerlink" title="97、隐式转换，如何消除隐式转换？"></a>97、隐式转换，如何消除隐式转换？</h2><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p><p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p><p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p><p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p><p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p><p id="如何处理多个异常的"></p><h2 id="98、C-如何处理多个异常的？"><a href="#98、C-如何处理多个异常的？" class="headerlink" title="98、C++如何处理多个异常的？"></a>98、C++如何处理多个异常的？</h2><ol><li><p>C++中的异常情况：<br> 语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br> 运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</p></li><li><p>C++异常处理机制：<br> 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br> C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br> 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p></li></ol> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>  {  可能抛出异常的语句；（检查） <span class="keyword">try</span> </span><br><span class="line"> { </span><br><span class="line"> 可能抛出异常的语句；（检查） </span><br><span class="line"> } </span><br><span class="line"> <span class="keyword">catch</span>（类型名[形参名]）<span class="comment">//捕获特定类型的异常 </span></span><br><span class="line"> { </span><br><span class="line"> <span class="comment">//处理1； </span></span><br><span class="line"> } </span><br><span class="line"> <span class="keyword">catch</span>（类型名[形参名]）<span class="comment">//捕获特定类型的异常 </span></span><br><span class="line"> { </span><br><span class="line"> <span class="comment">//处理2； </span></span><br><span class="line"> } </span><br><span class="line"> <span class="keyword">catch</span>（…）<span class="comment">//捕获所有类型的异常 </span></span><br><span class="line"> { </span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p id="如何在不使用额外空间的情况下，交换两个数"></p>## 99、如何在不使用额外空间的情况下，交换两个数？你有几种方法<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)  算术</span><br><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line">x = x - y; </span><br><span class="line"><span class="number">2</span>)  异或</span><br><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br></pre></td></tr></tbody></table></figure><p id="你知道strcpy和memcpy的区别是什么吗"></p>## 100、你知道strcpy和memcpy的区别是什么吗？1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之基础语法61-80</title>
      <link href="/2023/02/11/c-ji-chu-yu-fa-61-80/"/>
      <url>/2023/02/11/c-ji-chu-yu-fa-61-80/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之基础语法</h1><p id="什么是内存泄露，如何检测与避免"></p><h2 id="61、什么是内存泄露，如何检测与避免"><a href="#61、什么是内存泄露，如何检测与避免" class="headerlink" title="61、什么是内存泄露，如何检测与避免"></a>61、什么是内存泄露，如何检测与避免</h2><p><strong>内存泄露</strong></p><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p><p><strong>避免内存泄露的几种方式</strong></p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为<strong>虚函数</strong></li><li>对象数组的释放一定要用<strong>delete []</strong></li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><p id="对象复用的了解，零拷贝的了解"></p><h2 id="62、对象复用的了解，零拷贝的了解"><a href="#62、对象复用的了解，零拷贝的了解" class="headerlink" title="62、对象复用的了解，零拷贝的了解"></a>62、对象复用的了解，零拷贝的了解</h2><p><strong>对象复用</strong></p><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p><p><strong>零拷贝</strong></p><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p><p>在C++中，vector的一个成员函数<strong>emplace_back()<strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：</strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string p_name, <span class="type">int</span> p_age): <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">age</span>(p_age)</span><br><span class="line">    {</span><br><span class="line">         cout &lt;&lt; <span class="string">"I have been constructed"</span> &lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    {</span><br><span class="line">         cout &lt;&lt; <span class="string">"I have been copy constructed"</span> &lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(Person&amp;&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    {</span><br><span class="line">         cout &lt;&lt; <span class="string">"I have been moved"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; <span class="string">"emplace_back:"</span> &lt;&lt;endl;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(<span class="string">"Jane"</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="string">"push_back:"</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">"Mike"</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br></pre></td></tr></tbody></table></figure><p id="介绍面向对象的三大特性，并且举例说明"></p><h2 id="63、介绍面向对象的三大特性，并且举例说明"><a href="#63、介绍面向对象的三大特性，并且举例说明" class="headerlink" title="63、介绍面向对象的三大特性，并且举例说明"></a>63、介绍面向对象的三大特性，并且举例说明</h2><p>三大特性：继承、封装和多态</p><p><strong>（1）继承</strong></p><p><strong>让某种类型对象获得另一个类型对象的属性和方法。</strong></p><p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</p><p>常见的继承有三种方式：</p><ol><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li><li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）</li></ol><p>例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法</p><p><strong>（2）封装</strong></p><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p><p>封装，也就是<strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><p><strong>（3）多态</strong>  </p><p>同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为<strong>（重载实现编译时多态，虚函数实现运行时多态）</strong>。</p><p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p><p>实现多态有二种方式：覆盖（override），重载（overload）。</p><p>覆盖：是指子类重新定义父类的虚函数的做法。</p><p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。</p><p id="成员初始化列表的概念，为什么用它会快一些"></p><h2 id="64、成员初始化列表的概念，为什么用它会快一些？"><a href="#64、成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="64、成员初始化列表的概念，为什么用它会快一些？"></a>64、成员初始化列表的概念，为什么用它会快一些？</h2><p><strong>成员初始化列表的概念</strong></p><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</p><p><strong>效率</strong></p><p>用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"默认构造函数A()"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">    {</span><br><span class="line">        value = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">"A(int "</span>&lt;&lt;value&lt;&lt;<span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">    {</span><br><span class="line">        value = a.value;</span><br><span class="line">        cout &lt;&lt; <span class="string">"拷贝构造函数A(A&amp; a):  "</span>&lt;&lt;value &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">a</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        b = <span class="built_in">A</span>(<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//A(int 1)</span></span><br><span class="line"><span class="comment">//默认构造函数A()</span></span><br><span class="line"><span class="comment">//A(int 2)</span></span><br></pre></td></tr></tbody></table></figure><p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p><p id="西加加的四种强制转换人特普瑞特"></p><h2 id="65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="65、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast"></a>65、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast</h2><p><strong>reinterpret_cast</strong></p><p>reinterpret_cast&lt;type-id&gt; (expression)</p><p>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</p><p><strong>const_cast</strong></p><p>const_cast<type_id> (expression)</type_id></p><p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p><ul><li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针。如const char *p形式</li></ul><p><strong>static_cast</strong></p><p>static_cast &lt; type-id &gt; (expression)</p><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把空指针转换成目标类型的空指针</li><li>把任何类型的表达式转换成void类型</li></ul><p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p><p><strong>dynamic_cast</strong></p><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p><p>dynamic_cast &lt;type-id&gt; (expression)</p><p>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p><p>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p><p>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() :<span class="built_in">b</span>(<span class="number">1</span>) {}</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{};</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>() :<span class="built_in">d</span>(<span class="number">2</span>) {}</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> n = <span class="number">97</span>;</span><br><span class="line"><span class="comment">//reinterpret_cast</span></span><br><span class="line"><span class="type">int</span> *p = &amp;n;</span><br><span class="line"><span class="comment">//以下两者效果相同</span></span><br><span class="line"><span class="type">char</span> *c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt; (p); </span><br><span class="line"><span class="type">char</span> *c2 =  (<span class="type">char</span>*)(p);</span><br><span class="line">cout &lt;&lt; <span class="string">"reinterpret_cast输出："</span>&lt;&lt; *c2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//const_cast</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;n;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p2);</span><br><span class="line">*p3 = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"const_cast输出："</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Base* b1 = <span class="keyword">new</span> Son;</span><br><span class="line">Base* b2 = <span class="keyword">new</span> Base;</span><br><span class="line"><span class="comment">//static_cast</span></span><br><span class="line">Son* s1 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b1); <span class="comment">//同类型转换</span></span><br><span class="line">Son* s2 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b2); <span class="comment">//下行转换，不安全</span></span><br><span class="line">cout &lt;&lt; <span class="string">"static_cast输出："</span>&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1-&gt;d &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s2-&gt;d &lt;&lt; endl; <span class="comment">//下行转换，原先父对象没有d成员，输出垃圾值</span></span><br><span class="line"><span class="comment">//dynamic_cast</span></span><br><span class="line">Son* s3 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b1); <span class="comment">//同类型转换</span></span><br><span class="line">Son* s4 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b2); <span class="comment">//下行转换，安全</span></span><br><span class="line">cout &lt;&lt; <span class="string">"dynamic_cast输出："</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s3-&gt;d &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(s4 == <span class="literal">nullptr</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">"s4指针为nullptr"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; s4-&gt;d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//reinterpret_cast输出：a</span></span><br><span class="line"><span class="comment">//const_cast输出：100</span></span><br><span class="line"><span class="comment">//static_cast输出：</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//-33686019</span></span><br><span class="line"><span class="comment">//dynamic_cast输出：</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//s4指针为nullptr</span></span><br></pre></td></tr></tbody></table></figure><p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p><p id="函数调用的压栈过程"></p><h2 id="66、C-函数调用的压栈过程"><a href="#66、C-函数调用的压栈过程" class="headerlink" title="66、C++函数调用的压栈过程"></a>66、C++函数调用的压栈过程</h2><h2 id="66-1、以例子进行讲解"><a href="#66-1、以例子进行讲解" class="headerlink" title="66.1、以例子进行讲解"></a>66.1、以例子进行讲解</h2><p>从代码入手，解释这个过程：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> var1 = param1;</span><br><span class="line"><span class="type">int</span> var2 = param2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"var1=%d,var2=%d"</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));<span class="comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br></pre></td></tr></tbody></table></figure><p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p><p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p><p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p><p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p><h2 id="66-2、文字化表述"><a href="#66-2、文字化表述" class="headerlink" title="66.2、文字化表述"></a>66.2、文字化表述</h2><p>函数的调用过程：</p><p>1）从栈空间分配存储空间</p><p>2）从实参的存储空间复制值到形参栈空间</p><p>3）进行运算</p><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p><p id="很常见你遇到过吗怎么调试这个错误"></p><h2 id="67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h2><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><ul><li>使用gdb命令对core文件进行调试</li></ul><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></tbody></table></figure><p>在编辑器内键入</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,i);<span class="comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></tbody></table></figure><p>运行</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></tbody></table></figure><p>使用gdb调试coredump</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p id="说说移动构造函数"></p><h2 id="68、说说移动构造函数"><a href="#68、说说移动构造函数" class="headerlink" title="68、说说移动构造函数"></a>68、说说移动构造函数</h2><ol><li><p>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li><li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p></li></ol><p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p><ol start="3"><li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</li></ol><p id="将临时变量作为返回值时的处理过程"></p><h2 id="69、C-中将临时变量作为返回值时的处理过程"><a href="#69、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="69、C++中将临时变量作为返回值时的处理过程"></a>69、C++中将临时变量作为返回值时的处理过程</h2><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><p id="如何获得结构成员相对于结构开头的字节偏移量"></p><h2 id="70、如何获得结构成员相对于结构开头的字节偏移量"><a href="#70、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="70、如何获得结构成员相对于结构开头的字节偏移量"></a>70、如何获得结构成员相对于结构开头的字节偏移量</h2><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">S</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">char</span> y;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在Visual Studio 2019 + Win10 下的输出情况如下</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当然了，如果加上  #pragma pack(4) 指定4字节对齐方式就可以了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">S</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">char</span> y;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">｝</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐<br><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035079.png"></p><p id="静态类型和动态类型，静态绑定和动态绑定的介绍"></p><h2 id="71、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#71、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="71、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>71、静态类型和动态类型，静态绑定和动态绑定的介绍</h2><ul><li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；<br>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。<br>举个例子：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"A::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"B::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{ std::cout &lt;&lt; <span class="string">"C::func()\n"</span>; }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    </span><br><span class="line">    pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果将A类中的virtual注释去掉，则运行结果是：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，</p><ul><li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li><li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li><li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；<br><strong>本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。</strong><br>至此总结一下静态绑定和动态绑定的区别：</li><li>静态绑定发生在编译期，动态绑定发生在运行期；</li><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>要想实现动态，必须使用动态绑定；</li><li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；<br><strong>建议：</strong><br>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。<br>看下面的代码：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"E::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"F::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">E* pe = pf;</span><br><span class="line">pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">test2</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p id="引用是否能实现动态绑定，为什么可以实现"></p><h2 id="72、引用是否能实现动态绑定，为什么可以实现？"><a href="#72、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="72、引用是否能实现动态绑定，为什么可以实现？"></a>72、引用是否能实现动态绑定，为什么可以实现？</h2><p>可以。<br>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。<br>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"base :: fun()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"son :: fun()"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"son :: not virtual function"</span> &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Son s;</span><br><span class="line">Base&amp; b = s; <span class="comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span></span><br><span class="line">s.<span class="built_in">fun</span>(); <span class="comment">//son::fun()</span></span><br><span class="line">b.<span class="built_in">fun</span>(); <span class="comment">//son :: fun()</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p><p id="全局变量和局部变量有什么区别"></p><h2 id="73、全局变量和局部变量有什么区别？"><a href="#73、全局变量和局部变量有什么区别？" class="headerlink" title="73、全局变量和局部变量有什么区别？"></a>73、全局变量和局部变量有什么区别？</h2><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；<br>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。<br>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p><p id="指针加减计算要注意什么"></p><h2 id="74、指针加减计算要注意什么？"><a href="#74、指针加减计算要注意什么？" class="headerlink" title="74、指针加减计算要注意什么？"></a>74、指针加减计算要注意什么？</h2><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。<br>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> *a, *b, c;</span><br><span class="line">a = (<span class="type">int</span>*)<span class="number">0x500</span>;</span><br><span class="line">b = (<span class="type">int</span>*)<span class="number">0x520</span>;</span><br><span class="line">c = b - a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 8</span></span><br><span class="line">a += <span class="number">0x020</span>;</span><br><span class="line">c = b - a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// -24</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5*16^2=1280）和1312（5*16^2+2<em>16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8<br>a自增16进制0x20之后，其实际地址变为1280 + 2*16*4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24<br>遇到指针的计算，*<em>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</em></em></p><p id="怎样判断两个浮点数是否相等"></p><h2 id="75、-怎样判断两个浮点数是否相等？"><a href="#75、-怎样判断两个浮点数是否相等？" class="headerlink" title="75、 怎样判断两个浮点数是否相等？"></a>75、 怎样判断两个浮点数是否相等？</h2><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><p id="方法调用的原理"></p><h2 id="76、方法调用的原理（栈，汇编）"><a href="#76、方法调用的原理（栈，汇编）" class="headerlink" title="76、方法调用的原理（栈，汇编）"></a>76、方法调用的原理（栈，汇编）</h2><ol><li>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</li><li>由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li><li>过程实现<br>①   备份原来的帧指针，调整当前的栈帧指针到栈指针位置；<br>②   建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；<br>③   使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。<br>④   恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了<br>⑤   恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。<br>⑥   释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。<br>⑦   恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。<br>⑧   弹出返回地址，跳出当前过程，继续执行调用者的代码。</li><li>过程调用和返回指令<br>①   call指令<br>②   leave指令<br>③   ret指令</li></ol><p id="指针参数传递和引用参数传递有什么区别"></p>                       <h2 id="77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h2><p><strong>1)</strong> 指针参数传递本质上是值传递，它所传递的是一个地址值。<br>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。<br>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。<br><strong>2)</strong> 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<br>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。<br>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。<br><strong>3)</strong> 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。<br>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。<br><strong>4)</strong> 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。<br>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。<br>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><p id="类如何实现只能静态分配和只能动态分配"></p><h2 id="78、类如何实现只能静态分配和只能动态分配"><a href="#78、类如何实现只能静态分配和只能动态分配" class="headerlink" title="78、类如何实现只能静态分配和只能动态分配"></a>78、类如何实现只能静态分配和只能动态分配</h2><ol><li>前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</li><li>建立类的对象有两种方式：<br>①   静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；<br>②   动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</li><li>只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li></ol><p id="如果想将某个类用作基类，为什么该类必须定义而非声明"></p><h2 id="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>79、如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。<br>所以必须定义而非声明。</p><p id="继承机制中对象之间如何转换"></p><h2 id="80、-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#80、-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="80、 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>80、 继承机制中对象之间如何转换？指针和引用之间如何转换？</h2><ol><li><pre><code>向上类型转换</code></pre></li></ol><p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。<br>2)     向下类型转换<br>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p><p id="它与继承相比有什么优缺点吗"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之基础语法41-60</title>
      <link href="/2023/02/07/c-ji-chu-yu-fa-41-60/"/>
      <url>/2023/02/07/c-ji-chu-yu-fa-41-60/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之基础语法</h1><p id="中有几种类型的new"></p><h2 id="41、C-中有几种类型的new"><a href="#41、C-中有几种类型的new" class="headerlink" title="41、C++中有几种类型的new"></a>41、C++中有几种类型的new</h2><p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new</p><p>（1）<strong>plain new</strong></p><p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>因此<strong>plain new</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//执行结果：bad allocation</span></span><br></pre></td></tr></tbody></table></figure><p>（2）<strong>nothrow new</strong></p><p>nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果：alloc failed</span></span><br></pre></td></tr></tbody></table></figure><p>（3）<strong>placement new</strong></p><p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>,<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*,<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>使用placement new需要注意两点：</p><ul><li>palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</li><li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li></ul><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span>{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ADT</span>(){</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">j = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"ADT construct i="</span> &lt;&lt; i &lt;&lt; <span class="string">"j="</span>&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">~<span class="built_in">ADT</span>(){</span><br><span class="line">cout &lt;&lt; <span class="string">"ADT destruct"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">cout &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">ADT *q = <span class="built_in">new</span>(p) ADT;  <span class="comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line"><span class="comment">//delete q;//错误!不能在此处调用delete q;</span></span><br><span class="line">q-&gt;ADT::~<span class="built_in">ADT</span>();<span class="comment">//显示调用析构函数</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//ADT construct i=10j=100</span></span><br><span class="line"><span class="comment">//ADT destruct</span></span><br></pre></td></tr></tbody></table></figure><p id="异常处理的方法"></p><h2 id="42、C-的异常处理的方法"><a href="#42、C-的异常处理的方法" class="headerlink" title="42、C++的异常处理的方法"></a>42、C++的异常处理的方法</h2><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li><li>…</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><p><strong>（1）try、throw和catch关键字</strong></p><p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，其在程序中的用法如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"before dividing."</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">"after dividing."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> d) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"catch (double)"</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"catch (...)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"finished"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br></pre></td></tr></tbody></table></figure><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p><p><strong>（2）函数的异常声明列表</strong></p><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,A,B,C)</span></span>{...};</span><br></pre></td></tr></tbody></table></figure><p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p><p><strong>（3）C++标准异常类  exception</strong></p><p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212342667.png"></p><ul><li>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">A* a = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  cout &lt;&lt; <span class="built_in">typeid</span>(*a).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// Error condition</span></span><br><span class="line">  }</span><br><span class="line"><span class="built_in">catch</span> (bad_typeid){</span><br><span class="line">  cout &lt;&lt; <span class="string">"Object is NULL"</span> &lt;&lt; endl;</span><br><span class="line">  }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li><li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li><li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li></ul><p id="static的用法和作用"></p><h2 id="43、static的用法和作用？"><a href="#43、static的用法和作用？" class="headerlink" title="43、static的用法和作用？"></a>43、static的用法和作用？</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p><p>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p><p>3.static的第三个作用是默认初始化为0（static变量）</p><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p><p>4.static的第四个作用：C++中的类成员声明static</p><ol><li><p>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； </p></li><li><p>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；  </p></li><li><p>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；  </p></li><li><p>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  </p></li><li><p>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p></li></ol><p>类内：</p><ol start="6"><li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p></li><li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；</p></li><li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p></li></ol><p id="指针和const的用法"></p><h2 id="44、指针和const的用法"><a href="#44、指针和const的用法" class="headerlink" title="44、指针和const的用法"></a>44、指针和const的用法</h2><ol><li><p>当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。</p></li><li><p>int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量</p></li><li><p>int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。</p></li></ol><p>底层指针表示指针所指向的变量是一个常量。</p><p id="形参与实参的区别"></p><h2 id="45、形参与实参的区别？"><a href="#45、形参与实参的区别？" class="headerlink" title="45、形参与实参的区别？"></a>45、形参与实参的区别？</h2><ol><li><p>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。</p></li><li><p>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</p></li><li><p>实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</p></li><li><p>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p></li><li><p>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</p></li></ol><p id="值传递指针传递引用传递的区别和效率"></p><h2 id="46、值传递、指针传递、引用传递的区别和效率"><a href="#46、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46、值传递、指针传递、引用传递的区别和效率"></a>46、值传递、指针传递、引用传递的区别和效率</h2><ol><li><p>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）</p></li><li><p>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</p></li><li><p>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</p></li><li><p>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</p></li></ol><p id="静态变量什么时候初始化"></p><h2 id="47、静态变量什么时候初始化"><a href="#47、静态变量什么时候初始化" class="headerlink" title="47、静态变量什么时候初始化"></a>47、静态变量什么时候初始化</h2><ol><li><p>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p></li><li><p>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p></li><li><p>而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p></li></ol><p id="const关键字的作用有哪些"></p><h2 id="48、const关键字的作用有哪些"><a href="#48、const关键字的作用有哪些" class="headerlink" title="48、const关键字的作用有哪些?"></a>48、const关键字的作用有哪些?</h2><ol><li><p>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；  </p></li><li><p>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  </p></li><li><p>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；  </p></li><li><p>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；  </p></li><li><p>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p></li><li><p>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</p></li><li><p>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</p></li><li><p>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</p></li><li><p>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</p></li><li><p>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</p></li><li><p>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p></li></ol><p id="什么是类的继承"></p><h2 id="49、什么是类的继承？"><a href="#49、什么是类的继承？" class="headerlink" title="49、什么是类的继承？"></a>49、什么是类的继承？</h2><ol><li>类与类之间的关系</li></ol><p>has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；</p><p>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p><p>is-A，继承关系，关系具有传递性；</p><ol start="2"><li>继承的相关概念</li></ol><p>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；</p><ol start="3"><li>继承的特点</li></ol><p>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；</p><ol start="4"><li>继承中的访问控制</li></ol><p>public、protected、private</p><ol start="5"><li><p>继承中的构造和析构函数</p></li><li><p>继承中的兼容性原则</p></li></ol><p id="从汇编层去解释一下引用"></p><h2 id="50、从汇编层去解释一下引用"><a href="#50、从汇编层去解释一下引用" class="headerlink" title="50、从汇编层去解释一下引用"></a>50、从汇编层去解释一下引用</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>:      <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00401048</span>  mov     dword ptr [ebp<span class="number">-4</span>],<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:     <span class="type">int</span> &amp;b = x;</span><br><span class="line"></span><br><span class="line"><span class="number">0040104F</span>   lea     eax,[ebp<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">00401052</span>  mov     dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p><p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器</p><p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址</p><p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p><p id="深拷贝与浅拷可以描述一下吗"></p><h2 id="51、深拷贝与浅拷可以描述一下吗？"><a href="#51、深拷贝与浅拷可以描述一下吗？" class="headerlink" title="51、深拷贝与浅拷可以描述一下吗？"></a>51、深拷贝与浅拷可以描述一下吗？</h2><p>浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p><p>深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。 </p><p>在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><p id="new和malloc的区别"></p><h2 id="52、new和malloc的区别"><a href="#52、new和malloc的区别" class="headerlink" title="52、new和malloc的区别"></a>52、new和malloc的区别</h2><p>1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；</p><p>2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><p>3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><p>4、 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><p>5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p><p id="pallocator都有什么作用"></p><h2 id="53、delete-p、delete-p、allocator都有什么作用？"><a href="#53、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="53、delete p、delete [] p、allocator都有什么作用？"></a>53、delete p、delete [] p、allocator都有什么作用？</h2><p>1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p><p>2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p><p>3、 delete[]时，数组中的元素按逆序的顺序进行销毁；</p><p>4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p><p id="delete是如何知道释放内存的大小的"></p><h2 id="54、new和delete的实现原理，-delete是如何知道释放内存的大小的？"><a href="#54、new和delete的实现原理，-delete是如何知道释放内存的大小的？" class="headerlink" title="54、new和delete的实现原理， delete是如何知道释放内存的大小的？"></a>54、new和delete的实现原理， delete是如何知道释放内存的大小的？</h2><p>1、 new简单类型直接调用operator new分配内存；</p><p>而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p><p>对于简单类型，new[]计算好大小后调用operator new；</p><p>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p><p>①   new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</p><p>②   编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p><p>③   对象被分配了空间并构造完成，返回一个指向该对象的指针。</p><p>2、 delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p><p>3、 需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p><p id="malloc申请的存储空间能用delete释放吗"></p><h2 id="55、malloc申请的存储空间能用delete释放吗"><a href="#55、malloc申请的存储空间能用delete释放吗" class="headerlink" title="55、malloc申请的存储空间能用delete释放吗?"></a>55、malloc申请的存储空间能用delete释放吗?</h2><p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。</p><p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p><p>new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</p><p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p><p id="malloc与free的实现原理"></p><h2 id="56、malloc与free的实现原理？"><a href="#56、malloc与free的实现原理？" class="headerlink" title="56、malloc与free的实现原理？"></a>56、malloc与free的实现原理？</h2><p>1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;</p><p>2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p><p>3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p><p>4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><p id="mallocrealloccalloc的区别"></p><h2 id="57、malloc、realloc、calloc的区别"><a href="#57、malloc、realloc、calloc的区别" class="headerlink" title="57、malloc、realloc、calloc的区别"></a>57、malloc、realloc、calloc的区别</h2><ol><li>malloc函数</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));申请<span class="number">20</span>个<span class="type">int</span>类型的空间；</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>calloc函数</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p><ol start="3"><li>realloc函数</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>给动态分配的空间分配额外的空间，用于扩充容量。</p><p id="为什么用成员初始化列表会快一些"></p><h2 id="58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h2><ol><li>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。</li></ol><p>这两种方式的主要区别在于：</p><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。 </p><ol start="2"><li>一个派生类构造函数的执行顺序如下：</li></ol><p>①   虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p><p>②   基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p><p>③   类类型的成员对象的构造函数（按照初始化顺序）</p><p>④   派生类自己的构造函数。</p><ol start="3"><li>方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li></ol><p id="有哪些情况必须用到成员列表初始化"></p><h2 id="59、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#59、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="59、有哪些情况必须用到成员列表初始化？作用是什么？"></a>59、有哪些情况必须用到成员列表初始化？作用是什么？</h2><ol><li>必须使用成员初始化的四种情况</li></ol><p>①    当初始化一个引用成员时；</p><p>②    当初始化一个常量成员时；</p><p>③    当调用一个基类的构造函数，而它拥有一组参数时；</p><p>④    当调用一个成员类的构造函数，而它拥有一组参数时；</p><ol start="2"><li>成员初始化列表做了什么</li></ol><p>①    编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p><p>②    list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p><p id="有什么区别吗它是如何实现的"></p><h2 id="60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h2><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p><p id="什么是内存泄露，如何检测与避免"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之基础语法21-40</title>
      <link href="/2023/02/04/c-ji-chu-yu-fa-21-40/"/>
      <url>/2023/02/04/c-ji-chu-yu-fa-21-40/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之基础语法</h1><p id="在main执行之前和之后执行的代码可能是什么"></p><ul><li><h2 id="21、C-与Java的区别"><a href="#21、C-与Java的区别" class="headerlink" title="21、C++与Java的区别"></a>21、C++与Java的区别</h2><p><strong>语言特性</strong></p><ul><li>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</li><li>Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</li><li>C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果</li><li>Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性</li></ul><p><strong>垃圾回收</strong></p><ul><li>C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放</li><li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题</li></ul><p><strong>应用场景</strong></p><ul><li>Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）</li><li>Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架</li><li>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</li></ul><p id="西加加中斯坦特和克拉斯的区别"></p><h2 id="22、C-中struct和class的区别"><a href="#22、C-中struct和class的区别" class="headerlink" title="22、C++中struct和class的区别"></a>22、C++中struct和class的区别</h2><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点</strong></p><ul><li><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p></li><li><p>class默认是private继承， 而struct默认是public继承</p></li></ul><p><strong>引申</strong>：C++和C的struct区别</p></li><li><p>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</p></li><li><p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></p></li><li><p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p></li><li><p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</p><p id="define宏定义和const的区别"></p></li></ul><h2 id="23、define宏定义和const的区别"><a href="#23、define宏定义和const的区别" class="headerlink" title="23、define宏定义和const的区别"></a>23、define宏定义和const的区别</h2><p>  <strong>编译阶段</strong></p><ul><li><p>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、运行的时候起作用</p><p><strong>安全性</strong></p></li><li><p>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</p></li><li><p>const常量有数据类型，编译器可以对其进行类型安全检查</p><p><strong>内存占用</strong></p></li><li><p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p></li><li><p>宏不检查类型；const会检查数据类型。</p></li><li><p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p><p id="西加加中的作用"></p></li></ul><h2 id="24、C-中const和static的作用"><a href="#24、C-中const和static的作用" class="headerlink" title="24、C++中const和static的作用"></a>24、C++中const和static的作用</h2><p>  <strong>static</strong></p><ul><li><p>不考虑类的情况</p><ul><li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li><li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li><li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li></ul></li><li><p>考虑类的情况</p><ul><li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</li><li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li></ul><p><strong>const</strong></p></li><li><p>不考虑类的情况</p><ul><li>const常量在定义时必须初始化，之后无法更改</li><li>const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int&amp; i){//…}</li></ul></li><li><p>考虑类的情况</p><ul><li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li><li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li></ul><p>补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。<br>因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</p><p id="西加加的顶层康思特和底层康思特"></p></li></ul><h2 id="25、C-的顶层const和底层const"><a href="#25、C-的顶层const和底层const" class="headerlink" title="25、C++的顶层const和底层const"></a>25、C++的顶层const和底层const</h2><p>  <strong>概念区分</strong></p><ul><li><p><strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</p></li><li><p><strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</p><p><strong>举个例子</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">//顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;       <span class="comment">//底层const，b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>;    <span class="comment">//顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">//前一个const为底层，后一个为顶层，b4不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;   <span class="comment">//用于声明引用变量，都是底层const</span></span><br></pre></td></tr></tbody></table></figure><p>  <strong>区分作用</strong></p><ul><li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li><li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;<span class="type">int</span> <span class="type">const</span> a;<span class="type">const</span> <span class="type">int</span> *a;<span class="type">int</span> *<span class="type">const</span> a;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>int const a和const int a均表示定义常量类型a。</p></li><li><p>const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</p></li><li><p>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</p><p id="数组名和指针（这里为指向数组首元素的指针）区别"></p></li></ul><h2 id="26、数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#26、数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="26、数组名和指针（这里为指向数组首元素的指针）区别？"></a>26、数组名和指针（这里为指向数组首元素的指针）区别？</h2><ul><li><p>二者均可通过增减偏移量来访问数组中的元素。</p></li><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p></li><li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p><p id="final和override关键字"></p></li></ul><h2 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h2><p>  <strong>override</strong></p><p>  当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//OK</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0o</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>  <strong>final</strong></p><p>  当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : B <span class="comment">// Error: B is final</span></span><br><span class="line">{</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>  <p id="拷贝初始化和直接初始化"></p><h2 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h2><ul><li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">"I am a string"</span>)</span></span>;<span class="comment">//语句1 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span></span><br><span class="line">string str3 = <span class="string">"I am a string"</span>;<span class="comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line">string str4 = str1;<span class="comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>为了提高效率，允许编译器跳过创建临时对象这一步，</strong>直接调用构造函数构造要创建的对象，这样就完全等价于<strong>直接初始化了</strong>（语句1和语句3等价），但是需要辨别两种情况。</p><ul><li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li><li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li></ul><p id="初始化和赋值的区别"></p></li></ul><h2 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h2><ul><li>对于简单类型来说，初始化和赋值没什么区别</li><li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">num1</span>(a),<span class="built_in">num2</span>(b){};</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a){};</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a){</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>  <p id="欸克斯西的用法"></p><h2 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h2><p>  为了能够<strong>正确的在C++代码中调用C语言</strong>的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；</p><p>  哪些情况下使用extern “C”：</p><p>  （1）C++代码中调用C语言代码；</p><p>  （2）在C++中的头文件中使用；</p><p>  （3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p><p>  举个例子，C++中调用C代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_HANDLE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_HANDLE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">result_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">my_handle_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">my_handle_t</span> <span class="title">create_handle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">result_t</span> <span class="title">operate_on_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  综上，总结出使用方法<strong>，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。</strong>所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p><p>  总结出如下形式：</p><p>  （1）C++调用C函数：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">"xx.h"</span></span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  （2）C调用C++函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>{    </span><br><span class="line">}</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>  <p id="野指针和悬空指针"></p><h2 id="31、野指针和悬空指针"><a href="#31、野指针和悬空指针" class="headerlink" title="31、野指针和悬空指针"></a>31、野指针和悬空指针</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。</span><br><span class="line"></span><br><span class="line">+ 野指针  </span><br><span class="line">  野指针，指的是没有被初始化过的指针</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  int main(void) { </span><br><span class="line">      </span><br><span class="line">      int* p;     // 未初始化</span><br><span class="line">      std::cout&lt;&lt; *p &lt;&lt; std::endl; // 未初始化就被使用</span><br><span class="line">      </span><br><span class="line">      return 0;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>  因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就不会直接报错，产生非法内存访问。</p><ul><li><p>悬空指针<br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{ </span><br><span class="line">  <span class="type">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  </span><br><span class="line">  p = p2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> p2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。</span><br><span class="line">  避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</span><br><span class="line"></span><br><span class="line">  **产生原因及解决办法：**</span><br><span class="line"></span><br><span class="line">  野指针：指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</span><br><span class="line"></span><br><span class="line">  悬空指针：指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</span><br><span class="line"></span><br><span class="line">  &lt;p id = "西河西加加的类型安全"&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">## 32、C和C++的类型安全</span><br><span class="line"></span><br><span class="line">   **什么是类型安全？**</span><br><span class="line"></span><br><span class="line">  类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。</span><br><span class="line"></span><br><span class="line">  类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</span><br><span class="line"></span><br><span class="line">  **（1）C的类型安全**</span><br><span class="line"></span><br><span class="line">  C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：</span><br><span class="line"></span><br><span class="line">- printf格式输出</span><br><span class="line"></span><br><span class="line">  ![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341869.png)</span><br><span class="line"></span><br><span class="line">  上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误</span><br><span class="line"></span><br><span class="line">- malloc函数的返回值</span><br><span class="line"></span><br><span class="line">  malloc是C中进行内存分配的函数，它的返回类型是void\*即空类型指针，常常有这样的用法char\* pStr=(char\*)malloc(100\*sizeof(char))，这里明显做了显式的类型转换。</span><br><span class="line"></span><br><span class="line">  类型匹配尚且没有问题，但是一旦出现int\* pInt=(int*)malloc(100\*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  **（2）C++的类型安全**</span><br><span class="line"></span><br><span class="line">  如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</span><br><span class="line"></span><br><span class="line">- 操作符new返回的指针类型严格与对象匹配，而不是void\*</span><br><span class="line"></span><br><span class="line">- C中很多以void\*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</span><br><span class="line"></span><br><span class="line">- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</span><br><span class="line"></span><br><span class="line">- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</span><br><span class="line"></span><br><span class="line">- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</span><br><span class="line"></span><br><span class="line">  例1：使用void\*进行类型转换</span><br><span class="line"></span><br><span class="line">  ![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341679.png)</span><br><span class="line"></span><br><span class="line">  例2：不同类型指针之间转换</span><br><span class="line"></span><br><span class="line">​```cpp</span><br><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">   </span><br><span class="line">  class Parent{};</span><br><span class="line">  class Child1 : public Parent</span><br><span class="line">  {</span><br><span class="line">  public:</span><br><span class="line">  int i;</span><br><span class="line">  Child1(int e):i(e){}</span><br><span class="line">  };</span><br><span class="line">  class Child2 : public Parent</span><br><span class="line">  {</span><br><span class="line">  public:</span><br><span class="line">  double d;</span><br><span class="line">  Child2(double e):d(e){}</span><br><span class="line">  };</span><br><span class="line">  int main()</span><br><span class="line">  {</span><br><span class="line">  Child1 c1(5);</span><br><span class="line">  Child2 c2(4.1);</span><br><span class="line">  Parent* pp;</span><br><span class="line">  Child1* pc1;</span><br><span class="line">   </span><br><span class="line">  pp=&amp;c1; </span><br><span class="line">  pc1=(Child1*)pp;  // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span><br><span class="line">  cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; //输出：5</span><br><span class="line">   </span><br><span class="line">  pp=&amp;c2;</span><br><span class="line">  pc1=(Child1*)pp;  //强制转换，且类型发生变化，将造成错误</span><br><span class="line">  cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;// 输出：1717986918</span><br><span class="line">  return 0;</span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void*，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。</p>  <p id="西加加中的重载重写覆盖和隐藏的区别"></p><h2 id="33、C-中的重载、重写（覆盖）和隐藏的区别"><a href="#33、C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="33、C++中的重载、重写（覆盖）和隐藏的区别"></a>33、C++中的重载、重写（覆盖）和隐藏的区别</h2><p>  （1）重载（overload）</p><p>  重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  （2）重写（覆盖）（override）</p><p>  重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li><p>与基类的虚函数有相同的参数个数</p></li><li><p>与基类的虚函数有相同的参数类型</p></li><li><p>与基类的虚函数有相同的返回值类型</p><p>举个例子：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>{}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重写,一般加override可以确保是重写父类的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span></span>{}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  重载与重写的区别：</p><ul><li><p>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</p></li><li><p>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</p></li><li><p>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</p><p>（3）隐藏（hide）</p><p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p></li><li><p>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数。</strong>举个例子：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"B中的fun函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用的是B中的fun函数</span></span><br><span class="line">    b.A::<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* a)</span></span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"A中的fun函数"</span> &lt;&lt; endl;</span><br><span class="line">   }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class="line">    b.A::<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  补充：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>{ <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"This is A fun "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"This is A add "</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>{  <span class="comment">// 覆盖</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"this is B fun "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>{   <span class="comment">// 隐藏</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"This is B add "</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖</span></span><br><span class="line">    <span class="comment">// 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class="line"></span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">1</span>);      <span class="comment">// 调用子类 fun 覆盖函数</span></span><br><span class="line">    p-&gt;A::<span class="built_in">fun</span>(<span class="number">1</span>);   <span class="comment">// 调用父类 fun</span></span><br><span class="line">    p-&gt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span></span><br><span class="line">    <span class="comment">// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>  <p id="有哪几种的构造函数"></p><h2 id="34、C-有哪几种的构造函数"><a href="#34、C-有哪几种的构造函数" class="headerlink" title="34、C++有哪几种的构造函数"></a>34、C++有哪几种的构造函数</h2><p>  C++中的构造函数可以分为4类：</p><ul><li><p>默认构造函数</p></li><li><p>初始化构造函数（有参数）</p></li><li><p>拷贝构造函数</p></li><li><p>移动构造函数（move和右值引用）</p></li><li><p>委托构造函数</p></li><li><p>转换构造函数</p><p>举个例子：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(){<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    };  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n){}; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s){<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    }; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r){   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line"><span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    };</span><br><span class="line">    ~<span class="built_in">Student</span>(){}</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1 age:%d, num:%d\n"</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s3 age:%d, num:%d\n"</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s2 age:%d, num:%d\n"</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li><p>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</p></li><li><p>复制构造函数用于复制本类的对象</p></li><li><p>转换构造函数用于将其他类型的变量，隐式转换为本类对象</p><p id="浅拷贝和深拷贝的区别"></p></li></ul><h2 id="35、浅拷贝和深拷贝的区别"><a href="#35、浅拷贝和深拷贝的区别" class="headerlink" title="35、浅拷贝和深拷贝的区别"></a>35、浅拷贝和深拷贝的区别</h2><p>  <strong>浅拷贝</strong></p><p>  浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p>  <strong>深拷贝</strong></p><p>  深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(){</span><br><span class="line">        name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"Student"</span> &lt;&lt; endl;</span><br><span class="line">    };</span><br><span class="line">~<span class="built_in">Student</span>(){</span><br><span class="line">        cout &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; &amp;name &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    };</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student &amp;s){<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"copy Student"</span> &lt;&lt; endl;</span><br><span class="line">    };</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">{<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">Student s1;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>  <p id="内联函数和宏定义的区别"></p><h2 id="36、内联函数和宏定义的区别"><a href="#36、内联函数和宏定义的区别" class="headerlink" title="36、内联函数和宏定义的区别"></a>36、内联函数和宏定义的区别</h2><ul><li><p>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</p></li><li><p>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</p></li><li><p>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</p></li><li><p>内联函数有类型检测、语法判断等功能，而宏没有</p><p><strong>内联函数适用场景:</strong></p></li><li><p>使用宏定义的地方都可以使用 inline 函数。</p></li><li><p>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</p><p id="怕布雷克访问和继承权限怕布雷克噗若外套的区别"></p></li></ul><h2 id="37、public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#37、public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="37、public，protected和private访问和继承权限/public/protected/private的区别？"></a>37、public，protected和private访问和继承权限/public/protected/private的区别？</h2><ul><li><p>public的变量和函数在类的内部外部都可以访问。</p></li><li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p></li><li><p>private修饰的元素只能在类内访问。</p><p>（一）访问权限</p><p>派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341241.png"></p><p>派生类对基类成员的访问形象有如下两种：</p></li><li><p>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</p></li><li><p><strong>外部访问</strong>：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</p><p>（二）继承权限</p><p><strong>public继承</strong></p><p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p><p><strong>protected继承</strong></p><p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341074.png"></p><p><strong>private继承</strong></p><p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341430.png"></p><p><strong>总结</strong></p><p>一、访问权限</p></li></ul><table><thead><tr><th>访问权限</th><th>外部</th><th>派生类</th><th>内部</th></tr></thead><tbody><tr><td>public</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>protected</td><td>❌</td><td>✔</td><td>✔</td></tr><tr><td>private</td><td>❌</td><td>❌</td><td>✔</td></tr></tbody></table><p>  public、protected、private 的访问权限范围关系：</p><p>  public &gt; protected &gt; private</p><p>  二、继承权限</p><ol><li>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见</li><li>派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限</li><li>派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了 private 的继承方式遇到 private 成员是不可见外）。例如：</li></ol><ul><li><p>public 继承 + private 成员 =&gt; private</p></li><li><p>private 继承 + protected 成员 =&gt; private</p></li><li><p>private 继承 + private 成员 =&gt; 不可见</p><p id="如何用代码判断大小端存储"></p></li></ul><h2 id="38、如何用代码判断大小端存储？"><a href="#38、如何用代码判断大小端存储？" class="headerlink" title="38、如何用代码判断大小端存储？"></a>38、如何用代码判断大小端存储？</h2><p>  大端存储：字数据的高字节存储在低地址中</p><p>  小端存储：字数据的低字节存储在低地址中</p><p>  例如：32bit的数字0x12345678</p><p>  <strong>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p><p>  小端模式中的存储方式为：</p><p>  <img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205071832785.png"></p><p>  大端模式中的存储方式为：</p><p>  <img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205071832707.png"></p><p>  了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：</p><p>  <strong>方式一：使用强制类型转换</strong>-这种法子不错</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span></span><br><span class="line">    <span class="type">char</span> c = (<span class="type">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"big endian"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"little endian"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  <strong>方式二：巧用union联合体</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"big endian"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">"little endian"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>  <p id="mutable和explicit关键字的用法"></p><h2 id="39、volatile、mutable和explicit关键字的用法"><a href="#39、volatile、mutable和explicit关键字的用法" class="headerlink" title="39、volatile、mutable和explicit关键字的用法"></a>39、volatile、mutable和explicit关键字的用法</h2><p>  (1)<strong>volatile</strong></p><p>  volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>   当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p>  <strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><p>  <strong>volatile 指针</strong></p><p>  volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p><p>  修饰由指针指向的对象、数据是 const 或 volatile 的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpch;<span class="keyword">volatile</span> <span class="type">char</span>* vpch;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> pchc;<span class="type">char</span>* <span class="keyword">volatile</span> pchv;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>   注意：</p><ul><li><p>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</p></li><li><p>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</p></li><li><p>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</p><p><strong>多线程下的volatile</strong>   </p><p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p><p>（2）<strong>mutable</strong></p><p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p><p>样例</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> <span class="type">const</span><span class="comment">//在函数里不可修改this指针指向的值 常量指针</span></span></span><br><span class="line"><span class="function">     </span>{</span><br><span class="line">        m_A=<span class="number">10</span>;<span class="comment">//错误  不可修改值，this已经被修饰为常量指针</span></span><br><span class="line">        m_B=<span class="number">20</span>;<span class="comment">//正确</span></span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">const</span> person p;<span class="comment">//修饰常对象 不可修改类成员的值</span></span><br><span class="line">p.m_A=<span class="number">10</span>;<span class="comment">//错误，被修饰了指针常量</span></span><br><span class="line">p.m_B=<span class="number">200</span>;<span class="comment">//正确，特殊变量，修饰了mutable</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  （3）<strong>explicit</strong></p><p>  explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p><ul><li><p>explicit 关键字只能用于类内部的构造函数声明上</p></li><li><p>explicit 关键字作用于单个参数的构造函数</p></li><li><p>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</p><p id="什么情况下会调用拷贝构造函数"></p></li></ul><h2 id="40、什么情况下会调用拷贝构造函数"><a href="#40、什么情况下会调用拷贝构造函数" class="headerlink" title="40、什么情况下会调用拷贝构造函数"></a>40、什么情况下会调用拷贝构造函数</h2><ul><li><p>用类的一个实例化对象去初始化另一个对象的时候</p></li><li><p>函数的参数是类的对象时（非引用传递）</p></li><li><p>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</p><p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p><p><strong>在VS2019下进行下述实验：</strong></p><p>举个例子：</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() {};</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"copy constructor is called"</span> &lt;&lt; endl;</span><br><span class="line">};</span><br><span class="line">~<span class="built_in">A</span>() {};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>{}</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getClassA</span><span class="params">()</span><span class="comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">A a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//A a;</span></span><br><span class="line"><span class="comment">//return a;</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">A a1,a3,a4;</span><br><span class="line">A a2 = a1;  <span class="comment">//调用拷贝构造函数,对应情况1</span></span><br><span class="line"><span class="built_in">useClassA</span>(a1);<span class="comment">//调用拷贝构造函数，对应情况2</span></span><br><span class="line">a3 = <span class="built_in">getClassA</span>();<span class="comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span></span><br><span class="line">a4 = <span class="built_in">getClassA2</span>(a1);<span class="comment">//发生NRV优化，且引用返回自身，不会调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  情况1比较好理解</p><p>  情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象</p><p>  情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象，  依然会调用拷贝构造函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++之基础语法1-20</title>
      <link href="/2023/02/01/c-ji-chu-yu-fa-1-20/"/>
      <url>/2023/02/01/c-ji-chu-yu-fa-1-20/</url>
      
        <content type="html"><![CDATA[<h1 align="center">C++之基础语法</h1><p id="在main执行之前和之后执行的代码可能是什么"></p><h2 id="1、-在main执行之前和之后执行的代码可能是什么？"><a href="#1、-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、 在main执行之前和之后执行的代码可能是什么？"></a>1、 在main执行之前和之后执行的代码可能是什么？</h2><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容     </li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li><code>__attribute__((constructor))</code></li></ul><p><strong>main函数执行之后</strong>：  </p><ul><li>全局对象的析构函数会在main函数之后执行； </li><li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</li><li><code>__attribute__((destructor))</code></li></ul><p id="结构体内存对齐问题"></p><h2 id="2、结构体内存对齐问题？"><a href="#2、结构体内存对齐问题？" class="headerlink" title="2、结构体内存对齐问题？"></a>2、结构体内存对齐问题？</h2><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul><p>c++11以后引入两个关键字 <a href="https://zh.cppreference.com/w/cpp/language/alignas">alignas</a>与 <a href="https://zh.cppreference.com/w/cpp/language/alignof">alignof</a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</p><p>但是<code>alignas</code>在某些情况下是不能使用的，具体见下面的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alignas 生效的情况</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint16_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">};</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 6  2 + 2 + 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Info2 {</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint16_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">};</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="comment">// 8  4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p><code>alignas</code>将内存对齐调整为4个字节。所以<code>sizeof(Info2)</code>的值变为了8。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alignas 失效的情况</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">};</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 12  4 + 4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">2</span>) Info2 {</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">};</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="comment">// 12  4 + 4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</p><ul><li><p>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(push,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">} ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 6 1 + 4 + 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>确定结构体中每个元素大小可以通过下面这种方法:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(push,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 0 1   3     6   8 9            15</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* |a| b |  c  | d |e|     pad     |</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> {</span><br><span class="line">  <span class="type">uint16_t</span> a : <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint16_t</span> b : <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint16_t</span> c : <span class="number">3</span>;</span><br><span class="line">  <span class="type">uint16_t</span> d : <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint16_t</span> e : <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint16_t</span> pad : <span class="number">7</span>;</span><br><span class="line">} ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>这种处理方式是<code>alignas</code>处理不了的。</p></li></ul><p id="指针和引用的区别"></p><h2 id="3、指针和引用的区别"><a href="#3、指针和引用的区别" class="headerlink" title="3、指针和引用的区别"></a>3、指针和引用的区别</h2><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li><li>引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。</li><li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><p>参考代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">　　<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　cout&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPTR</span><span class="params">(<span class="type">int</span>* p)</span> </span>{</span><br><span class="line"><span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">p = &amp;a;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testREFF</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>{</span><br><span class="line"><span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">p = a;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b = &amp;a;</span><br><span class="line"><span class="built_in">testPTR</span>(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line">cout &lt;&lt; *b &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">testREFF</span>(a);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> 在编译器看来, int a = 10; int &amp;b = a; 等价于 int * const b = &amp;a; 而 b = 20; 等价于 *b = 20; 自动转换为指针和自动解引用. </p><p id="在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢"></p><h2 id="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h2><ul><li><p>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</p></li><li><p>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</p></li><li><p>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</p></li></ul><p id="堆和栈的区别"></p><h2 id="5、堆和栈的区别"><a href="#5、堆和栈的区别" class="headerlink" title="5、堆和栈的区别"></a>5、堆和栈的区别</h2><ul><li><p>申请方式不同。</p><ul><li>栈由系统自动分配。</li></ul></li><li><p>堆是自己申请和释放的。</p></li><li><p>申请大小限制不同。</p><ul><li><p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</p></li><li><p>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p></li></ul></li><li><p>申请效率不同。</p><ul><li><p>栈由系统分配，速度快，不会有碎片。</p></li><li><p>堆由程序员分配，速度慢，且会有碎片。</p></li></ul></li></ul><p> 栈空间默认是4M, 堆区一般是 1G - 4G </p><table><thead><tr><th align="left"></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td align="left"><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td align="left"><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删    除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td></tr><tr><td align="left"><strong>空间大小</strong></td><td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit  系统理论上是4G），所以堆的空间比较灵活，比较大</td><td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在  编译时确定，VC中可设置）</td></tr><tr><td align="left"><strong>碎片问题</strong></td><td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td></tr><tr><td align="left"><strong>生长方向</strong></td><td>堆向上，向高地址方向增长。</td><td>栈向下，向低地址方向增长。</td></tr><tr><td align="left"><strong>分配方式</strong></td><td>堆都是动态分配（没有静态分配的堆）</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td align="left"><strong>分配效率</strong></td><td>堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门  寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table><p><strong>形象的比喻</strong></p><p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p><p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><p id="你觉得堆快一点还是栈快一点"></p><h2 id="6、你觉得堆快一点还是栈快一点？"><a href="#6、你觉得堆快一点还是栈快一点？" class="headerlink" title="6、你觉得堆快一点还是栈快一点？"></a>6、你觉得堆快一点还是栈快一点？</h2><p>毫无疑问是栈快一点。</p><p>因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p><p>而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p><p id="区别以下指针类型"></p><h2 id="7、区别以下指针类型？"><a href="#7、区别以下指针类型？" class="headerlink" title="7、区别以下指针类型？"></a>7、区别以下指针类型？</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li><li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li><li>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li><li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。<p id="newdelete与mallocfree的异同"></p></li></ul><h2 id="8、new-delete-与-malloc-free的异同"><a href="#8、new-delete-与-malloc-free的异同" class="headerlink" title="8、new / delete 与 malloc / free的异同"></a>8、new / delete 与 malloc / free的异同</h2><p><strong>相同点</strong></p><ul><li>都可用于内存的动态申请和释放<br><strong>不同点</strong></li><li>前者是C++运算符，后者是C/C++语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">double</span>));<span class="comment">//编译无错误</span></span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li></ul><p id="new和delete是如何实现的"></p><h2 id="9、new和delete是如何实现的？"><a href="#9、new和delete是如何实现的？" class="headerlink" title="9、new和delete是如何实现的？"></a>9、new和delete是如何实现的？</h2><ul><li>new的实现过程是：首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li><li>delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li></ul><p id="malloc和new的区别"></p><h2 id="10、malloc和new的区别？"><a href="#10、malloc和new的区别？" class="headerlink" title="10、malloc和new的区别？"></a>10、malloc和new的区别？</h2><ul><li><p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。</p></li><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li><li><p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p></li></ul><p id="既然有了为什么还需要呢？直接用不好吗"></p><h2 id="11、既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？"><a href="#11、既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？" class="headerlink" title="11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？"></a>11、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？</h2><ul><li>malloc/free和new/delete都是用来申请内存和回收内存的。</li><li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。</li></ul><p id="被free回收的内存是立即返还给操作系统吗"></p><h2 id="12、被free回收的内存是立即返还给操作系统吗？"><a href="#12、被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="12、被free回收的内存是立即返还给操作系统吗？"></a>12、被free回收的内存是立即返还给操作系统吗？</h2><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><p id="宏定义和函数有何区别"></p><h2 id="13、宏定义和函数有何区别？"><a href="#13、宏定义和函数有何区别？" class="headerlink" title="13、宏定义和函数有何区别？"></a>13、宏定义和函数有何区别？</h2><ul><li>宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li><li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li><li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li><li>宏定义不要在最后加分号。</li></ul><p id="宏定义和typedef区别"></p><h2 id="14、宏定义和typedef区别？"><a href="#14、宏定义和typedef区别？" class="headerlink" title="14、宏定义和typedef区别？"></a>14、宏定义和typedef区别？</h2><ul><li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p></li></ul><p id="变量声明和定义区别"></p><h2 id="15、变量声明和定义区别？"><a href="#15、变量声明和定义区别？" class="headerlink" title="15、变量声明和定义区别？"></a>15、变量声明和定义区别？</h2><ul><li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p></li><li><p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p></li></ul><p id="strlen和sizeof区别"></p><h2 id="16、strlen和sizeof区别？"><a href="#16、strlen和sizeof区别？" class="headerlink" title="16、strlen和sizeof区别？"></a>16、strlen和sizeof区别？</h2><ul><li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p></li><li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">"name"</span>;</span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="16-2、（补充）一个指针占多少字节？"><a href="#16-2、（补充）一个指针占多少字节？" class="headerlink" title="16.2、（补充）一个指针占多少字节？"></a>16.2、（补充）一个指针占多少字节？</h2><p>在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；</p><p>而在32位环境下，指针占用大小为4字节。</p><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p><p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p><p id="常量指针和指针常量区别"></p><h2 id="17、常量指针和指针常量区别？"><a href="#17、常量指针和指针常量区别？" class="headerlink" title="17、常量指针和指针常量区别？"></a>17、常量指针和指针常量区别？</h2><ul><li><p>指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。</p></li><li><p>常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。</p></li></ul><p id="哎和爱有什么区别"></p><h2 id="18、a和-a有什么区别？"><a href="#18、a和-a有什么区别？" class="headerlink" title="18、a和&amp;a有什么区别？"></a>18、a和&amp;a有什么区别？</h2><p>假设数组int a[10]; int (*p)[10] = &amp;a;其中：</p><ul><li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ul><p id="西加加和派森的区别"></p><h2 id="19、C-和Python的区别"><a href="#19、C-和Python的区别" class="headerlink" title="19、C++和Python的区别"></a>19、C++和Python的区别</h2><p>包括但不限于：</p><ul><li>Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li><li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>Python的库函数比C++的多，调用起来很方便</li></ul><p id="西加加和西语言的区别"></p><h2 id="20、C-和C语言的区别"><a href="#20、C-和C语言的区别" class="headerlink" title="20、C++和C语言的区别"></a>20、C++和C语言的区别</h2><ul><li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li><li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li><li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li><li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li><li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li><li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的</li><li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li><li>C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解网络编程和套接字</title>
      <link href="/2023/01/29/li-jie-wang-luo-bian-cheng-he-tao-jie-zi/"/>
      <url>/2023/01/29/li-jie-wang-luo-bian-cheng-he-tao-jie-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章：理解网络编程和套接字"><a href="#第-1-章：理解网络编程和套接字" class="headerlink" title="第 1 章：理解网络编程和套接字"></a>第 1 章：理解网络编程和套接字</h1><h2 id="1-1-理解网络编程和套接字"><a href="#1-1-理解网络编程和套接字" class="headerlink" title="1.1 理解网络编程和套接字"></a><strong>1.1 理解网络编程和套接字</strong></h2><h3 id="1-1-1构建打电话套接字"><a href="#1-1-1构建打电话套接字" class="headerlink" title="1.1.1构建打电话套接字"></a>1.1.1构建打电话套接字</h3><p>以电话机打电话的方式来理解套接字。<br>调用 socket 函数（安装电话机）时进行的对话：<br>问：接电话需要准备什么？<br>答：当然是电话机。<br>有了电话机才能安装电话，于是就要准备一个电话机，下面函数相当于电机的套接字。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></tbody></table></figure><p>调用 bind 函数（分配电话号码）时进行的对话：</p><p>问：请问我的电话号码是多少<br>答：我的电话号码是123-1234<br>套接字同样如此。就想给电话机分配电话号码一样，利用以下函数给创建好的套接字分配地址信息（IP地址和端口号）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br></pre></td></tr></tbody></table></figure><p>调用 bind 函数给套接字分配地址之后，就基本完成了所有的准备工作。接下来是需要连接电话线并等待来电。<br>调用 listen 函数（连接电话线）时进行的对话：<br>问：已架设完电话机后是否只需链接电话线？<br>答：对，只需要连接就能接听电话。<br>一连接电话线，电话机就可以转换为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接受连接状态。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br></pre></td></tr></tbody></table></figure><p>连接好电话线以后，如果有人拨打电话就响铃，拿起话筒才能接听电话。<br>调用 accept 函数（拿起话筒）时进行的对话：<br>问：电话铃响了，我该怎么办？<br>答：接听啊。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></tbody></table></figure><p>网络编程中和接受连接请求的套接字创建过程可整理如下：</p><ol><li><p>第一步：调用 socket 函数创建套接字。</p></li><li><p>第二步：调用 bind 函数分配IP地址和端口号。</p></li><li><p>第三步：调用 listen 函数转换为可接受请求状态。</p></li><li><p>第四步：调用 accept 函数受理套接字请求。<br>  1.1.2 编写 Hello World 套接字程序<br>  服务端：<br>  服务器端（server）是能够受理连接请求的程序。下面构建服务端以验证之前提到的函数调用过程，该<br>  服务器端收到连接请求后向请求者返回 Hello World! 答复。除各种函数的调用顺序外，我们还未涉及<br>  任何实际编程。因此，阅读代码时请重点关注套接字相关的函数调用过程，不必理解全过程。<br>  服务器端代码请参见：hello_server.c<br>  客户端：<br>  客户端程序只有 调用 socket 函数创建套接字 和 调用 connect 函数向服务端发送连接请求 这两个步<br>  骤，下面给出客户端，需要查看以下两方面的内容：</p></li><li><p>调用 socket 函数 和 connect 函数</p></li><li><p>与服务端共同运行以收发字符串数据 </p><p>客户端代码请参见：hello_client.c<br>编译：<br>分别对客户端和服务端程序进行编译：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_server.c -o hserver</span><br><span class="line">gcc hello_client.c -o hclient</span><br></pre></td></tr></tbody></table></figure><p>运行：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./hserver <span class="number">9190</span></span><br><span class="line">./hclient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">9190</span></span><br></pre></td></tr></tbody></table></figure><p>运行的时候，首先再 9190 端口启动服务，然后 heserver 就会一直等待客户端进行响应，当客户端监听位于本地的 IP 为 127.0.0.1 的地址的9190端口时，客户端就会收到服务端的回应，输出 Hello World!</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> TCP/IP网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站在对象模型的类端</title>
      <link href="/2023/01/28/zhan-zai-dui-xiang-mo-xing-de-lei-duan/"/>
      <url>/2023/01/28/zhan-zai-dui-xiang-mo-xing-de-lei-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="模板感悟"><a href="#模板感悟" class="headerlink" title="模板感悟"></a>模板感悟</h1><h3 id="模板的实例化"><a href="#模板的实例化" class="headerlink" title="模板的实例化"></a>模板的实例化</h3><p><strong>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++标准才要求实例化他们。</strong>其原因，有两点：</p><ul><li><strong>空间和时间效率的考虑，</strong>如果模板类中有100个成员函数，对某个特定类型只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩余的195个函数实例化将浪费大量的时间和空间。</li><li><strong>使模板有最大的适用性。</strong>并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li></ul><p>可以明确的要求在一个文件中将整个类模板实例化：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Point3d</span>&lt;<span class="type">float</span>&gt;;</span><br></pre></td></tr></tbody></table></figure><p>也可以显示指定实例化一个模板类的成员函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">float</span> Point3d&lt;<span class="type">float</span>&gt;::<span class="built_in">X</span>() <span class="type">const</span>;</span><br></pre></td></tr></tbody></table></figure><p>或是针对一个模板函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> Point3d&lt;<span class="type">float</span>&gt; <span class="keyword">operator</span>+(   </span><br><span class="line">    <span class="type">const</span> Point3d&lt;<span class="type">float</span>&gt;&amp;, <span class="type">const</span> Point3d&lt;<span class="type">float</span>&gt;&amp; );</span><br></pre></td></tr></tbody></table></figure><p>模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。</p><h3 id="模板的名称决议"><a href="#模板的名称决议" class="headerlink" title="模板的名称决议"></a>模板的名称决议</h3><p>一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of the temlate instantiation”，可以直译为“实例化模板的范围”。</p><p>第一种情况：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">type</span> &gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScopeRules</span>  </span><br><span class="line">{  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invariant</span><span class="params">()</span> </span>{  </span><br><span class="line">        _member = <span class="built_in">foo</span>( _val );  </span><br><span class="line">    }  </span><br><span class="line">    </span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>( _member );  </span><br><span class="line">    }  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> _val;  </span><br><span class="line">    type _member;  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第二种情况:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope of the template instantiation  </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">ScopeRules&lt; <span class="type">int</span> &gt; sr0;  </span><br><span class="line">sr0.<span class="built_in">invariant</span>();</span><br><span class="line">sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></tbody></table></figure><p>在“scope of the template instantiation ”中 两个foo()都声明在此 scope中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">foo</span> <span class="params">( <span class="type">double</span> )</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>看上去，应该调用：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()<br>中调用的却在我们意料之中，调用的是:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">( <span class="type">int</span> )</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>诸上所述,看上去或合理或不合理的选择，原因在于:</p><blockquote><p>template 之中， 对于一个非成员名字的决议结果是根据这个 name<br>的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互<br>不相干，那么就以“scope of the template dclaration”来决定name。如果其<br>使用的互相关联，那么就以“scope of the template<br>instantiation”来决定name.</p></blockquote><p>对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场面，估计没有一个模板设计者能够hold住。相反，对于一个与实例化类型有关的名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字早在模板定义时被决议出来，那就该轮到模板的使用者hold不住了。当然所上完全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。</p><h1 id="EH-RTTI"><a href="#EH-RTTI" class="headerlink" title="EH &amp; RTTI"></a>EH &amp; RTTI</h1><h3 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理(Exception Handling)"></a>异常处理(Exception Handling)</h3><p>C++的 exception handling 有三个主要的子句组成：</p><ul><li>一个throw子句。它在程序的某处丢出一个exception，被丢出的exception可以是内建类型，也可以是自定义类型。——抛出exception组件。</li><li>一个或多个 catch 子句。 每一个 catch 子句都是一个 exception handler。每个子句可以处理一种类型(也包括其继承类)的exception，在大括号中包含处理代码。——专治各<br>种不服组件。每一个catch子句都可以用来处理某exception。</li><li>一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出exception，从而引发catch 子句的作用。——逮捕各种 exception 组件。</li></ul><p>当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的catch子句，如果各层调用都没有吻合的catch子句，<code>terminate()</code>将被调用。在控制权被放弃后，堆栈中<br>的每一个函数调用也被出栈，这个过程称为unwinding the stack(关于 stack unwinding ,可以参考《C++ Primer》第四版之 17.1.2 Stack Unwinding)，在每一个函数被出栈之前,其局部变量会被摧毁。</p><p>异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。解决方法之一是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">mumble</span><span class="params">( <span class="type">void</span> *arena )</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    Point *p;  </span><br><span class="line">    p = <span class="keyword">new</span> Point;  </span><br><span class="line">    <span class="keyword">try</span> {  </span><br><span class="line">        <span class="built_in">smLock</span>( arena );  </span><br><span class="line">        <span class="comment">// ...  </span></span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">catch</span> ( ... ) {  </span><br><span class="line">        <span class="built_in">smUnLock</span>( arena );  </span><br><span class="line">        <span class="keyword">delete</span> p;  </span><br><span class="line">        <span class="keyword">throw</span>;  </span><br><span class="line">    }  </span><br><span class="line">    <span class="built_in">smUnLock</span>( arena );  </span><br><span class="line">    <span class="keyword">delete</span> p;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。new expression的调用不用包括在try块之内是因为，不论在new operator调用时还是构造函数调用时抛出异常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete 。</p><p>另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。</p><p>在对单个对象构造过程中抛出异常，会只调用已经构造好的base class object或member class object的析构函数。<strong>同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那</strong><br><strong>么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象构造的原则，然后释放已经分配好的内存。</strong></p><p>只有在一个catch子句评估完毕并且知道它不会再抛出exception后，真正的exception object才会被释放。关于 catch子句使用引用还是使用对象来捕获异常，省略。</p><h3 id="执行期类型识别（Runtime-Type-Identification-RTTI）"><a href="#执行期类型识别（Runtime-Type-Identification-RTTI）" class="headerlink" title="执行期类型识别（Runtime Type Identification RTTI）"></a>执行期类型识别（Runtime Type Identification RTTI）</h3><ol><li>RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。</li><li>对指针进行<code>dynamic_cast</code>失败会返回NULL ,而对引用的话，识别会抛出bad_cast exception`。</li><li>typeid 可以返回<code>const type_info&amp;</code>，用以获取类型信息。</li></ol><p>关于1是因为RTTI的实现是通过vptr来获取存储在虚函数表中的<code>type_info*</code> ，事实上为非多态类提供RTTI,也没有多大意义。 2的原因在于指针可以被赋值为0，以表示 no object，但是引用不行。关于3，虽然第一点指出RTTI只支持多态类，但<code>typeid</code>和<code>type_info</code>同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的<code>type_info</code>对象是静态取得(所以不能叫“执行期类型识别”)，而多态类的是在执行期获得。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行期语意学</title>
      <link href="/2023/01/12/zhi-xing-qi-yu-yi-xue/"/>
      <url>/2023/01/12/zhi-xing-qi-yu-yi-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="new-expression、operator-new-和-placement-new——三个妞（new）的故事（1）"><a href="#new-expression、operator-new-和-placement-new——三个妞（new）的故事（1）" class="headerlink" title="new expression、operator new 和 placement new——三个妞（new）的故事（1）"></a>new expression、operator new 和 placement new——三个妞（new）的故事（1）</h1><p>之前虽然一直知道有new expression、operator new和placement new，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new和delete，特意结合《C++ Primer》写下这篇笔记，以作总结。</p><h3 id="new-expression-和-operator-new"><a href="#new-expression-和-operator-new" class="headerlink" title="new expression 和 operator new"></a>new expression 和 operator new</h3><p>一个看起来很简单的new expression运算，其实暗含一些步骤，像这样的一次简单运用：<br><code>int *p=new int (5)</code>实际上包含着两个步骤：</p><ol><li>调用一个合适的operator new实体分配足够的未类型化的内存。</li><li>调用合适的构造函数初始化这块内存，当然<code>int</code>没有构造函数，但是会进行赋值操作：<br><code>*p=5</code>。</li></ol><p>由此可见：new expression和operator new完全不是一回事，但关系不浅——operator new 为new expression分配内存。</p><p>摘录一下 《C++ primer》关于对比new expression 和 operator new的一小段话：</p><blockquote><p>标准库函数 operator new和 operator delete 的命名容易让人误解。与其他operator 函<br>数（如 <code>operator=</code>）不同，这些函数没有重载new或delete expression，实际上，我们<br>不能重定义new或delete expression的行为。</p></blockquote><p>这段话有两个要点：</p><ol><li>operator new和operator delete不<strong>是new expression和delete expression的重载</strong>，它们完全是另外的一个独立的东西，具有不同的语意，这与operator +是对+ expression的重载不同。</li><li>new expression和delete expression是不能被重载的，可以看出它们与普通的expression 不同。</li></ol><p>operator new其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用operator new 来进行。用法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* newelements = static_cast&lt;T*&gt;(operator new ( sizeof(T) );</span><br></pre></td></tr></tbody></table></figure><p>标准库重载有两个版本的operator new，分别为单个对象和数组对象服务，单个对象版本的提供给分配单个对象new expression调用，数组版的提供给分配数组的 new expression 调用：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;     <span class="comment">// allocate anobject</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// allocate an array</span></span><br></pre></td></tr></tbody></table></figure><p>我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operator new时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个<code>void*</code>类型和第一个参数的类型必须为<code>size_t</code>。</p><p>还要注意的是，在类中重载的operator new和operator delete是<strong>隐式静态的，因为前者运行于对象构造之前，后者运行于对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据</strong>。另外，new expression 默认调用的是单参数的operator new——上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p><p>delete expression与new expression相对应，而operator delete则与operator new对应。综上所述，则不难推断出关于delete expression和operator delete之间的关系以及一些特性，此略。</p><p>当使用new expression来动态分配数组的时候，Lippman在<strong>《深度探索C++对象模型》中指出：当分配的类型有一个默认构造函数的时候，new expression将调用一个所谓的<code>vec_new()</code>函数来分配内存，而不是operator new内存。</strong></p><p>但我在VC ++ 2010 上测试的结果却是，不论有没有构造函数，new expression都是调用operator new来分配内存，并在此之后，调用默认构造函数逐个初始化它们，而不调用所谓的<code>vec_new()</code>，也许cfront确实离我们有点遥远。</p><p><strong>总结:</strong></p><ol><li><p>operator new/operator delete operator new[] /operator delete[] 和 malloc/free用法一 样。</p></li><li><p>他们只负责分配空间/释放空间， 不会调用对象构造函数/析构函数来初始化/清理对象。</p></li><li><p>实际operator new和operator delete只是malloc和free的一层封装。</p></li></ol><h1 id="new-expression、operator-new和placement-new——三个妞（new）的故事（2）"><a href="#new-expression、operator-new和placement-new——三个妞（new）的故事（2）" class="headerlink" title="new expression、operator new和placement new——三个妞（new）的故事（2）"></a>new expression、operator new和placement new——三个妞（new）的故事（2）</h1><h3 id="两个-delete-后的问题"><a href="#两个-delete-后的问题" class="headerlink" title="两个 delete 后的问题"></a>两个 delete 后的问题</h3><p>最近在网上看到两个关于指针 delete 后的问题。第一种情况：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">// p为什么能delete两次，而程序运行的时候还不报错。</span></span><br></pre></td></tr></tbody></table></figure><p>第二种情况：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span> ;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">*p = <span class="number">5</span>;     <span class="comment">//delete后对*p进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？</span></span><br></pre></td></tr></tbody></table></figure><p>在回答这两个问题之前，我们先想想delete p; 这一语句意味着什么？p指向一个地址，以该地址为起始地址保存有一个<code>int</code>变量（虽然该变量并没有进行初始化），<code>delete p</code>之后<code>p</code>所指向的地址空间被释放，也就是说这个<code>int</code>变量的生命结束，但是<code>p</code>仍旧是一个合法的指针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与<code>delete</code>之前唯一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？<strong>你租了一间储物室（<code>int* p = new int;</code>），后来退租了（<code>delete p;</code>），但你却保存了出入该储物室的钥匙（指针<code>p</code>）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。</strong>但是：</p><p>你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再之后各种难以预料的情况就会发生。</p><p>又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾出空间来放你的。</p><p>回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大的逻辑错误，<strong>不论你对一块已经释放的内存再度<code>delete</code>，还是再度给它赋值，都暗含着很大的危险，因为当你delete后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再度分配出去，此时不论是你再度<code>delete</code>还是重新赋值，都将破坏其它代码的数据，同时你存储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，</strong>这取决于有一个怎么样的“房东”，聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。</p><p>上述情况下的指针p被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的内存。<strong>避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为<code>NULL</code>，其缘由在于，你可以很容易的判断一个指针是否为<code>NULL</code>,却难以抉择其是否为野指针。而且，<code>delete</code>一个空指针，不会做任何操作，因此总是安全的。</strong></p><h3 id="不用一个基类指针指向派生类数组？"><a href="#不用一个基类指针指向派生类数组？" class="headerlink" title="不用一个基类指针指向派生类数组？"></a>不用一个基类指针指向派生类数组？</h3><p>《深度探索C++对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的cfront中的<code>vec_delete</code>是根据被删除指针的类型来调用析构函数——也就是说虚函数机制在这儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。</p><p>我在vc++2008和vc++ 2010下的结果是：是的，有与cfront不同，它支持多态。在VS2019上也是这个结果</p><p>我的测试代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">point</span>(){</span><br><span class="line">            std::cout&lt;&lt;<span class="string">"point::~point()"</span>&lt;&lt;std::endl;</span><br><span class="line">        }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  a;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point3d</span>:<span class="keyword">public</span> point{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">point3d</span>()</span><br><span class="line">        {</span><br><span class="line">            std::cout&lt;&lt;<span class="string">"point3d::~point3d()"</span>&lt;&lt;std::endl;</span><br><span class="line">        }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    point *p=<span class="keyword">new</span> point3d[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">} ;</span><br></pre></td></tr></tbody></table></figure><p><strong>输出的结果，也令人满意：</strong></p><p><a href="http://www.roading.org/images/2011-12/image_thumb1.png"><img src="http://www.roading.org/images/2011-12/image_thumb1.png" alt="VC输出的结果"></a></p><p>VC输出的结果</p><p><strong>确实调用了派生类的析构函数，而非基类的析构函数。</strong></p><p>即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。<strong>非得这么做？那么我认为<code>delete</code>的时候将之类类型转换为派生类就差不多了，可以这样:</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] <span class="built_in">static_cast</span>&lt;point3d*&gt;(p);</span><br></pre></td></tr></tbody></table></figure><p>似乎不必要像Lippman说的这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> ix = <span class="number">0</span>; ix &lt; elem_count; ++ix ) {      Point3d *p = &amp;((Point3d*)ptr)[ ix ];      <span class="keyword">delete</span> p;  }</span><br></pre></td></tr></tbody></table></figure><h1 id="new-expression、operator-new和placement-new——三个妞（new）的故事（3）"><a href="#new-expression、operator-new和placement-new——三个妞（new）的故事（3）" class="headerlink" title="new expression、operator new和placement new——三个妞（new）的故事（3）"></a>new expression、operator new和placement new——三个妞（new）的故事（3）</h1><h2 id="placement-operator-new"><a href="#placement-operator-new" class="headerlink" title="placement operator new"></a>placement operator new</h2><p>placement operator new用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是 对指定地址调用构造函数。其调用方式如下：</p><p><code>point *pt=new(p) point3d;</code><br>观其名字可知，它是operator new的一个重载版本。它的实现方式异常简单，传回一个指针即 可：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">site_t</span>,<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{    <span class="keyword">return</span> p;}</span><br></pre></td></tr></tbody></table></figure><p>不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman告诉我们，它有另一半重要的工 作是被扩充而来。我在想，扩充一个类中定义的placement operator new还好说，但是要如何 扩充一个库中提供的placement operator new呢？毕竟它要放之四海而皆准，我原以为这其中 有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement operator new 也并不强 大。</p><p>我先明确调用了 placement operator new ：</p><p><code>point *pt=(point*)operator new(sizeof(point), p) ;</code><br>如我所料，输出结果显示（我在point的默认构造函数和placement operator new中间各输 出一句不同的话），此时 point的默认构造函数并不会被调用。然后我通过new expression 的方式来间接调用placement operator new：</p><p>point *pt=new(p) point();`<br>这个时候 point 的默认的构造函数被调用了。可见 placement operator new并没有什么奇特 的地方，它与一般的operator new不同处在于，它不会申请内存。它也不会在指定的地址调用 构造函数，而调用构造函数的的全部原因在于new expression总是先调用一个匹配参数的 operator new然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new 也是一个 operator new。</p><p><strong>通过一个placement operator new构建的一个对象，如果你使用delete来撤销对象，那么其内 存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。</strong></p><p>看一份代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> { <span class="type">int</span> j; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; };</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base { <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; };</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">()</span> </span>{  </span><br><span class="line">   Base b;  </span><br><span class="line">   b.<span class="built_in">f</span>(); <span class="comment">// Base::f() invoked  </span></span><br><span class="line">   b.~<span class="built_in">Base</span>();  <span class="comment">//析构掉了，但是内存并未释放掉</span></span><br><span class="line">   <span class="keyword">new</span> ( &amp;b ) Derived; <span class="comment">// 1  </span></span><br><span class="line">   b.<span class="built_in">f</span>(); <span class="comment">// which f() invoked?  </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>上述两个类的大小相同，因此将Derived对象放在 Base对象中是安全的，但是在最后一句代码 中 <code>b.f()</code>调用的是哪一个类的<code>f()</code>。答案是<code>Base::f()</code> 的。虽然此时b中存储的实际上是一个 Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。</strong></p><h1 id="对象的构造与析构"><a href="#对象的构造与析构" class="headerlink" title="对象的构造与析构"></a>对象的构造与析构</h1><p>一般而言，构造函数被安插在对象的定义处，而析构函数被安插在对象生命周期结束前：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ Code  </span></span><br><span class="line">{ Point point; <span class="comment">// point.Point::Point() 一般被安插在这儿      </span></span><br><span class="line">    ...      </span><br><span class="line">             <span class="comment">// point.Point::~Point() 一般被安插在这儿 </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>当代码有一个以上的离开点的时候，析构函数则必须放在对象被构造之后的每一个离开点之前。因此，尽可能将对象定义在接近要使用的地方</strong>，可以减少不必要的构造对象和析构对象的代码被插入到自己的代码当中。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>一个全局对象，c++保证它在<code>main()</code>在第一次使用它之前将其构造，而在main()`结束之前，将之析构掉。C规定一个全局对象只能被一个常量表达式(编译期可知)赋初值。而构造函数显然不是一个常量表达式。虽然全局对象在编译期被即被置为0，但真正的构造工作却需要直到程序激活后才能进行，而这个过程就是所谓的静态初始化。我是这样理解，但我不保证正确，因为全局变量，被放在data segment (数据段)，data segment是在编译期已经布置好的，但构造函数的结果在编译期不能评估，因此先将对象的内容设置为0，存储在数据段，而等到程序激活时，这时候就可以通过构造函数对在数据段的全局对象进行初始化了，而这就是所谓的静态初始化。</p><p>静态初始化的对象有一些缺点：如果构造函数支持异常机制，那么遗憾的是对象的构造函数的调用，无法被放置于try块中，我们知道一个没有得到catch的异常默认的调用<code>terminate()</code>函数。也就是说一个全局对象在构造过程中抛出异常，将导致程序的终结，而更悲剧的是，你还无法来捕获并处理这个异常。另一点在于，在不同文件中定义的全局变量，构造顺序有规则吗？我不知道。即使有规则，如果不同的构造顺序对程序有影响的话，那么有多琐碎复杂…</p><p>Lippman甚至建议：根本就不要使用那些需要静态初始化的全局对象。真的非要一个全局对象，而且这个对象还需要静态初始化？那么我的方法是，用一个函数封装一个静态局部对象，也是一样的效果嘛。</p><h3 id="局部静态对象-Local-Static-Object"><a href="#局部静态对象-Local-Static-Object" class="headerlink" title="局部静态对象(Local Static Object)"></a>局部静态对象(Local Static Object)</h3><p>下面一段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Matrix&amp;  <span class="title">identity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="type">static</span> Matrix mat_identity;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>因为静态语意保证了 mat_identity 在整个程序周期都存在，而不会在函数identity()`退出时被析构，</strong>所以：</p><ul><li>mat_identity的构造函数只能被施行一次，虽然identity()可以被调用多次。</li><li>mat_identity 的析构函数只能被施行一次，虽然identity()可以被调用多次。</li></ul><p>那么 mat_identity的构造函数和析构函数到底在什么时候被调用？答案是:mat_identity的构造函数只有在第一次被调用时在被施行，而在整个程序退出之时按构造相反的顺序析构局部静态对象。</p><h3 id="对象数组-Array-of-Objects"><a href="#对象数组-Array-of-Objects" class="headerlink" title="对象数组(Array of Objects)"></a>对象数组(Array of Objects)</h3><p>对于定义一个普通的数组，例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[ <span class="number">10</span> ];</span><br></pre></td></tr></tbody></table></figure><p>实际上背后做的工作则是：</p><ol><li>分配充足的内存以存储10个Point元素；</li><li>为每个Point元素调用它们的默认构造函数(如果有的话，且不论是合成的还<br>是显式定义的)。编译器一般以一个或多个函数来完成这个任务。当数组的<br>生命周期结束的时候，则要逐一调用析构函数，然后回收内存，编译器同样<br>一个或多个函数来完成任务。这些函数完成什么功能，大概都能猜得出来。<br>而关于细节，不必要死扣了，每个编译器肯定都有些许差别。</li></ol><h1 id="零时性对象"><a href="#零时性对象" class="headerlink" title="零时性对象"></a>零时性对象</h1><h3 id="何时生成临时对象"><a href="#何时生成临时对象" class="headerlink" title="何时生成临时对象"></a>何时生成临时对象</h3><p>对于一个下面这样的程序片段：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T a, b;</span><br><span class="line">T c=a+b;</span><br></pre></td></tr></tbody></table></figure><p>死板一点来讲，它应当产生一个临时对象用来存储a+b的结果，然后以临时对象作为初值调用拷贝构造函数初始化对象c。而实际上编译器更愿意直接调用拷贝构造函数的方式将a+b的值放到c中，这样就不需要临时对象，和它的构造函数和拷贝构造函数的调用了。</p><p>更进一步，如果operator +的定义符合NRV优化的条件，那么NRV优化的开启，将使得拷贝构造函数的调用和named object的析构函数都免了。期间详情可以参见”<a href="http://www.roading.org/?p=544">NRV优化</a>”。也就是说对于上面那种情形在我们的代码中是不产生临时对象的。但是对于一个情况非常类似的赋值操作语句<code>c = a+b</code>，却有很大的差别，那个临时变量是不能省的不能忽略临时对象，反而导致如下过程：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pseudo C++ code  // T temp = a + b;  T temp;  a.operator+( temp, b ); // @1 [^注1]// c = temp  c.operator =( temp ); // @2  temp.T::~T();</span></span><br></pre></td></tr></tbody></table></figure><p>在代码@1处，表明以拷贝构造函数或NRV方式将结果保存的临时对象中。为什么不能省略那个临时对象，比如直接这样：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.T::~T();c.T::T(a+b);</span><br></pre></td></tr></tbody></table></figure><p>这不是更高效，更简洁的方式吗？不行，其原因在于，拷贝构造函数、析构函数以及赋值操作符都可以由使用者提供，没有人能保证，析构函数加拷贝构造函数的组合和赋值操作符具有相同的含义。所以：<code>T c=a+b</code>总是比c = a + b<code>更有效率。对于一个没有出现目标对象的表达式</code>a + b`,那么产生一个临时对象来存储运算结果，则是非常必要的。</p><h3 id="临时对象的生命周期"><a href="#临时对象的生命周期" class="headerlink" title="临时对象的生命周期"></a>临时对象的生命周期</h3><p><strong>很多时候，产生临时对象是必不可少的，但是何时摧毁一个临时对象才是最佳行为呢？过早或过晚都不太适合，过早有可能使得程序错误，过晚的话又使得资源没有得到及时回收。</strong>对于下面的程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">s1</span><span class="params">(<span class="string">"hello "</span>)</span>, <span class="title function_">s2</span><span class="params">(<span class="string">"world "</span>)</span>,<span class="title function_">s3</span><span class="params">(<span class="string">"by Adoo"</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;s1+s2+s3&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><p>显然保存<code>s1+s2</code>结果的临时对象，如果在与s3进行加法之前析构，将会带来大麻烦。于是C++标准中有一条：</p><ul><li><strong>临时性对象的摧毁应当作为造成产生这个临时对象的完整表达式的最后一个步骤。</strong></li></ul><p>完整的表达式，是指涵括的表达式中最外围的那个。我们再看上面那个字符串相加的表达式，当计算完成，而cout还未调用，此时我们析构掉存储最终结果的临时对象，岂不悲剧。其实上面的规定还有两个例外：</p><ol><li><p>凡含有表达式执行结果的临时性对象，应该保存到Object的初始化操作完成为止。</p></li><li><p>如果临时性对象被绑定与一个引用，临时对象将残留，直至初始化的引用的生命结束，或直到临时对象的生命周期结束——视哪一种情况先达到，对应于这种情况：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">string</span> <span class="title function_">s1</span><span class="params">(<span class="string">"hello "</span>)</span>;</span><br><span class="line">::<span class="built_in">string</span> &amp;s=s1+<span class="string">"world"</span>;</span><br></pre></td></tr></tbody></table></figure></li></ol><p>[^注1]: 侯捷认为此处为 Lippman 的错误，他认为应该为</p><p><code>temp.operator + ( a, b )</code>但我以为是侯捷并没有理解Lippman的意思，回顾一下,《深度探索对象模型》2.3<strong>讲到的返回值初始化(Return Value Initialization)——返回值将作为一个额外的参数提供给函数，来传回函数内部的值，</strong>也就是说对于一个 operator + 操作符<code>T T::operator+ (const T&amp; right)</code>将转化为<br><code>void T::operator+ (T &amp;result ,const T&amp; right)</code>所以<code>temp=a+b</code>是<strong>a.operator+( temp, b )</strong><code>还是</code>temp.operator+( a, b )`自然不言而喻。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造、析构、拷贝语意学</title>
      <link href="/2022/12/30/gou-zao-xi-gou-kao-bei-yu-yi-xue/"/>
      <url>/2022/12/30/gou-zao-xi-gou-kao-bei-yu-yi-xue/</url>
      
        <content type="html"><![CDATA[<hr><h4 id="1、几点类设计原则"><a href="#1、几点类设计原则" class="headerlink" title="1、几点类设计原则"></a>1、几点类设计原则</h4><p><strong>1.即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数</strong>，来初始化它的数据成员。或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。</p><p><strong>2.不要将析构函数设计为纯虚的，这不是一个好的设计。</strong>将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。一个不能派生继承类的抽象类有什么存在的意义？必须定义纯虚析构函数，而不能仅仅声明它的原因在于：每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的<br>析构函数声明，则去调用它的实体，而不管它有没有被定义。</p><p><strong>3.真的必要的时候才使用虚函数，不要滥用虚函数。</strong>虚函数意味着不<br>小的成本，编译很可能给你的类带来膨胀效应：</p><ul><li>每一个对象要多负担一个word的vptr。</li><li>给每一个构造函数（不论是显示的还是编译器合成的），插入一些代<br>码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，<br>但需在任意用户代码之前。没有构造函数则需要合成，并插入代码。</li><li>合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入<br>对vptr的初始化代码，有的话也需要插入vptr的初始化代码。</li><li>意味着，如果具有bitwise语意，将不再具有，然后是变大的对象、没<br>有那么高效的构造函数，没有那么高效的复制控制。</li></ul><p><strong>4.不能决定一个虚函数是否需要 const ，那么就不要它。</strong></p><p><strong>5.决不在构造函数或析构函数中使用虚函数机制。</strong>在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。这是由vptr初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data语意学</title>
      <link href="/2022/12/16/data-yu-yi-xue/"/>
      <url>/2022/12/16/data-yu-yi-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="1、一个实例引起的思考"><a href="#1、一个实例引起的思考" class="headerlink" title="1、一个实例引起的思考"></a>1、一个实例引起的思考</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> X{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> X{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Y, <span class="keyword">public</span> Z{};</span><br></pre></td></tr></tbody></table></figure><p>Lippman的一个法国读者的结果是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> X yielded <span class="number">1</span>                         </span><br><span class="line"><span class="keyword">sizeof</span> Y yielded <span class="number">8</span>                         </span><br><span class="line"><span class="keyword">sizeof</span> Z yielded <span class="number">8</span>                         </span><br><span class="line"><span class="keyword">sizeof</span> A yielded <span class="number">12</span> </span><br></pre></td></tr></tbody></table></figure><p>而我在VS2019，win10，64bit上以及Linux环境下的Ubuntu下输出都是</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> X yielded <span class="number">1</span>   </span><br><span class="line"><span class="keyword">sizeof</span> Y yielded <span class="number">8</span>  </span><br><span class="line"><span class="keyword">sizeof</span> Z yielded <span class="number">8</span>    </span><br><span class="line"><span class="keyword">sizeof</span> Z yielded <span class="number">16</span>   </span><br></pre></td></tr></tbody></table></figure><h3 id="C-类的大小计算汇总，这篇文章讲的非常好："><a href="#C-类的大小计算汇总，这篇文章讲的非常好：" class="headerlink" title="C++类的大小计算汇总，这篇文章讲的非常好："></a>C++类的大小计算汇总，这篇文章讲的非常好：</h3><p><a href="https://www.cnblogs.com/fengyaoyao/p/10262312.html">https://www.cnblogs.com/fengyaoyao/p/10262312.html</a></p><p>先贴几个重要结论：</p><ul><li><strong>类大小的计算，遵循结构体的对齐原则；</strong></li><li><strong>类的大小，与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员，均对类的大小无影响；</strong></li><li><strong>虚函数对类的大小有影响，是因为虚函数表指针带来的影响；</strong></li><li><strong>虚继承对类的大小有影响，是因为虚基表指针带来的影响；</strong></li><li><strong>静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区；</strong></li></ul><p>1、空类的大小</p><p>C++的空类是指这个类不带任何数据，即类中没有非静态(non-static)数据成员变量，没有虚函数(virtual function)，也没有虚基类(virtual base class)。</p><p>　　直观地看，空类对象不使用任何空间，因为没有任何隶属对象的数据需要存储。然而，C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小。换句话说，c++空类的大小不为0 。</p><p>计算结果1。</p><p>　　C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。</p><p>　　这是由于：</p><ul><li>new需要分配不同的内存地址，不能分配内存大小为0的空间；</li><li>避免除以 sizeof(T)时得到除以0错误；</li></ul><p>　　故使用一个字节来区分空类。</p><p>　　但是，有两种情况值得我们注意</p><p>　　第一种情况，空类的继承： </p><p>　　当派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。sizeof(D)为4。</p><p>　　第二种情况，一个类包含一个空类对象数据成员：</p><p>sizeof(HoldsAnInt)为8。 </p><p>　　在这种情况下，空类的1字节是会被计算进去的。而又由于字节对齐的原则，所以结果为4+4=8。</p><p>　　继承空类的派生类，如果派生类也为空类，大小也都为1。</p><p>2、含有虚函数成员的类</p><p>　　虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。</p><p>　　每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就会为这个类创建一个虚函数表（VTABLE）保存该类所有虚函数的地址，其实这个VTABLE的作用就是保存自己类中所有虚函数的地址，可以把VTABLE形象地看成一个函数指针数组，这个数组的每个元素存放的就是虚函数的地址。在每个带有虚函数的类中，编译器秘密地置入一指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。 当构造该派生类对象时，其成员VPTR被初始化指向该派生类的VTABLE。<strong>所以可以认为VTABLE是该类的所有对象共有的，在定义该类时被初始化；而VPTR则是每个类对象都有独立一份的，且在该类对象被构造时被初始化。</strong> </p><p>3、基类含有虚函数的继承</p><p>1）虚函数按照其声明顺序放于表中。</p><p>2）基类的虚函数在派生类的虚函数前面。</p><p>1）覆盖的f()函数被放到了虚表中原来基类虚函数的位置；</p><p>2）没有被覆盖的函数依旧；</p><p>3）派生类的大小仍是基类和派生类的非静态数据成员的大小+一个vptr指针的大小；</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>    </span><br><span class="line">{    </span><br><span class="line">};   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>    </span><br><span class="line">{ </span><br><span class="line">    <span class="type">char</span> ch;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>{  }  </span><br><span class="line">};  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>   </span><br><span class="line">{ </span><br><span class="line">    <span class="type">char</span> ch1; </span><br><span class="line">    <span class="type">char</span> ch2; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>{  }   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>{  }  </span><br><span class="line">}; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> C </span><br><span class="line">{    </span><br><span class="line">    <span class="type">int</span> d;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span>  </span>{  }  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>{  } </span><br><span class="line">};    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C </span><br><span class="line">{    </span><br><span class="line">    <span class="type">int</span> e;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func0</span><span class="params">()</span>  </span>{  }  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span>  </span>{  } </span><br><span class="line">}; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    cout&lt;&lt;<span class="string">"A="</span>&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;    <span class="comment">//result=1 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">"B="</span>&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;    <span class="comment">//result=16     </span></span><br><span class="line">    cout&lt;&lt;<span class="string">"C="</span>&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl;    <span class="comment">//result=16 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">"D="</span>&lt;&lt;<span class="built_in">sizeof</span>(D)&lt;&lt;endl;    <span class="comment">//result=16 </span></span><br><span class="line">    cout&lt;&lt;<span class="string">"E="</span>&lt;&lt;<span class="built_in">sizeof</span>(E)&lt;&lt;endl;    <span class="comment">//result=32 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>　　结果分析: </p><p>　　1.A为空类，所以大小为1 ；</p><p>　　2.B的大小为char数据成员大小+vptr指针大小。由于字节对齐,大小为8+8=16 ；</p><p>　　3.C的大小为两个char数据成员大小+vptr指针大小。由于字节对齐，大小为8+8=16 ；</p><p>　　4.D为多继承派生类，由于D有数据成员，所以继承空类A时，空类A的大小1字节并没有计入当中，D继承C，此情况D只需要一个vptr指针，所以大小为数据成员加一个指针大小。由于字节对齐,大小为8+8=16 ；</p><p>　　5.E为多继承派生类，此情况为我们上面所讲的多重继承，含虚函数覆盖的情况。此时大小计算为数据成员的大小+2个基类虚函数表指针大小 ，考虑字节对齐，继承顺序B在先，B(8 + 1)，然后是C(8+1+1)，由于字节对齐，B得与C中最大值对齐，因此B+7变成16，再+C（10），得26，最后+E的其它成员+1，因为要整体对于最大值（8）对齐，因此补齐得32。（之前看到几篇博客这里解释得都有问题）</p><p>3.虚继承的情况</p><p>　　对虚继承层次的对象的内存布局，在不同编译器实现有所区别。 </p><p>　　在这里，只说一下在gcc编译器下，虚继承大小的计算。它在gcc下实现比较简单，不管是否虚继承，GCC都是将虚表指针在整个继承关系中共享的，不共享的是指向虚基类的指针。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a;　<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfuncA</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A{</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunB</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A{</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunC</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B,<span class="keyword">public</span> C{</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myfunD</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>sizeof(A)=16，sizeof(B)=24，sizeof(C)=24，sizeof(D)=48；</p><p>　　A的大小为int大小加上虚表指针大小;</p><p>　　B，C中由于是虚继承，因此大小为int大小加指向虚基类的指针的大小。B,C虽然加入了自己的虚函数，但是虚表指针是和基类共享的，因此不会有自己的虚表指针，他们两个共用虚基类A的虚表指针。D由于B，C都是虚继承，其大小等于B+C）。</p><h3 id="2、在VC中数据成员的布局顺序为："><a href="#2、在VC中数据成员的布局顺序为：" class="headerlink" title="2、在VC中数据成员的布局顺序为："></a>2、在VC中数据成员的布局顺序为：</h3><ol><li>vptr部分（如果基类有，则继承基类的）</li><li>vbptr （如果需要）</li><li>基类成员（按声明顺序）</li><li>自身数据成员</li><li>虚基类数据成员（按声明顺序）</li></ol><h3 id="3、虚拟成员函数"><a href="#3、虚拟成员函数" class="headerlink" title="3、虚拟成员函数"></a>3、虚拟成员函数</h3><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p-&gt;function()   将转化为</span></span><br><span class="line">(*p-&gt;vptr[<span class="number">1</span>])(p);</span><br></pre></td></tr></tbody></table></figure><ul><li><p>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</p></li><li><p>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().</p></li></ul><p>何时发生这种转换？<strong>答案是在必需的时候</strong>——一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。</p><h3 id="4、静态成员函数"><a href="#4、静态成员函数" class="headerlink" title="4、静态成员函数"></a>4、静态成员函数</h3><p>静态成员函数的一些特性：</p><ol><li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态<br>成员函数(Nonstatic Member Functions)。</li><li>不能够声明为 const、voliatile或virtual。</li><li>它不需经由对象调用，当然，通过对象调用也被允许。</li></ol><p>除了缺乏一个this指针他与非静态成员函数没有太大的差别。在这里通过对象调用和通过指针或引用调用，将被转化为同样的调用代码。</p><p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：(a+=b).static_fuc();</p><p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间。这无疑是一个明智的规定。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数语义学</title>
      <link href="/2022/12/14/gou-zao-han-shu-yu-yi-xue/"/>
      <url>/2022/12/14/gou-zao-han-shu-yu-yi-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="0、通常很多C-程序员存在两种误解："><a href="#0、通常很多C-程序员存在两种误解：" class="headerlink" title="0、通常很多C++程序员存在两种误解："></a>0、通常很多C++程序员存在两种误解：</h3><ul><li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li><li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li></ul><p>在读《深度探索C++对象模型》之前，我一直停留在上述二种误解上，所幸的是<br>Lippman为我破除了藩篱。下面的部分我将随《深度探索C++对象模型》对C++默<br>认构造函数一探究竟。</p><p>C++标准规定：如果类的设计者并未为类定义任何构造函数，那么会有一个默认<br>构造函数被暗中生成，而这个暗中生成的默认构造函数通常是不做什么事的(无<br>用的)，下面四种情况除外。</p><p>换句话说，有以下四种情况编译器必须为未声明构造函数的类生成一个会做点事<br>的默认构造函数。我们会看到这些默认构造函数仅“忠于编译器”，而可能不会按<br>照程序员的意愿程效命。</p><h3 id="1-包含有带默认构造函数的对象成员的类"><a href="#1-包含有带默认构造函数的对象成员的类" class="headerlink" title="1.包含有带默认构造函数的对象成员的类"></a>1.包含有带默认构造函数的对象成员的类</h3><p>若一个类X没有定义任何构造函数，但却包含一个或以上定义有默认构造函数的<br>对象成员，此时编译器会为X合成默认构造函数，该默认函数会调用对象成员的<br>默认构造函数为之初始化。如果对象的成员没有定义默认构造函数，那么编译器<br>合成的默认构造函数将不会为之提供初始化。例如类A包含两个数据成员对象，<br>分别为：<code>string str</code>和<code>char *Cstr</code>，那么编译器生成的默认构造函数将只提<br>供对string类型成员的初始化，而不会提供对char*类型的初始化。</p><p>假如类X的设计者为X定义了默认的构造函数来完成对str的初始化，形如：<br><code>A::A(){Cstr=”hello”};</code>因为默认构造函数已经定义，编译器将不能再生成一<br>个默认构造函数。但是编译器将会扩充程序员定义的默认构造函数——在最前面插<br>入对初始化str的代码。若有多个定义有默认构造函数的成员对象，那么这些成员<br>对象的默认构造函数的调用将依据声明顺序排列。</p><h3 id="2-继承自带有默认构造函数的基类的类"><a href="#2-继承自带有默认构造函数的基类的类" class="headerlink" title="2.继承自带有默认构造函数的基类的类"></a>2.继承自带有默认构造函数的基类的类</h3><p>如果一个没有定义任何构造函数的类派生自带有默认构造函数的基类，那么编译<br>器为它定义的默认构造函数，将按照声明顺序为之依次调用其基类的默认构造函<br>数。若该类没有定义默认构造函数而定义了多个其他构造函数，那么编译器扩充<br>它的所有构造函数——加入必要的基类默认构造函数。另外，编译器会将基类的默<br>认构造函数代码加在对象成员的默认构造函数代码之前。</p><h3 id="3-带有虚函数的类"><a href="#3-带有虚函数的类" class="headerlink" title="3.带有虚函数的类"></a>3.带有虚函数的类</h3><p>带有虚函数的类，与其它类不太一样，因为它多了一个vptr，而vptr的设置是由<br>编译器完成的，因此编译器会为类的每个构造函数添加代码来完成对vptr的初始<br>化。</p><h3 id="4-带有一个虚基类的类"><a href="#4-带有一个虚基类的类" class="headerlink" title="4.带有一个虚基类的类"></a>4.带有一个虚基类的类</h3><p>在这种情况下，编译器要将虚基类在类中的位置准备妥当，提供支持虚基类的机<br>制。也就是说要在所有构造函数中加入实现前述功能的的代码。没有构造函数将<br>合成以完成上述工作。</p><p>总结：简单来讲编译器会为构造函数做的一点事就是调用其基类或成员对象的默<br>认构造函数，以及初始化vprt以及准备虚基类的位置。</p><p>总的来说，编译器将对构造函数动这些手脚：</p><ul><li>如果类虚继承自基类，编译器将在所有构造函数中插入准备虚基类位置的代<br>码和提供支持虚基类机制的代码。</li><li>如果类声明有虚函数，那么编译器将为之生成虚函数表以存储虚函数地址，<br>并将虚函数指针（vptr）的初始化代码插入到类的所有构造函数中。</li><li>如果类的父类有默认构造函数，编译将会对所有的默认构造函数插入调用其<br>父类必要的默认构造函数。必要是指设计者没有显示初始化其父类，调用顺<br>序，依照其继承时声明顺序。</li><li>如果类包含带有默认构造函数的对象成员，那么编译器将会为所有的构造函<br>数插入对这些对象成员的默认构造函数进行必要的调用代码，所谓必要是指<br>类设计者设计的构造函数没有对对象成员进行显式初始化。成员对象默认构<br>造函数的调用顺序，依照其声明顺序。</li><li>若类没有定义任何构造函数，编译器会为其合成默认构造函数，再执行上述<br>四点。</li></ul><p>【2011/12/21 补】需要说明的是，从概念来上来讲，每一个没有定义构造函数<br>的类都会由编译器来合成一个默认构造函数，以使得可以定义一个该类的对象，<br>但是默认构造函数是否真的会被合成，将视是否有需要而定。C++ standard 将<br>合成的默认构造函数分为 trivial 和 notrivial 两种，前文所述的四种情况对<br>应于notrivial默认构造函数，其它情况都属于trivial。对于一个trivial默认<br>构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清<br>的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要<br>的东西就不要。</p><h3 id="5、命名返回值优化"><a href="#5、命名返回值优化" class="headerlink" title="5、命名返回值优化"></a>5、命名返回值优化</h3><p>对于一个如<code>foo()</code>这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以引用的方式传入一个参数<code>result</code>取代返回对象。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span> <span class="comment">//原型</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    X xx; </span><br><span class="line">    <span class="keyword">if</span>(...) </span><br><span class="line">        returnxx; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        returnxx; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优化后的<code>foo()</code>以<code>result</code>取代<code>xx</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">foo</span><span class="params">(X &amp;result)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    result.X::<span class="built_in">X</span>();</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对比优化前与优化后的代码可以看出，对于一句类似于<code>X a = foo()</code>这样的代<br>码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同<br>时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝<br>构造函数的调用，增加了一次对a的默认构造函数的调用）。</p><p>注：Lippman在《深度探索C++》书中指出NRV的开启与关闭取决于是否有显式定义一个拷贝构造函数，我实在想不出有什么理由必须要有显示拷贝构造函数才能开启NRV优化，于是在vs2010中进行了测试，测试结果表明，在release版本中，不论是否定义了一个显式拷贝构造函数，NRV都会开启。由此可见vs2010并不以是否有一个显式拷贝构造函数来决定NRV优化的开启与否。但同时，立足于这一点，可以得出Lippman所说的以是否有一个显式定义的拷贝构造函数来决定是否开启NRV优化，应该指的是他自己领导实现的cfront编译器，而非泛指所有编译器。那么cfront又为什么要以是否定义有显示的拷贝构造函数来决定是否开启NRV优化呢？我猜测，他大概这样以为，当显式定义有拷贝构造函数的时候一般代表着要进行深拷贝，也就是说此时的拷贝构造函数将费时较长，在这样的情况下NRV优化才会有明显的效果。反之，不开启NRV优化也不是什么大的效率损失。</p><p>另外，有一点要注意的是，NRV优化，有可能带来程序员并不想要的结果，最明显的一个就是——当你的类依赖于构造函数或拷贝构造函数，甚至析构函数的调用次数的时候，想想那会发生什么。由此可见、Lippman的cfront对NRV优化抱有更谨慎的态度，而MS显然是更大胆。</p><h3 id="6、成员初始化队列（Member-Initialization-List）"><a href="#6、成员初始化队列（Member-Initialization-List）" class="headerlink" title="6、成员初始化队列（Member Initialization List）"></a>6、成员初始化队列（Member Initialization List）</h3><p>对于初始化队列，我相信厘清一个概念是非常重要的：在构造函数中对于对象<br>成员的初始化发生在初始化队列中——或者我们可以把初始化队列直接看做是对<br>成员的定义，而构造函数体中进行的则是赋值操作。所以不难理解有四种情况<br>必须用到初始化列表：</p><ul><li>有const成员</li><li>有引用类型成员</li><li>成员对象没有默认构造函数</li><li>基类对象没有默认构造函数</li></ul><p>前两者因为要求定义时初始化，所以必须明确的在初始化队列中给它们提供初<br>值。后两者因为不提供默认构造函数，所有必须显示的调用它们的带参构造函<br>数来定义即初始化它们。</p><p>显而易见的是当类中含有对象成员或者继承自基类的时候，在初始化队列中初<br>始化成员对象和基类子对象会在效率上得到提升——省去了一些赋值操作嘛。</p><p>最后，一个关于初始化队列众所周知的陷阱，初始化队列的顺序，请参考《C++<br>primer》或者《深度探索C++对象模型》。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>{</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val):<span class="built_in">j</span>(val),<span class="built_in">i</span>(j) {}</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段程序是要将j的初始值设置为val，再将i设置为j，但是由于声明顺序的原因，initialzation list中的 i(j) 其实要比 j(val) 更早执行的，所以这是会导致一定的错误出现。</p><p>下面是回一个比较喜欢的解决方式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>{</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val):<span class="built_in">j</span>(val) {</span><br><span class="line">        i = j;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>initialzation list的执行先于 用户自定义的函数体，因此这样写就有效解决了上述问题。</p><p>总的来说：编辑器会对initialzation list一一处理并可能重新排列，以反映出members的声明顺序，它会安插一些代码到 constructor 体内，并置于任何 explicit user code之前。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对象</title>
      <link href="/2022/12/09/guan-yu-dui-xiang/"/>
      <url>/2022/12/09/guan-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="1、C-在布局以及存取时间上的主要负担是有virtual引起的，这其中包括"><a href="#1、C-在布局以及存取时间上的主要负担是有virtual引起的，这其中包括" class="headerlink" title="1、C++在布局以及存取时间上的主要负担是有virtual引起的，这其中包括"></a>1、C++在布局以及存取时间上的主要负担是有virtual引起的，这其中包括</h4><p>1、virtual function机制 ：用以支持一个有效率的“执行期绑定的”</p><p>2、virtual base class：用以实现“多次出现在继承体系中的base class，有一个单一而被共享的实例”</p><h4 id="2、C-有三种方式支持多态"><a href="#2、C-有三种方式支持多态" class="headerlink" title="2、C++有三种方式支持多态"></a>2、C++有三种方式支持多态</h4><p>1、经由一组隐式的转化操作，比如将派生类指针转化为指向其基类的指针  shape *ps =new circle();</p><p>2、经由virtual  function机制  ps-&gt;rotate()</p><p>3、经由dynamic_cast 和typeid运算符</p><p>if(circle *pc = dynamic_cast&lt;circle *&gt; (ps))</p><h4 id="3、一个类的对象的内存大小包括："><a href="#3、一个类的对象的内存大小包括：" class="headerlink" title="3、一个类的对象的内存大小包括："></a>3、一个类的对象的内存大小包括：</h4><ul><li><p>所有非静态数据成员的大小。</p></li><li><p>由内存对齐而填补的内存大小。</p></li><li><p>为了支持virtual有内部产生的额外负担。</p><p>如下类：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span> {  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">ZooAnimal</span>();  </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">    <span class="type">int</span> loc;  </span><br><span class="line">    String name;  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ul><p>在32位计算机上所占内存为16字节：int四字节，String8字节（一个表示长度的整形，一个指向字符串的指针），以及一个指向虚函数表的指针vptr。对于继承类则为基类的内存大小加上本身数据成员的大小。</p><h4 id="4、C-类包含两种数据成员：静态数据成员和非静态数据成员；同时包含成员函数，静态函数和虚函数三种成员函数"><a href="#4、C-类包含两种数据成员：静态数据成员和非静态数据成员；同时包含成员函数，静态函数和虚函数三种成员函数" class="headerlink" title="4、C++类包含两种数据成员：静态数据成员和非静态数据成员；同时包含成员函数，静态函数和虚函数三种成员函数"></a>4、C++类包含两种数据成员：静态数据成员和非静态数据成员；同时包含成员函数，静态函数和虚函数三种成员函数</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 深度探索C++对象模型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
